{"posts":[{"title":"Day1:x86汇编框架、数据类型、基本运算、位运算","text":"vs2022汇编环境、x86汇编框架、数据类型、基本运算、位运算 在vs2022中编写汇编代码 新建一个空项目 在工具栏的“工具”选项中选择“获取工具和功能”，在“使用C++的桌面开发”中勾选“Windows 10 SDK”以及“MSVC v142 -VS 2015 C++生成工具”，然后安装这些新勾选的选项，更新VS2022 右键新建的空项目，选择最下方的“属性”，在弹出来的页面中选择“常规”，然后将平台版本改成windows10，可能需要改也可能不需要 右键新建的空项目，选择“生成依赖性”，然后是“生成自定义”，在界面中选择masm 然后就可以新建一个.asm源文件了。新建完成后，右键源文件选择“属性”，然后在“常规”里检查项类型是否为“Microsoft Macro Assembler” 以上是针对报错进行的尝试修正总结，可能有多余或者不足之处 x86汇编框架(MASM) xxxxxxxxxx2 1int num[2][2] = { {1,2},{3,4} };2printf(“%d,%d,%d,%d”, num[0][0], num[0][1], num[1][0], num[1][1]);c 123456789101112131415161718192021222324252627;预处理.586.model flat,stdcall;包含的链接库includelib ucrt.libincludelib legacy_stdio_definitions.libincludelib kernel32.libincludelib user32.lib;外部函数声明extern printf:proc;数据段.dataszHello db 'HelloWorld!',0;代码段.code;函数声明main proc lea eax,szHello push eax call printf add esp,4main endpend 重点如下： 链接库声明 1includelib NameOfLib.lib 不同的段 12.NameOfSection;段所包含的数据 函数格式 123functionName proc 参数名1:参数类型，参数名2:参数类型... ;汇编代码functionName endp 在一个asm文件末尾，需要 12end ;用于无入口点，即非可执行文件，不需要主函数时end main ;用于可执行文件，必须指定入口点(如main函数)时 数据类型 类型名称 简写 对应类型 占用字节数 BYTE db char 1 WORD dw short 2 DWORD dd int 4 QWORD dq long long 8 基本运算 数据传送指令 1234mov dest,src ;dest=src;eax=1示例mov eax,1 地址传送指令 1234lea dest,[addr] ;dest=addr;eax=77E75F38示例lea eax,77E75F38 加法 12345add dest,src ;dest=dest+src;1+1=2示例，最后eax里为2mov eax,1add eax,1 自增 1234inc dest ;dest=dest+1;eax++示例inc eax 减法 12345sub dest,src ;dest=dest-src;6-2=4示例，最后eax里为4mov eax,6sub eax,2 自减 1234dec dest ;dest=dest-1;eax--示例dec eax 乘法 1234567891011;分为mul(无符号)和imul(有符号);乘法结果存放在edx和eax中(edx:eax)，低位eax，高位edx。未指定时，eax默认作为一个因数mul src ;edx:eax=eax*srcimul src ;edx:eax=eax*srcimul dest,src ;dest=dest*srcimul dest,src,imm ;dest=src*imm;4*2=8示例，eax*ebxmov eax,4mov ebx,2mul ebx 除法 12345678910;分为div(无符号)和idiv(有符号);被除数放在edx:eax中，除数任意，商存放在eax中，余数存放在edx中div src ;edx:eax%src=eax...edxidiv src ;edx:eax%src=eax...edx;101%2...1示例mov eax,101mov edx,0mov ebx,2div ebx 位运算 与 123456and dest,src ;dest=dest &amp; src;1&amp;2=0示例mov eax,1mov ebx,2and eax,ebx 或 123456or dest,src ;dest=dest | src;1|2=3示例mov eax,1mov ebx,2or eax,ebx 取反 12345not dest ;dest=~dest;not 00000001=11111110示例mov eax,1not eax 异或 123456xor dest,src ;dest=dest^src;1^2=3示例mov eax,1mov ebx,2xor eax,ebx 左移，右移 123456789101112131415;左移shl dest,count ;dest=dest&lt;&lt;count;1&lt;&lt;3=8示例mov eax,1mov cl,3shl eax,cl;右移shr dest,count ;dest=dest&gt;&gt;count;8&gt;&gt;3=1示例mov eax,8mov cl,3shr eax,cl","link":"/2025/07/05/Day1-x86%E6%B1%87%E7%BC%96%E6%A1%86%E6%9E%B6/"},{"title":"Day1:数据结构与复杂度","text":"数据结构简述、复杂度初探 数据结构简述 “数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法”，这是Hello 算法中给出的定义。数据结构是人为创造的、服务于数据存储与处理的一种规范，我们可以根据一种数据结构的概念，用不同的语言、不同的特性来实现它。 数据主要有两种存储结构：顺序存储和链式存储。这两种存储结构是后续各种数据结构实现的基础。 顺序存储，就是数据存储在连续的内存空间上。 链式存储，就是数据存储在不连续的内存空间上，但是每个内存单位之间又有联系，像链条一样串联在一起。 数据结构按照逻辑特征可以分为四种：线性结构、图结构、树形结构、集合结构。 抽象数据类型(ADT)：用于描述数据结构的一种模型，包括了结构特性的描述、相关的运算函数描述。ADT和类很像，但是ADT更像是用代码实现具体数据结构前列的的提纲。 算法是对数据进行处理的策略，即运算方法。算法会依赖数据结构来实现。算法追求效率，即更短的运算时间和更少的资源占用。 复杂度 算法追求时间和空间上的效率，所以描述一个算法的复杂度分为两种：时间复杂度和空间复杂度。 时间复杂度评估的是一段代码的运行时间，由于计算机执行操作的时间都很短，所以时间复杂度的评估往往等同于操作次数的评估。我们通常说的时间复杂度实际上是渐进时间复杂度。标准的时间复杂度考虑代码中所有的操作，比如赋值会记1次操作，两个变量相加会记1次操作等。渐进时间复杂度则只考虑操作数的量级，所以关注的往往是代码中的关键操作。 所谓关键操作，一般是指操作边界含n，即操作的边界含有变量、不同情况下边界不同的的操作。如 1234567int sum(int n){ int sum=0; for(int i=1;i&lt;=n;i++){ sum+=n; } return sum;} 其中，for循环中的操作执行次数依赖于边界n，这就是我们需要关注的地方。 以这段代码为例，给sum赋值的语句记1次操作，for循环中，给i赋值记1次操作，i的边界判断记n+1次操作（因为i自增到n+1还会到i&lt;=n这里来进行边界判断），for循环中sum累加记n次操作，返回sum记1次操作。这样子，这段代码总共进行了2n+4次操作，只考虑量级的话就是n。 对于渐进时间复杂度，采用大O表示法：O(算法量级)。如上面这段代码，量级为n，渐进时间复杂度记为O(n)。 空间复杂度评估的是一段代码占用的内存空间。空间复杂度和时间复杂度类似，通常只考虑量级，但此处是占用内存空间的量级。内存空间的占用比较直观，关注的重点依旧是边界包含变量的操作，记录的是操作带来的内存空间占用情况。如赋值操作，记1个单位的空间占用；创建长度为n的数组，记n个单位的空间占用等。还用上面的代码为例子，sum赋值记1个单位，i赋值记1个单位，所以这段代码总共就占用2个单位的内存空间，量级为1，空间复杂度记为O(1)。 常见操作的时间复杂度和空间复杂度： 语句/操作 时间复杂度 空间复杂度 说明 赋值操作 (a = b) O(1) O(1) 基本数据类型赋值 算术运算 (+, -, *, /, %) O(1) O(1) 固定大小数值运算 比较操作 (==, !=, &lt;, &gt;) O(1) O(1) 基本数据类型比较 数组索引 (arr[i]) O(1) O(1) 随机访问 函数调用 O(1) O(1) 调用开销本身 if-else O(1) O(1) 条件判断本身 switch-case O(1) O(1) 跳转表实现 goto O(1) O(1) 跳转指令 单层for循环 O(n) O(1) 循环n次，体为O(1) 嵌套for循环 O(n²) O(1) 两层各n次循环 while循环 O(n) O(1) 循环n次，体为O(1) do-while循环 O(n) O(1) 循环n次，体为O(1) 递归调用 O(n) O(n) 线性递归，n为深度 尾递归优化 O(n) O(1) 编译器优化后 函数返回 O(1) O(1) 栈帧销毁 malloc/new O(1) O(n) 分配n字节内存 free/delete O(1) O(1) 释放内存 内存拷贝 O(n) O(1) 拷贝n字节 内存设置 O(n) O(1) 设置n字节 try-catch O(1) O(1) 无异常时开销 throw抛出 O(n) O(1) n为调用栈深度 异常捕获 O(1) O(1) 匹配异常类型","link":"/2025/09/18/Day1-%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"title":"Day12:反调试（一）","text":"反调试基本原理、WINAPI检测、数据检测、进程检测 反调试基本原理 反调试技术通常借助操作系统相关的内容来实现，常见办法有调用WindowsAPI获得相关数据、有意触发异常监测异常处理（调试器会捕获异常）、时间差检测（实际运行过程十分迅速）、硬件断点检测、进程检测等 WINAPI检测 由于是直接使用WINAPI，所以一般在IDA或者动态调试器里会有明显的函数名字样，识别会比较容易 此类一般是利用函数的返回值或者函数传递回来的参数作为判断标准，应对方法主要有使用反反调试插件、修改相关值、hook等 IsDebuggerPresent 原理： IsDebuggerPresent() 实际上是通过访问PEB（ProcessEnvironmentBlock，进程环境块，一个描述进程相关数据的结构体）中的BeingDebugged标志来判断是否被调试的，被调试的话，函数返回1。有关BeingDebugged的内容，见下文。 IDA和XDbg的效果图： 可以看到明显的IsDebuggerPresent字样。 应对方法： 在XDbg中开启scyllahide插件或者在TEST EAX,EAX后改变一下ZF就可以了 CheckRemoteDebuggerPresent 原理： 函数原型： 1234BOOL WINAPI CheckRemoteDebuggerPresent( In HANDLE hProcess,//参数1，一个进程句柄，传入当前进程句柄就是checklocal了 Inout PBOOL pbDebuggerPresent//参数2，一个用来传递的布尔值，用来表示是否被调试); 这个函数实际上是借用了NtQueryInfomationProcess函数来实现调试检测的，简单讲就是通过NtQueryInformationProcess查询一个数据然后和非调试状态下这个数据预期的值进行比较，比较结果再传给自己的参数2。更详细的原理见下一个API 效果图： 应对方法： scyllahide依旧管用，也可以在call CheckRemoteDebuggerPresent下面的cmp后改变zf来实现反反调试 NtQueryInformationProcess 原理： 函数原型： 1234567__kernel_entry NTSTATUS NtQueryInformationProcess( IN HANDLE ProcessHandle,//要查询的进程句柄 IN PROCESSINFOCLASS ProcessInformationClass,//要查询的信息类型 OUT PVOID ProcessInformation,//接收查询结果的缓冲区（变量） IN ULONG ProcessInformationLength,//缓冲区大小 OUT PULONG ReturnLength OPTIONAL//实际返回的数据大小，可选); 通过设置第二个参数为0x7（表示查询一个叫ProcessDebugPort的变量），函数会通过第三个参数传递调试信息，被调试则传递非0 或者设置第二个参数为0x1E（表示查询一个叫ProcessDebugObjectHandle的变量），被调试则传递非NULL 或者设置第二个参数为0x1F（表示查询一个叫ProcessDebugFlags的变量），被调试则传递0 原型是这样，但是这个函数是Windows内部API，即系统不想用户使用这个函数（可能是出于安全考虑），所以直接调用是不行的，要动态加载。下面是DS给的实现源码参考： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// 1. 定义函数指针类型（必须手动声明）typedef LONG NTSTATUS;typedef NTSTATUS (NTAPI* PNtQueryInformationProcess)( HANDLE ProcessHandle, int ProcessInformationClass, // 直接使用 int 代替 PROCESSINFOCLASS PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);int main() { // 2. 动态加载 ntdll.dll HMODULE hNtdll = GetModuleHandleW(L&quot;ntdll.dll&quot;); if (!hNtdll) { printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0; } // 3. 获取 NtQueryInformationProcess 函数地址 PNtQueryInformationProcess NtQueryInformationProcess = (PNtQueryInformationProcess)GetProcAddress(hNtdll, &quot;NtQueryInformationProcess&quot;); if (!NtQueryInformationProcess) { printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0; } // 4. 调用函数查询调试端口（0x7 = ProcessDebugPort） DWORD debugPort = 0; NTSTATUS status = NtQueryInformationProcess( GetCurrentProcess(), 0x7, // ProcessDebugPort &amp;debugPort, sizeof(debugPort), NULL ); // 5. 严格按照你的逻辑输出 if (debugPort) printf(&quot;bye\\n&quot;); else printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0;} 下面是IDA的反汇编结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105.text:000000014007E130 sub_14007E130 proc near ; CODE XREF: sub_14007920B↑j.text:000000014007E130 ; DATA XREF: .pdata:00000001401AB818↓o.text:000000014007E130.text:000000014007E130 var_180 = byte ptr -180h.text:000000014007E130 var_160 = qword ptr -160h.text:000000014007E130 var_150 = byte ptr -150h.text:000000014007E130 hModule = qword ptr -148h.text:000000014007E130 var_128 = qword ptr -128h.text:000000014007E130 var_10C = dword ptr -10Ch.text:000000014007E130 var_EC = dword ptr -0ECh.text:000000014007E130 var_18 = qword ptr -18h.text:000000014007E130.text:000000014007E130 ; __unwind { // j___GSHandlerCheck.text:000000014007E130 push rbp.text:000000014007E132 push rdi.text:000000014007E133 sub rsp, 178h.text:000000014007E13A lea rbp, [rsp+30h].text:000000014007E13F lea rdi, [rsp+180h+var_150].text:000000014007E144 mov ecx, 22h ; '&quot;'.text:000000014007E149 mov eax, 0CCCCCCCCh.text:000000014007E14E rep stosd.text:000000014007E150 mov rax, cs:__security_cookie.text:000000014007E157 xor rax, rbp.text:000000014007E15A mov [rbp+150h+var_18], rax.text:000000014007E161 lea rcx, unk_1401B80A2.text:000000014007E168 call sub_14007A313.text:000000014007E16D nop.text:000000014007E16E lea rcx, ModuleName ; &quot;ntdll.dll&quot;.text:000000014007E175 call cs:GetModuleHandleW ;此处加载ntdll库.text:000000014007E17B mov [rbp+150h+hModule], rax.text:000000014007E17F cmp [rbp+150h+hModule], 0.text:000000014007E184 jnz short loc_14007E1A7.text:000000014007E186 lea rcx, aHello ; &quot;hello\\n&quot;.text:000000014007E18D call sub_14007886F.text:000000014007E192 nop.text:000000014007E193 lea rcx, aPause ; &quot;pause&quot;.text:000000014007E19A call sub_140078810.text:000000014007E19F nop.text:000000014007E1A0 xor eax, eax.text:000000014007E1A2 jmp loc_14007E240.text:000000014007E1A7 ; ---------------------------------------------------------------------------.text:000000014007E1A7.text:000000014007E1A7 loc_14007E1A7: ; CODE XREF: sub_14007E130+54↑j.text:000000014007E1A7 lea rdx, ProcName ; &quot;NtQueryInformationProcess&quot;.text:000000014007E1AE mov rcx, [rbp+150h+hModule] ; hModule.text:000000014007E1B2 call cs:GetProcAddress ;此处获取NtQueryInformationProcess函数地址.text:000000014007E1B8 mov [rbp+150h+var_128], rax ;此处把函数地址传给局部变量.text:000000014007E1BC cmp [rbp+150h+var_128], 0.text:000000014007E1C1 jnz short loc_14007E1E1.text:000000014007E1C3 lea rcx, aHello ; &quot;hello\\n&quot;.text:000000014007E1CA call sub_14007886F.text:000000014007E1CF nop.text:000000014007E1D0 lea rcx, aPause ; &quot;pause&quot;.text:000000014007E1D7 call sub_140078810.text:000000014007E1DC nop.text:000000014007E1DD xor eax, eax.text:000000014007E1DF jmp short loc_14007E240.text:000000014007E1E1 ; ---------------------------------------------------------------------------.text:000000014007E1E1.text:000000014007E1E1 loc_14007E1E1: ; CODE XREF: sub_14007E130+91↑j.text:000000014007E1E1 mov [rbp+150h+var_10C], 0.text:000000014007E1E8 call cs:GetCurrentProcess .text:000000014007E1EE mov [rsp+180h+var_160], 0.text:000000014007E1F7 mov r9d, 4 ;缓冲区大小.text:000000014007E1FD lea r8, [rbp+150h+var_10C] ;接收结果的缓冲区.text:000000014007E201 mov edx, 7 ;指定查询的信息类型.text:000000014007E206 mov rcx, rax ;查询的进程句柄.text:000000014007E209 call [rbp+150h+var_128] ;调用NtQueryInformationProcess.text:000000014007E20C mov [rbp+150h+var_EC], eax.text:000000014007E20F cmp [rbp+150h+var_10C], 0.text:000000014007E213 jz short loc_14007E224.text:000000014007E215 lea rcx, aBye ; &quot;bye\\n&quot;.text:000000014007E21C call sub_14007886F.text:000000014007E221 nop.text:000000014007E222 jmp short loc_14007E231.text:000000014007E224 ; ---------------------------------------------------------------------------.text:000000014007E224.text:000000014007E224 loc_14007E224: ; CODE XREF: sub_14007E130+E3↑j.text:000000014007E224 lea rcx, aHello ; &quot;hello\\n&quot;.text:000000014007E22B call sub_14007886F.text:000000014007E230 nop.text:000000014007E231.text:000000014007E231 loc_14007E231: ; CODE XREF: sub_14007E130+F2↑j.text:000000014007E231 lea rcx, aPause ; &quot;pause&quot;.text:000000014007E238 call sub_140078810.text:000000014007E23D nop.text:000000014007E23E xor eax, eax.text:000000014007E240.text:000000014007E240 loc_14007E240: ; CODE XREF: sub_14007E130+72↑j.text:000000014007E240 ; sub_14007E130+AF↑j.text:000000014007E240 mov rdi, rax.text:000000014007E243 lea rcx, [rbp+150h+var_180].text:000000014007E247 lea rdx, unk_140171FF0.text:000000014007E24E call sub_140079A35.text:000000014007E253 mov rax, rdi.text:000000014007E256 mov rcx, [rbp+150h+var_18].text:000000014007E25D xor rcx, rbp ; StackCookie.text:000000014007E260 call j___security_check_cookie.text:000000014007E265 lea rsp, [rbp+148h].text:000000014007E26C pop rdi.text:000000014007E26D pop rbp.text:000000014007E26E retn.text:000000014007E26E ; } // starts at 14007E130.text:000000014007E26E sub_14007E130 endp.text:000000014007E26E 特征应该是 call cs:GetModuleHandleW、call cs:GetProcAddress、 call cs:GetCurrentProcess 应对方法： scyllahide也是支持反NtQueryInformationProcess反调试的，手动绕过一般是更改缓冲区的值与标准值的比较结果，当然在DS给的源码中因为加入了一些错误处理（如ntdll载入失败就跳过反调试），可以通过人为改动错误判断的结果来实现直接跳过反调试 GetLastError 这个函数用于获取最近一次异常的返回值。使用的方法一般是故意构造异常，如果处于被调试状态，调试器会捕获异常导致返回的错误码和预期的不符。 效果： 应对方法： 可以看到，GetLastError之后，会把返回值和预设的值进行比较，所以修改cmp后的zf就可以了。由于GetLastError的自由度比较高（触发异常的方法多样），所以scyllahide应该是不支持的（笔者没有认出什么相关的设置） 数据检测BeingDebugged BeingDebugged是PEB的成员变量之一，用于描述进程是否处于被调试状态，为1时表示处于被调试状态。 PEB结构体具体如下： 123456789101112131415161718192021typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged;//偏移为2 BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId;} PEB, *PPEB; 反调试手段通常是访问进程的该参数（如WINAPI的IsDebuggerPresent()）来判断是否处于被调试状态。32位下，PEB用FS:[0x30]表示；64位下，PEB用FS:[0x60]表示。加上偏移2就是对BeingDebugged的访问了（这就是这种方法的特征了） 效果图： 应对方法： scyllahide可绕过，手动绕过只需要在访问指令下方的cmp后修改ZF即可 NTGlobalFlag NTGlobalFlag也是PEB结构体的成员，但是是非公开的（因此上文的PEB结构体定义中看不到）。32位下，它位于PEB偏移0x68处，64位下，它位于PEB偏移0xBC处（特征）。它本是描述进程堆管理的，但是由于调试器中的进程创建堆的方式和正常情况有所不同，被调试时该值会被设为0x70（又一个特征），因此也被用来判断是否被调试 效果： 应对方法： syllahide可以绕过，也可以在下面的比较逻辑（因为是内联汇编，所以比较逻辑的实现会有不同）后修改ZF绕过 进程检测FindWindow 实际上是窗口检测，这个函数获取的是进程窗口的类名或者标签，通过与预期的名字进行比较来判断是否处于被调试状态。由于使用的是系统函数，所以实际上也属于WINAPI检测，但是不重要。特征和WINAPI检测一样，会有明显的标记 效果： 本例的程序创建了一个判断函数，在主函数中是将返回值test后来判断是否被调试的，所以只需要修改主函数中的test eax,eax后的ZF就可以实现绕过了。scyllahide应该是不支持的 父进程检测 原理是正常程序双击运行父进程为explorer.exe，而拖进调试器打开父进程为调试器，通过比较获得的父进程名和预设的父进程名可以判断是否处于被调试状态。一般会通过遍历进程或者通过NtQueryInfomationProcess查询来实现。特征是出现大量和进程相关的api，如遍历进程时会调用CreateToolhelp32Snapshot、th32ParentProcessID、Process32Next等，NtQueryInfomationProcess查询会出现QueryFullProcessImageNameA或者其他相关函数与调试器名称字符串同时出现的情况 效果： 实测scyllahide绕过不了第一种方法但可以绕过第二种方法。手动绕过也可以，主要基于后续对进程名的判断，修改判断结果即可绕过 特征码检测 有的调试器在内存中会有特征码，通过遍历进程和搜索特征码可以判断是否被调试。这种情况会比较复杂，难点应该在识别上。一方面可以通过分析是否出现特征码（可能会是很明显的一连串数字初始化），另一方面遍历进程会出现父进程检测中提及的api，但是这些一般不会出现在主函数中，需要跟进函数查看。 特征码示例： scyllahide一般绕过不了，可以在主函数涉及判断结果的逻辑中进行改动绕过。","link":"/2025/08/02/Day12-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"Day11:花指令","text":"花指令 花指令 又叫垃圾指令，不影响程序原始逻辑，但会干扰IDA反编译或者反汇编。 原理： 因为反编译器多是静态分析的，不会通过执行来分析逻辑，只会根据反汇编出来的指令分析，因此有空可乘：例如可以通过内联汇编不完整指令但是跳过不完整指令来模糊指令边界、内联汇编永跳永不跳分支来误导运行逻辑分析、内联汇编无意义指令误导主要逻辑 显著特征是出现红色行，而应对方法是选中花指令所在的区域改为“nop”（空指令） 恒跳型 实测IDA9.0.241217不会报红，也就是混淆失效，所以就看看源码吧 12345678910111213#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main() { _asm{ xor eax, eax; jz s; add esp, 0x11; s: }; printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0;} call-ret相消型 来看效果 可以看到，在函数中间出现了sp-analysis failed，而上面一条就是retn，明显不对。 往前看，rep stosd初始化后，call了$+5，即当前位置+5=0046308C，也就是下一条的add 然后给esp的值+7（call的时候push eip即push 0046308c了） 此时esp存放值为0046308c+7=00463093，所以retn时会pop 00463093，程序跳到00463093 往下看，00463093正是没识别出来的三个数的最后一个，下面还有一个offset没有指令。 第三个数68h和offset结合刚好是push offset，对应上了下面的call（函数传参） 选中没识别的三个数，按“U”（undefine)，可以看到三个数分开了 选中db 68h和dd offset aHello，按C转化为汇编指令，可以看到push offset恢复了 选中call $+5到db 34h，右键选择”Fill with NOPs“（实测db 34h会nop不干净，要选中到db 34h下一行） 可以看到函数变成这样，这是因为插入了retn导致函数范围分析错误，需要纠正 点击函数名，然后右键edit fuction，把end address改成末尾那个真正的retn的地址就OK了 jz-操作数不全型 这种情况下会出现和上一种一样的指令识别错误的问题，且看图： 这是按照MSVS C++初始化规则跳转后，在本来main函数的地方的截图。但是跳转过程中会发现，跳转到main函数的代码是jmp loc_xxxxxx而不是jmp sub_xxxxxx。但是目前还不影响，先分析报错的地方。 可以看到 xor ebp,[eax+50h] 处报红了，并且下面是一段没分析出来的数和字符串”pause”，下面进行分析 首先，rep stosd初始化后，进行了一个恒跳，跳转的地方是0046308E，在 xor ebp,[eax+50h] 这条指令里，所以这里红了 把 xor ebp,[eax+50h] 这条指令undefine一下 根据逻辑，程序是肯定会跳到0046308E的，所以前面的代码冗余，直接nop掉。选中 xor eax,eax 到0046308E（根据上一种类型的经验，要多覆盖一位才能刚好nop掉目标代码） nop完成后（如果有db 90h就按”C“转成code）就会发现下面没分析的数立刻分析出指令了 但是还没完，此时按F5是无法反编译的，因为报错的地方是loc_xxxxxx范围里的，不是一个函数，也就是前面说的jmp loc_xxxxxx而不是jmp sub_xxxxxx的问题了。这里可以看出，IDA这类混淆会导致IDA把函数识别成一个引用而不是函数。 到最开始push ebp开辟栈帧的引用loc_463070处，把它undefine一下，再按“P”重新分析一下，就可以得到main函数了 这类有一个特征就是jz loc_xxxxxx+1，据此可以快速找到加了混淆的地方 总结 上述三种（实际上有混淆效果的只有两种）是比较基础的花指令。识别花指令的要点主要是看红色错误，也可以结合一些特征来识别。解决方法就是nop掉混淆代码。 在实际设计题目时，笔者意外发现了一些更强力的混淆，单单是在上述三种类型的基础上加一点其他指令，就会导致一个函数完全无法被识别（被放在rdata段而不是text段的那种），但是程序还能正常执行，而报错的地方在无法识别的函数的上级函数里（跳转到这个函数的那个函数），可能要结合AI才能实现快捷的分析。因此，花指令还是一个具有挑战性的混淆方式（当然也可能是笔者太菜了没石粒）","link":"/2025/07/31/Day11-%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"title":"Day10:壳与脱壳（二）","text":"二次断点法、一次断点法、特征查找法（均基于Xdbg）、Dll手动脱壳 寻找OEP的方法（二）二次断点法 又叫内存镜像法，原理是壳程序解析时会从.rsrc段获取资源，解析后回到代码段，因此可以通过现在.rsrc段设置内存读取断点，然后在代码段(.text/.code)设置内存写入断点来监控壳程序执行。 通常这个方法是基于OllyDbg的，但是从原理出发Xdbg也不是不能用。除了有一步是在OllyDbg中设置忽略所有异常，Xdbg好像没有这个设置选项，但是经过实测是可以用这个方法在Xdbg脱upx壳的。 Upx脱壳示例： Xdbg载入程序，先在“断点”模块把预设的断点删除，避免程序在非关注的异常处（断点处）停下 然后到“内存映射”模块找到程序的.rsrc（注意所属方为用户），下一次性内存读取断点 shift+F9运行，然后在上方的upx0处下一次性内存写入断点 shift+F9运行，回到“CPU”模块，会发现下方不远处就有一个大跳（隔得有点远截不到eip和大跳的同框图），在大跳前下断点，F9运行到断点处，然后步进就可以到达OEP了 但是有一点奇怪的地方：结合upx的解析原理，upx好像是从upx1段加载数据解析到upx0段的（AI说的，不确定对不对），所以按道理，在upx1处下内存读取断点不是也有类似的监控效果吗？但是实测这样子会跑飞🤔有过一个想法就是，因为在upx1段下了读取断点，壳程序解析前中断了，然后又在upx0段下写入断点，然后按道理应该停在解析然后写入这一步，就是解析了还没写入，或者说刚刚写入一次，那这样也不至于直接调试终止吧🤔 一次断点法（二次断点法plus) 这个方法是基于二次断点法和upx实测出来的，因为根据壳程序解析的原理，最终都会发生向内存写入解析完的数据的操作，所以直接在写入的地方下内存写入断点，这样调试器中断的地方就离OEP不远了（接近壳程序解析的尾声，但还是远到截不到eip和大跳的同框图） 示例 首先，同样要先去掉预设断点 然后在“内存映射”模块给upx0下一次性内存写入断点/给upx1下一次性内存读取断点 shift+F9运行，中断的地方就差不多是壳程序解析写入/开始解析的地方了，在下方大跳前F2断点+F9运行一步到位，然后就可以跳转到OEP了 特征查找法 借助特征指令popad，在程序区域搜索指令，然后下断点运行至此，再接着运行到OEP处 示例： F9运行到程序区域，此时断在pushad 右键在当前区域搜索命令popad 双击搜索结果跳转，下方不远处就是到OEP的大跳了。直接在jmp前一条指令下断点，F9到此，然后步进 Dll手动脱壳 若出现Dll程序加壳的情况，可以先把Dll程序转化成exe程序，然后使用和exe手动脱壳一样的步骤即可 示例： 用DIE打开Dll程序，可以看到显示加了upx壳 点击“区块”下方的“&gt;”，打开文件结构界面 取消勾选右上角”只读“，然后点击IMAGE_FILE_HEADER，取消勾选”标志“中的”Dll“（图中未取消） 此时可以发现，Characteristics的值变了 然后把dll后缀改成exe就可以按照exe手动脱壳的步骤进行脱壳了","link":"/2025/07/30/Day10-%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Day14:IDApython与SMC","text":"IDApythonAPI、SMC自修改代码 IDApython 先贴上官方文档： https://python.docs.hex-rays.com/index.html 基础API idc.here() / idc.get_screen_ea()：返回光标所在处的地址 idc.get_inf_attr(INF_MIN_EA) / idc.get_inf_attr(INF_MAX_EA)：返回最小/最大地址（没有随机化地址情况下） idc.generate_disasm_line(ea,0)：返回ea所在处的汇编指令 idc.prev_head(ea)/next_head(ea)：返回ea处上一条/下一条指令地址 idc.print_insn_mnem(ea)：打印ea处的助记符（即mov,add什么的） idc.print_operand(ea,n)：打印ea处第n个操作数（n=0或者1） 段相关API idautils.Segments()：返回段起始地址列表 idc.get_segm_name(ea)：返回ea所在段的名字 idc.get_segm_start(ea)/get_segm_end(ea)：返回ea所在段的起始地址/结束地址 idc.get_next_seg(ea)：返回ea所在段的下一个段的起始地址 函数相关API idautils.Functions(start_addr,end_addr)：返回地址间的函数对象（不写参数就是所有函数对象） idautils.FuncItems(ea)：返回ea所在函数所有指令的地址（相当于地址列表） idaapi.get_func(ea)：获得ea所在函数的对象（含有如start_ea、end_ea、size等属性） idc.get_func_name(ea)：返回ea所在函数的名字 idc.get_func_attr(ea,FUNCATTR_START) / idc.get_func_attr(ea,FUNCATTR_END)：返回ea所在函数的起始地址/结束地址 idc.get_next_func(ea) / idc.get_prev_func(ea)：返回ea所在函数的上一个/下一个函数的起始地址 指令相关API ida_ua.insn_t()，返回一个空的指令对象（或者说创建一个空的指令对象），包含函数的一些属性 idaapi.decode_insn(out,ea)，解析ea所在处的指令，把解析的结果给out（out必须是一个指令对象） out.ea：指令的起始地址 out.size：指令占用的字节数 out.get_cannon_mnemonic()：指令的助记符 out.itype：助记符的十进制码 操作数相关API idc.get_operand_value(ea,n)：返回ea处第n个操作数的值 idc.get_operand_type(ea,n)：返回ea处第n个操作数的类型 数据读写相关API idc.get_bytes(ea,size)：返回ea处size大小的bytes idc.patch_byte(ea,content)：修改ea处的1字节为content idc.patch_word(ea,content)：修改ea处的2字节为content idc.patch_dword(ea,content)：修改ea处的4字节为content idc.patch_qword(ea,content)：修改ea处的8字节为content 调试相关API ida_dbg.load_debugger(“local”,0)：启动调试器 ida_dbg.add_bpt(ea)：在ea处下断点 ida_dbg.del_bpt(ea)：删除ea处断点 ida_dbg.start_process(path,args,sdir)：启动调试进程，参数对应路径、命令行参数、工作目录 ida_dbg.step_into()：单步步入 ida_dbg.step_over()：单步步过 ida_dbg.step_until_ret()：运行到返回 idc.get_reg_value(regname)：获取regname寄存器的值 idc.set_reg_value(value,regname)：设置regname寄存器的值 其他操作相关API idautils.XrefsFrom(ea)：返回ea处引用的对象（有属性frm、to、type） idautils.XrefsTo(ea)：返回所有引用ea处的对象（有属性frm、to、type）（Ctrl+X） 示例： 1234567import idautils,idaapifor xref in idautils.XrefsTo(here()): print(xref.to)#here() print(xref.frm)#调用here()的函数地址for xref in idautils.XrefsFrom(here()): print(xref.frm)#here() print(xref.to)#here()引用的函数地址 idautils.Strings()：返回包含所有字符串的对象（有属性ea、length、strtype）（shift+F12） idc.get_strlit_contents(ea)：返回ea处的字符串 示例： 12345import idc,idautilsfor s in idautils.Strings(): string=idc.get_strlit_contents(s.ea) print(string)#打印所有字符串 自修改代码（SMC） 自修改代码（Self-Modifying-Code）指某部分代码以加密后的形式存在于程序中，程序执行到这部分代码的时候才会进行动态解密，和加壳有点异曲同工。常用来加密关键逻辑，使其不可直接静态分析 特征： 程序中存在对程序自身某部分的运算，一般还需要VirtualProtect() / mprotect()来改变内存的属性以便将解密后的代码数据写入内存，或者使用VirtualAlloc把解密后的代码数据写入堆中执行（为了避免API暴露，还可能会新增一个有RWX属性的段来存放加密后的代码）。 应对方法有两种：一种是动态调试得到解密后的关键逻辑，另一种是使用脚本解密关键逻辑后再覆盖回去 示例：2021-羊城杯-babysmc PS：本来想要自己写一个简单程序试试手的，研究了半个下午没研究出来，程序修正到解密函数可以解密出正确代码了，但是调用关键逻辑check的时候莫名其妙跑飞了，在那个安全检查的位置，跳转后像是个畸形函数，不知道是不是改内存属性的时候影响到了，所以只能去找网上的题目了 这是优化后的主函数： 优化的来源就是，enc的位置是一团数字，而loc_7FF6BF081D00处开始是正常代码，加上对下面的decrypt函数的分析，可以确定enc就是被加密后的first_part 这是decrypt函数： 非常明显地调用了VirtualProtect函数，解密逻辑很简单，就是ror后异或0x5a（ror查出来是循环右移，3就是右移的位数了，这点看汇编可能更清晰点） 下面就是今天的成果展示了（ror由DS协助实现），SMC解密脚本： 12345678910111213import idautils,idc,idaapienc=idc.get_bytes(0x00007FF6BF081085,0x00007FF6BF081D00-0x00007FF6BF081085)loc=0x00007FF6BF081085def ror(value, shift, bits=8): shift %= bits # 确保位移量在有效范围内 return (value &gt;&gt; shift) | ((value &lt;&lt; (bits - shift)) &amp; ((1 &lt;&lt; bits) - 1))for i in enc: idc.patch_byte(loc,(ror(i,3)^0x5a)&amp;0xff) loc+=1print(&quot;done&quot;) 本来是要写完的，但是first_part的函数解析完好几百行了，是我看不懂的加密🫠去找WP，发现是非常混淆的base64，还加了异或，但是我没看出逻辑，索性点到为止，改天把编码和密码的部分补上再说。 本来也尝试了动调解密，但是调着调着给我下起东西来了，虽然链接看着是微软的，但是还是有点怕，就舍弃这个方法了（下的是kernel.pdb好像，DS说是缺失符号文件🫠🫠）","link":"/2025/08/05/Day14-IDApython/"},{"title":"Day15:指令虚拟化","text":"指令虚拟化、实现一个小型虚拟机程序、VM逆向实践 什么是指令虚拟化 CPU厂商在开发CPU前会制定一个规范，建立起数据和操作的对应关系（如x86-64规定0x30对应异或操作），而这个数据又可以根据操作命名出汇编指令（如0x30命名为xor），因此有了数据与操作的对应关系和汇编指令与操作的对应关系，称之为指令集。CPU可以视作一个解释器，负责读取数据或者汇编指令然后带动机器产生操作。 通俗的讲，指令虚拟化实际上就是自定义指令集并为自己的指令集构建解释器，用自定义的指令实现程序的过程。这个过程利用高级语言代码实现，也就是用软件来模拟硬件，类似于虚拟机，因此称之为指令虚拟化。 实现指令虚拟化，需要定义寄存器变量（至少需要一个EIP来指向运行的指令）、内存空间数组、解释器和指令数组。 实现自定义指令集的解释器，可以采用C语言的switch（其中code是自定义指令，通过循环输入）： 1234567891011//解释器：1输出11111，2输出22222，3输出33333switch(code):case 1: printf(&quot;11111&quot;); break;case 2: print(&quot;22222&quot;); break:case 3: print(&quot;33333&quot;); break; 实现一个小型虚拟机程序 尝试编写一个输入两个数，输出和的程序 声明虚拟硬件结构体1234567typedef struct{ unsigned int r1;//寄存器r1 unsigned int r2;//寄存器r2 unsigned int eip;//寄存器eip unsigned char mem[256];//虚拟内存数组 unsigned char code[1024];//指令数组} VM; 定义指令集 使用op1、op2表示指令后面跟的操作数，寄存器作为隐式参数不会出现在code中 指令 使用格式 对应汇编指令/伪代码 操作解读 0x10 0x10,op1 mov r1,mem[op1] r1=mem[op1] 0x11 0x11,op1 mov r2,mem[op1] r2=mem[op1] 0x20 0x20 add r1,r2 r1+=r2 0x30 0x30,op1,op2 scanf-&gt;mem[op1],mem[op2] 输入给mem[op1]，mem[op2] 0x40 0x40 printf r1 输出r1的值 0x50 0x50 ret return 1 编写解释器123456789101112131415161718192021222324252627282930313233343536373839404142int vm_run(VM* vm) { char opcode;//用来存放指令 char op1, op2;//用来存放操作数 while (1) { opcode = vm-&gt;code[vm-&gt;eip];//读取eip指向的指令 switch (opcode) { case 0x10: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r1 = vm-&gt;mem[op1];//r1=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x11: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r2 = vm-&gt;mem[op1];//r2=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x20: vm-&gt;r1 += vm-&gt;r2;//r1+=r2 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x30: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数1 op2 = vm-&gt;code[vm-&gt;eip + 2];//获取操作数2 scanf(&quot;%d %d&quot;, &amp;vm-&gt;mem[op1], &amp;vm-&gt;mem[op2]);//输入给mem[op1]，mem[op2] vm-&gt;eip += 3;//跳转到下一条指令（指令+操作数占3个索引位） break; case 0x40: printf(&quot;%d&quot;, vm-&gt;r1);//输出r1的值 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x50: return 1;//循环终止，函数返回，虚拟机关机 } }} 指令数组12345678unsigned char code[]={ 0x30,0x0,0x1,//输入给mem[0]，mem[1] 0x10,0x0,//r1=mem[0] 0x11,0x1,//r2=mem[1] 0x20,//r1+=r2 0x40,//输出r1的值 0x50//虚拟机关机} 完整程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef struct{ unsigned int r1;//寄存器r1 unsigned int r2;//寄存器r2 unsigned int eip;//寄存器eip unsigned char mem[256];//虚拟内存数组 unsigned char code[1024];//指令数组} VM;unsigned char code[]={ 0x30,0x0,0x1,//输入给mem[0]，mem[1] 0x10,0x0,//r1=mem[0] 0x11,0x1,//r2=mem[1] 0x20,//r1+=r2 0x40,//输出r1的值 0x50//虚拟机关机};VM* vm_new() { VM* vm = (VM*)malloc(sizeof(VM));//为虚拟硬件结构体申请空间 memset(vm, 0, sizeof(VM));//初始化结构体 memcpy(vm-&gt;code, code, sizeof(code));//初始化code return vm;}int vm_run(VM* vm) { char opcode;//用来存放指令 char op1, op2;//用来存放操作数 while (1) { opcode = vm-&gt;code[vm-&gt;eip];//读取eip指向的指令 switch (opcode) { case 0x10: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r1 = vm-&gt;mem[op1];//r1=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x11: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r2 = vm-&gt;mem[op1];//r2=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x20: vm-&gt;r1 += vm-&gt;r2;//r1+=r2 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x30: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数1 op2 = vm-&gt;code[vm-&gt;eip + 2];//获取操作数2 scanf(&quot;%d %d&quot;, &amp;vm-&gt;mem[op1], &amp;vm-&gt;mem[op2]);//输入给mem[op1]，mem[op2] vm-&gt;eip += 3;//跳转到下一条指令（指令+操作数占3个索引位） break; case 0x40: printf(&quot;%d&quot;, vm-&gt;r1);//输出r1的值 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x50: return 1;//循环终止，函数返回，虚拟机关机 } }}int main() { VM* vm = vm_new();//生成一个虚拟机 if (vm_run(vm))//运行虚拟机 system(&quot;pause&quot;); return 0;} 简单示例的逆向 VM题最显著的特征应该就是虚拟硬件结构体的初始化和解释器了。解决这类问题，需要先复刻出一个解释器，通过在解释器中增加打印分析出的代码的操作，来得到去虚拟化的原程序，进而可以正常逆向分析 先来看main函数： 下面三个带字符串的函数可以看出是printf和system 看看v1=后面的函数 目前没什么明显的VM特征 再看看if括号里的函数 看到出现switch了，开始推测是VM的解释器 回到上一个函数，发现确实和VM的初始化函数很像，最后面一个函数的第二个参数对应出来的是一堆数字，和初始化code对应上了 OK，那就对伪代码进行一点点优化，然后开始分析解释器 1234567891011121314151617181920212223242526272829303132333435363738//推测虚拟硬件结构体__int64 __fastcall vm_run(unsigned int *vm){ sub_140001940(&amp;unk_1401150A2); while ( 1 ) { switch ( *((_BYTE *)vm + vm[2] + 268) )//vm+268是code所在，结合下文分析，加上vm[2]就构成了code[eip] { case 0x10: *vm = *((char *)vm + vm[2] + 269);//*vm=code[eip+1]，vm应该是一个寄存器，这句是mov r1,op1 vm[2] += 2;//每个case都有，推测是eip。+=2，说明有一个操作数 break; case 0x11: vm[1] = *((char *)vm + vm[2] + 269);//vm[1]=code[eip+1]，vm[1]应该也是一个寄存器,这句是mov r2,op1 vm[2] += 2;//有一个操作数 break; case 0x20: *((_BYTE *)vm + *((char *)vm + vm[2] + 269) + 12) = *((_BYTE *)vm + vm[2] + 270); //*((char *)vm + vm[2] + 269)是code[eip+1]，即op1，所以左边是vm+12+op1，推测vm+12是虚拟内存，刚好跨过三个连续的int型寄存器 //右边即vm+vm[2]+268+2即code[eip+2]，即op2 vm[2] += 3;//有两个操作数 break; case 0x30: *((_BYTE *)vm + *vm + 12) ^= *((_BYTE *)vm + 4);//mem[r1]^=r2 ++vm[2];//无操作数 break; case 0x40: sub_140001610(&amp;unk_1400D74B0, vm + 3);//unk这个是%5s，所以这是scanf。这里的vm是int，加三跳过了单个寄存器，是mem[0] ++vm[2];//无操作数 break; case 0x50: return sub_1400D4430(vm + 3, (char *)vm + *((char *)vm + vm[2] + 269) + 12, *((char *)vm + vm[2] + 270)); //三个参数分别为mem[0],mem[op1],op2，推测是memcmp（怎么没暗示操作数个数 default: continue; } }} 推测虚拟硬件结构体如下： 1234567typedef struct{ unsigned int r1; unsigned int r2; unsigned int eip; unsigned char mem[268-3*4=256]; unsigned char code[36];} VM; 带输出分析出来的代码的解释器如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int vm_run(VM* vm) { char opcode; char op1, op2; while (1) { opcode = vm-&gt;code[vm-&gt;eip]; switch (opcode) { case 0x10: vm-&gt;r1 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r1,&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; endl; break; case 0x11: vm-&gt;r2 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r2,&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x20: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; vm-&gt;mem[op1] = op2; vm-&gt;eip += 3; cout &lt;&lt; &quot;mov mem[&quot; &lt;&lt; (int)op1 &lt;&lt; &quot;],&quot; &lt;&lt; op2 &lt;&lt; endl; break; case 0x30: vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2; ++vm-&gt;eip; cout &lt;&lt; &quot;xor mem[&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; &quot;],&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x40: scanf(&quot;%5s&quot;, &amp;vm-&gt;mem[0]); ++vm-&gt;eip; printf(&quot;scanf mem\\n&quot;); break; case 0x50: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; return memcmp(&amp;vm-&gt;mem[0], &amp;vm-&gt;mem[op1], op2); } }} 完整的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;typedef struct { unsigned int r1; unsigned int r2; unsigned int eip; unsigned char mem[256]; unsigned char code[36];} VM ;unsigned char code[] = { 0x20, 0x10, 0x48, 0x20, 0x11, 0x65, 0x20, 0x12, 0x6C, 0x20, 0x13, 0x6C, 0x20, 0x14, 0x6F, 0x40, 0x11, 0x21, 0x10, 0x00, 0x30, 0x10, 0x01, 0x30, 0x10, 0x02, 0x30, 0x10, 0x03, 0x30, 0x10, 0x04, 0x30, 0x50, 0x10, 0x05};VM* vm_new() { VM* vm = (VM*)malloc(sizeof(VM)); memset(vm, 0, sizeof(VM)); memcpy(vm-&gt;code, code, sizeof(code)); return vm;}int vm_run(VM* vm) { char opcode; char op1, op2; while (1) { opcode = vm-&gt;code[vm-&gt;eip]; switch (opcode) { case 0x10: vm-&gt;r1 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r1,&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; endl; break; case 0x11: vm-&gt;r2 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r2,&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x20: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; vm-&gt;mem[op1] = op2; vm-&gt;eip += 3; cout &lt;&lt; &quot;mov mem[&quot; &lt;&lt; (int)op1 &lt;&lt; &quot;],&quot; &lt;&lt; op2 &lt;&lt; endl; break; case 0x30: vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2; ++vm-&gt;eip; cout &lt;&lt; &quot;xor mem[&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; &quot;],&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x40: scanf(&quot;%5s&quot;, &amp;vm-&gt;mem[0]); ++vm-&gt;eip; printf(&quot;scanf mem\\n&quot;); break; case 0x50: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; return memcmp(&amp;vm-&gt;mem[0], &amp;vm-&gt;mem[op1], op2); } }}int main() { VM* vm = vm_new(); if (vm_run(vm)) printf(&quot;failed\\n&quot;); else printf(&quot;good\\n&quot;); system(&quot;pause&quot;); return 0;} 这样我们得到了原程序的汇编代码（参杂着奇怪的代码） 12345678910111213141516171819mov mem[16],Hmov mem[17],emov mem[18],lmov mem[19],lmov mem[20],o12345scanf memmov r2,33mov r1,0xor mem[0],33mov r1,1xor mem[1],33mov r1,2xor mem[2],33mov r1,3xor mem[3],33mov r1,4xor mem[4],33failed 可以看到，程序先把”Hello”传给了mem的一片区域，然后获取输入，把输入的数与33异或，最后执行返回处的判断。返回处是对比mem[0]和mem[op1]，对比op2位，结合code最后几位，知道是对比mem[0]和mem[16]，对比5位。所以要求的输入是”Hello”逐位异或的结果（不可见字符，尝试输入失败）","link":"/2025/08/06/Day15-%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"title":"Day13:反调试（二）","text":"时间差检测、断点检测 时间差检测 CPU的运行十分迅速，一段代码可能在几毫秒内就可以执行完毕，但是调试的时候，代码运行时间会显著地变慢，这就是时间差检测的原理。时间差检测主要通过计算时间差然后与预设的值比较实现。 RDTSC指令计算 rdtsc是一个汇编指令，用于将时间读入edx:eax寄存器（高32位：低32位）。通过取两次时间把结果相减可以得到一个时间差。显著特征就是rdtsc指令 效果： 应对方法： 根据程序的逻辑，可以在计算出时间差并比较之后改变比较结果。 GetTickCount计算 原理和RDTSC类似，只不过时间差采用GetTickCount计算。GetTickCount也是WINAPI，会有明显标记。 效果： 应对方法： 修改比较结果即可 QueryPerformanceCounter计算 原理类似，只是采用QueryPerformanceCounter计算，也是WINAPI，比较好识别 效果： 应对方法： 修改比较结果即可 断点检测 断点是调试的一个显著特点。断点可以分为软件断点、硬件断点和内存断点。软件断点通过将目标代码修改为中断指令（X86\\X64下一般为INT3\\0xCC）实现；硬件断点通过将指令地址写入调试寄存器的DR0-DR3监控地址访问来实现；内存断点通过修改内存页（一片片内存区域）的访问权限实现。三者的实现方法都会触发异常让调试器捕获进而中断。反调试的断点检测主要利用软件断点和硬件断点，内存断点由于针对内存区域而非具体指令，精度太低，一般不考虑。 软件断点检测 常见手段是在内存区域搜索0xCC（使用汇编指令repnz scasb） 效果： 因为进行了比较，所以修改比较结果即可绕过 硬件断点检测 常见手段是获取DR寄存器的值并和0比较。特征是GetThreadContext函数（或者其他ThreadContext相关的函数）和与0的比较 效果： 应对方法： 还是进行了比较，修改比较结果绕过","link":"/2025/08/03/Day13-%E5%8F%8D%E8%B0%83%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Day16:Z3求解器","text":"z3求解器 基本数据类型 Int：整数 BitVec：二进制数据（如BitVec(‘a’,8)：8个比特位的一个变量a） Real：有理数 Bool：布尔值 Array：数组 基本流程设变量 使用基本数据类型来声明变量，如：x=Int(‘x’) 创建求解器 使用函数Solve()创建一个求解器：s=Solver() 添加约束条件 使用函数add()添加约束条件：s.add(一个方程/不等式) 判断是否有解 使用函数check()检查是否有解，有解返回’sat’，无解返回’unsat’ 取解的交集 使用函数model()取满足每个条件的解的交集，返回的是字典，用model[变量名]可以得到变量的解 示例解方程{x,y|30x+15y=675,12x+5y=265} 1234567891011from z3 import *x=Int('x')y=Int('y')s=Solver()s.add(30*x+15*y==675)s.add(12*x+5*y==265)if s.check()==sat: print(s.model())#得到解[x = 20, y = 5]","link":"/2025/08/21/Day16-Z3/"},{"title":"Day2:寻址方式、标志寄存器、JCC指令","text":"寻址方式、标志寄存器、JCC指令 寻址方式 寻址方式 示例 典型用途 立即数寻址 mov eax,42 加载常数 寄存器寻址 add eax,ebx 寄存器运算 直接寻址 mov eax,[0x8040000] 访问全局变量 寄存器间接寻址 mov eax,[esi] 指针解引用 基址寻址 mov [ebp-4],ecx 栈帧局部变量 变址寻址 mov eax,[esi*4] 数组遍历 基址变址寻址 mov eax,[ebx+esi*2+8] 结构体，多维数组 相对寻址 jmp label 跳转，函数调用 标志寄存器 标志位 名称 作用 CF Carry Flag 进位标志位 最高位发生进位/借位时置1 PF Parity Flag 奇偶标志位 1的个数为偶数时置1 AF Auxiliary Carry Flag 辅助进位标志位 bit3和bit4之间发生进位/借位时置1 ZF Zoro Flag 零标志位 为0时置1 SF Sign Flag 符号标志位 最高位为1(负数)时置1 OF Overflow Flag 溢出标志位 有符号数溢出时置1 DF Direction Flag 方向标志位 为1时从高位到低位处理字符串，std打开，cld关闭 IF Interrupt Flag 中断标志位 为1时可以响应中断请求，sti打开，cli关闭 TF Trap Flag 陷阱标志位 为1时会触发异常，被调试器捕获，用于单步调试 JCC指令 TEST指令：TEST op1,op2 将两个操作数进行&amp;操作（op1 &amp; op2）并更新标志位： CF=0，OF=0 &amp;结果为0：ZF=1 结果最高位为1：SF=1 CMP指令：CMP op1,op2 进行减法操作（op1 - op2）并更新标志位： 若op1 &lt; op2（发生借位），CF=1 若发生有符号溢出，OF=1 op1 == op2（结果为0），ZF=1 op1 &lt; op2（结果为负数），SF=1 JCC指令：JCC Label 指令 条件 描述 JMP 无条件 无条件跳转 JE / JZ ZF=1 Jump if Equal / Jump if ZF JNE / JNZ ZF=0 Jump if Not Equal / Jump if Not ZF JS SF=1 Jump if SF JNS SF=0 Jump if Not SF JP / JPE PF=1 Jump if PF / Jump if Parity Even JNP / JPO PF=0 Jump if Not PF / Jump if Parity Odd JO OF=1 Jump if OF JNO OF=0 Jump if Not OF JB / JNAE / JC CF=1 Jump if Below / Jump if Not Above or Equal / Jump if CF JNB / JAE / JNC CF=0 Jump if Not Below / Jump if Above or Equal / Jump if Not CF JBE / JNA CF=1 或 ZF=1 Jump if Below or Equal / Jump if Not Above JA / JNBE CF=0 且 ZF=0 Jump if Above / Jump if Not Below or Equal JL / JNGE SF ≠ OF Jump if Less / Jump if Not Greater or Equal JGE / JNL SF = OF Jump if Greater or Equal / Jump if Not Less JLE / JNG ZF=1 或 SF ≠ OF Jump if Less or Equal / Jump if Not Greater JG / JNLE ZF=0 且 SF = OF Jump if Greater / Jump if Not Less or Equal","link":"/2025/07/07/Day2-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"},{"title":"Day3:函数与栈帧、数组与串指令、宏与结构体、x64汇编框架、内联汇编与混合编程","text":"函数与栈帧、数组与串指令、宏与结构体、x64汇编框架、内联汇编与混合编程 函数与栈帧 “栈“是内存中的一部分，可以理解为连续的一块内存，它为程序运行提供了一个暂时的存放数据的地方，地址、数据等可以通过push指令从寄存器中被复制到栈中，进而寄存器可以进行其他操作，等到这些数据再次被需要时再从栈中被pop出来。栈遵循先进后出的规则，先push的在高地址，后push的在低地址 在程序运行时，每个函数都会拥有独立的栈帧，即独立的栈上的一部分空间。有两个寄存器，esp，ebp（x86即32位环境下）负责维护函数的栈空间。ebp存放的是函数栈空间的栈基址，esp存放的是函数栈空间的栈顶。可以理解为ebp是指向函数栈空间最高位的一个指针（因为栈空间从高地址开始分配，因此指向的是最高位，但是是栈空间的起始地址），而esp是指向函数栈空间最低位的一个指针（指向的是最低位，但是会随着后续栈空间的扩充而变化）。 CALL指令： 123;call一个函数的时候，会发生以下内容push 返回地址（call所在指令的下一条）jmp 目标函数地址 RET指令： 12;函数结束时，RET指令会发生以下内容pop eip ;从栈上弹出返回地址到eip（保存下一步指令地址的寄存器） 栈帧： 1234567;跳转到每一个函数，会发生以下内容以开辟栈帧push ebp ;把上一个函数的ebp值放到栈上mov ebp,esp ;把esp值给ebp，开辟新函数的栈帧;函数执行完毕后，会发生以下内容清理栈帧mov esp,ebp ;把ebp值给esp，清理函数栈帧pop ebp ;恢复ebp原来的值，即上一个函数的ebpret 数组与串指令 声明数组： 123.data ;在数据段声明 szHello db 'HelloWorld',0 ;声明一个字符串 nNumber dd 20 dup(0) ;声明一个DWORD数组，20位，使用dup()初始化数组内容为0 使用数组基址的几种方式： 12lea eax,szHellomov ebx,offset Nnumber 访问数组成员： 1234567891011;[数组起始地址+索引寄存器*比例因子+偏移量]（索引寄存器用来存放索引值，比例因子对应类型的字节大小，偏移量可用于结构体数组等场景）;如：mov ebx,offset Array ;把数组基址给ebxmov esi,0 ;esi用来当索引寄存器mov ecx,10 ;ecx用来放索引上限（ecx常用作计数器）loop_start: ;创建一个循环 mov eax,[ebx+esi*4] ;取出数组内容放到eax中 add esi,1 ;索引递增 cmp esi,ecx ;与索引上限比较，判断是否遍历完数组 jl loop_start ;还没遍历完数组就循环操作，jump到loop_start再走一遍 串指令： 1234;stos系列:stosb,stosw,stosd,stosq（分别对应byte,word,dword,qword,功能是把al/ax/eax/rax中的内容存到edi/rdi）;lods系列:lodsb,lodsw,lodsd,lodsq（同样分别对应四个类型，功能是把esi/rsi的内容加载到al/ax/eax/rax中）;movs系列:movsb,movsw,movsd,movsq（同样分别对应四个类型，功能是把esi的内容复制到edi中）;cmps系列:cmpsb,cmpsw,cmpsd,cmpsq（同样分别对应四个类型，功能是比较esi和edi的内容并设置标志位） 宏与结构体 宏： 12345678;无参宏使用关键字EQU，如PI EQU 3 ;定义PI=3;含参宏使用关键字MACRO，用endm结尾，如Myadd MACRO Number add eax,Numberendm ;定义Myadd函数实现eax加上参数;含参宏的调用：Myadd&lt;参数&gt; 结构体： 1234567891011;使用关键字struct和ends，如Point struct x word ? y word ?Point ends;实例化结构体MyPoint Point&lt;?&gt; ;实例化出MyPoint;访问结构体成员mov MyPoint.x,123 x64汇编框架(MASM)1234567891011121314151617181920212223242526272829303132333435363738;x64环境下的代码，传参的时候先使用寄存器(Windows:rcx,rdx,r8,r9 Linux:rdi,rsi,rdx,rcx,r8,r9)再使用栈.code;Add函数声明Add proc push rbp mov rbp,rsp lea rax,[rdi + rsi] ;从寄存器中取参数 pop rbp retAdd endpmain proc mov rdi,2 ;把参数传入寄存器中 mov rsi,3 call Add retmain endpend;x86环境下的代码，传参使用栈.code;Add函数声明Add proc push ebp mov ebp,esp mov eax,[esp+8] ;从栈上取参数 add eax,[esp+12] pop ebp retAdd endpmain proc push 3 ;把参数压入栈中 push 2 call Add add esp,8main endp 内联汇编与混合编程 x86下，在Microsoft Visual C++ (MSVC)程序中使用汇编，可以通过_asm{}直接写在C++代码中: 123456789#include&lt;iostream&gt;int main(){ _asm{ xor eax,eax mov eax,1 add eax,1 } return 0;} x64下，在Microsoft Visual C++ (MSVC)程序中使用汇编，需要独立的asm文件，通过extern声明使用： 1234567891011121314151617181920#include&lt;iostream&gt;extern &quot;C&quot; long long Add(long long number1,long long number2);int main(){ long long res=Add(1,2); std::cout&lt;&lt;res&lt;&lt;std::endl; return 0;}//asm文件.codeAdd proc push rbp mov rbp,rsp xor rax,rax add rax,rcx add rax,rdx pop rbp retAdd endpend","link":"/2025/07/08/Day3-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A0%86%E6%A0%88/"},{"title":"Day4:Linux汇编框架、操作系统与汇编器、主函数跳转流程","text":"Linux汇编框架、操作系统与汇编器、主函数跳转流程 Linux(NASM)汇编框架 Linux和Windows的不同主要有： 系统调用方式不同： Windows提供API，可以直接利用系统函数 Linux需要用系统调用号触发系统调用。系统调用号存入特定寄存器后使用触发指令，触发系统调用 触发指令： ​ 32位(x86)：int 0x80 ​ 64位(x64)：syscall 参数传递： ​ 32位：eax（系统调用号），ebx、ecx、edx、esi、edi、ebp（参数）。 ​ 64位：rax（系统调用号），rdi、rsi、rdx、r10、r8、r9（参数）。 32位下exit示例： 12mov eax,1 ;32位下，exit的系统调用号为1int 0x80 ;系统调用号存入寄存器后，触发系统调用 可执行文件格式不同： Windows使用PE文件格式 Linux使用ELF文件格式 其他细节： Linux在段名前必须添加section，只有.text段没有.code段（实际上由汇编器决定，详见下一部分） Linux使用0xA作为字符串结束符 32位汇编框架 12345678910111213141516section .data msg db &quot;HelloWorld&quot;,0xA len equ $ - msg ;用变量len记录msg的长度（$表示当前变量的地址，减去msg的地址就是msg的长度） section .text global _start_start: mov eax,4 ;eax存放系统调用号4：sys_write mov ebx,1 ;参数1：文件描述符，1表示标准输出stdout mov ecx,msg ;参数2：要打印的数据地址 mov edx,len ;参数3：打印的字节数 int 0x80 mov eax,1 ;eax存放系统调用号1：sys_exit mov ebx,0 ;参数1：退出状态码（0表示成功） int 0x80 64位汇编框架 12345678910111213141516section .data msg db &quot;HelloWorld&quot;,0xA len equ $ - msg section .text global _start_start: mov rax,1 ;rax存放系统调用号1：sys_write mov rdi,1 ;参数1：文件描述符，1表示标准输出stdout mov rsi,msg ;参数2：要打印的数据地址 mov rdx,len ;参数3：打印的字节数 syscall mov rax,60 ;rax存放系统调用号60：sys_exit xor rdi,rdi ;参数1：退出状态码（0表示成功） syscall 操作系统与汇编器 Windows：主要有MASM和NASM两种汇编器 MASM（Microsoft Macro Assembler），主要集成在visual studio中 段名前不要求加section，可以直接用 .段名 声明 指令存放在.code段 .code段，函数以 func_name proc 开始，以 func_name endp 结束 使用Intel风格，即 指令 目标操作数，源操作数 NASM（Netwide Assembler），跨平台汇编器，支持Windows、Linux、macOS 段名前要求加section，用 sectino .段名 声明 指令存放在.text段 .text段，函数用 global func_name 声明后再定义 使用Intel风格 Linux：主要有NASM和GAS两种汇编器 NASM同上 GAS（GNU Assembler），Linux默认汇编器 段名前要求加.section，用 .section .段名 声明 指令存放在.text段 .text段，函数用 .global func_name 声明后再定义 使用AT&amp;T风格，即 指令 源操作数，目标操作数 主函数跳转流程 环境：vs2022，Debug x86/x64，Release x86/x64 123456789101112131415161718192021222324252627;x86 debug 跳转特征;step1jmp ;直接jmp;step2call ;第一个call;step3callcall &lt;-- ;连续两个call，进第二个;step42*jz--&gt;callmovcall ;两个jz指向的同一个call且此call后紧跟mov和call;step5movpushmovpushmovpushcall ;连续push3个参数入栈后的call;step6jmp 12345678910;x86 Release 跳转特征;step1calljmp ;call后的jmp;step2pushpushpushcall ;连续push3个参数入栈后的call 1234567891011121314151617181920212223242526;x64 Debug 跳转特征 ;step1jmp ;直接jmp;step2call ;第一个call;step3callcall &lt;-- ;连续两个call进第二个;step42*jz--&gt;callmovcall ;两个jz指向的同一个call且此call后紧跟mov和call;step5movmovmovmovmovcall ;连续5个mov后的call（传参）;step6jmp ;直接jmp 123456789101112;x64 Release 跳转特征 ;step1calljmp ;call后的jmp;step2movmovmovcallmovcall ;三个mov后的call（传参）且此call后紧跟mov和call","link":"/2025/07/11/Day4-Linux%E6%B1%87%E7%BC%96%E6%A1%86%E6%9E%B6/"},{"title":"Day7:数组与指针识别","text":"数组与指针识别 数组与指针识别 整型一维数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.text:00464260 mov [ebp+var_14], 1.text:00464267 mov [ebp+var_10], 2.text:0046426E mov [ebp+var_C], 3.text:00464275 lea eax, [ebp+var_14] ; 数组首地址.text:00464278 push eax ; 传参.text:00464279 call sub_45D447.text:0046427E add esp, 4;sub_45D447.text:004640D0 arg_0 = dword ptr 8.text:004640D0.text:004640D0 push ebp.text:004640D1 mov ebp, esp.text:004640D3 sub esp, 0C0h.text:004640D9 push ebx.text:004640DA push esi.text:004640DB push edi.text:004640DC mov edi, ebp.text:004640DE xor ecx, ecx.text:004640E0 mov eax, 0CCCCCCCCh.text:004640E5 rep stosd.text:004640E7 mov ecx, offset unk_54D014.text:004640EC call sub_45FF35.text:004640F1 nop.text:004640F2 mov eax, 4.text:004640F7 shl eax, 1 ; eax=4*2^1=8.text:004640F9 mov ecx, [ebp+arg_0] ; [ebp+arg_0]是传入的参数，即数组首地址.text:004640FC mov edx, [ecx+eax] ; [ecx+eax]即[ebp+arg_0+eax]，即[ebp+10h].text:004640FF push edx.text:00464100 mov eax, 4.text:00464105 shl eax, 0 ; eax=4*2^0=4.text:00464108 mov ecx, [ebp+arg_0].text:0046410B mov edx, [ecx+eax] ; 即[ebp+0Ch].text:0046410E push edx.text:0046410F mov eax, 4.text:00464114 imul ecx, eax, 0 ; ecx=4*0=0.text:00464117 mov edx, [ebp+arg_0].text:0046411A mov eax, [edx+ecx] ; 即[ebp+8]，即[ebp+arg_0]，数组首位.text:0046411D push eax.text:0046411E push offset aDDD ; &quot;%d %d %d&quot;.text:00464123 call sub_45DB5E ; printf.text:00464128 add esp, 10h.text:0046412B pop edi.text:0046412C pop esi.text:0046412D pop ebx.text:0046412E add esp, 0C0h.text:00464134 cmp ebp, esp.text:00464136 call sub_45F17F.text:0046413B mov esp, ebp.text:0046413D pop ebp.text:0046413E retn 源码 12345678void IntShow(int* n) { printf(&quot;%d %d %d&quot;, n[0], n[1], n[2]);}int main(){ int arr[3] = { 1,2,3 }; IntShow(arr); return 0;} 字符型一维数组 123456789101112131415161718192021222324252627282930313233343536373839.text:00464281 mov eax, ds:dword_520E60 ; 'lleh'.text:00464286 mov [ebp+var_24], eax ; 用eax过渡，传给局部变量.text:00464289 mov cx, ds:word_520E64 ; 'o'.text:00464290 mov [ebp+var_20], cx ; 用cx过渡，传给局部变量.text:00464294 lea eax, [ebp+var_24].text:00464297 push eax ; 前半段的地址入栈.text:00464298 call sub_45E3AB.text:0046429D add esp, 4;sub_45E3AB.text:00463FC0 arg_0 = dword ptr 8.text:00463FC0.text:00463FC0 push ebp.text:00463FC1 mov ebp, esp.text:00463FC3 sub esp, 0C0h.text:00463FC9 push ebx.text:00463FCA push esi.text:00463FCB push edi.text:00463FCC mov edi, ebp.text:00463FCE xor ecx, ecx.text:00463FD0 mov eax, 0CCCCCCCCh.text:00463FD5 rep stosd.text:00463FD7 mov ecx, offset unk_54D014.text:00463FDC call sub_45FF35.text:00463FE1 nop.text:00463FE2 mov eax, [ebp+arg_0] ; 参数传给eax.text:00463FE5 push eax.text:00463FE6 push offset aS ; &quot;%s&quot;.text:00463FEB call sub_45DB5E ; printf.text:00463FF0 add esp, 8.text:00463FF3 pop edi.text:00463FF4 pop esi.text:00463FF5 pop ebx.text:00463FF6 add esp, 0C0h.text:00463FFC cmp ebp, esp.text:00463FFE call sub_45F17F.text:00464003 mov esp, ebp.text:00464005 pop ebp.text:00464006 retn 源码 12345678void CharShow(char* n) { printf(&quot;%s&quot;, n);}int main(){ char buf[] = { &quot;hello&quot; }; CharShow(buf); return 0;} 数组作为返回值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.text:004642C3 call sub_45FC79.text:004642C8 mov [ebp+var_40], eax ; 从返回值中取出传到局部变量.text:004642CB mov eax, [ebp+var_40] ; 放入寄存器中push作为参数.text:004642CE push eax.text:004642CF push offset aS ; &quot;%s&quot;.text:004642D4 call sub_45DB59 ; printf.text:004642D9 add esp, 8;sub_45FC79.text:00464020 var_14 = byte ptr -14h.text:00464020 var_10 = dword ptr -10h.text:00464020 var_C = word ptr -0Ch.text:00464020 var_A = byte ptr -0Ah.text:00464020 var_4 = dword ptr -4.text:00464020.text:00464020 push ebp.text:00464021 mov ebp, esp.text:00464023 sub esp, 0D4h.text:00464029 push ebx.text:0046402A push esi.text:0046402B push edi.text:0046402C lea edi, [ebp+var_14].text:0046402F mov ecx, 5.text:00464034 mov eax, 0CCCCCCCCh.text:00464039 rep stosd.text:0046403B mov eax, ___security_cookie.text:00464040 xor eax, ebp.text:00464042 mov [ebp+var_4], eax.text:00464045 mov ecx, offset unk_54E014.text:0046404A call sub_45FF35.text:0046404F nop.text:00464050 mov eax, ds:dword_521E60 ; 'oviv'.text:00464055 mov [ebp+var_10], eax ; eax过渡，传给局部变量.text:00464058 mov cx, ds:word_521E64 ; '05'.text:0046405F mov [ebp+var_C], cx ; cx过渡，传给局部变量.text:00464063 mov dl, ds:byte_521E66.text:00464069 mov [ebp+var_A], dl.text:0046406C lea eax, [ebp+var_10] ; 前半段给eax，作为返回值传递.text:0046406F push edx.text:00464070 mov ecx, ebp.text:00464072 push eax.text:00464073 lea edx, dword_4640A0.text:00464079 call sub_45EC52.text:0046407E pop eax.text:0046407F pop edx.text:00464080 pop edi.text:00464081 pop esi.text:00464082 pop ebx.text:00464083 mov ecx, [ebp+var_4].text:00464086 xor ecx, ebp ; StackCookie.text:00464088 call j_@__security_check_cookie@4 ; __security_check_cookie(x).text:0046408D add esp, 0D4h.text:00464093 cmp ebp, esp.text:00464095 call sub_45F17A.text:0046409A mov esp, ebp.text:0046409C pop ebp.text:0046409D retn 源码 123456789char* CrZT() { char temp[7] = &quot;vivo50&quot;; return temp;}int main(){ char* p = CrZT(); printf(&quot;%s&quot;, p); return 0;} 整形二维数组（和一维数组没有本质上的区别，都是占用一段连续的内存空间） 1234567891011121314151617181920212223242526272829303132333435.text:004642DC mov [ebp+var_58], 1.text:004642E3 mov [ebp+var_54], 2.text:004642EA mov [ebp+var_50], 3.text:004642F1 mov [ebp+var_4C], 4.text:004642F8 mov eax, 8.text:004642FD shl eax, 0 ; eax=8*2^0=8.text:00464300 lea ecx, [ebp+eax+var_58] ; 即[ebp+var_58+8]，即[ebp+var_50].text:00464304 mov edx, 4.text:00464309 shl edx, 0 ; edx=4*2^0=4.text:0046430C mov eax, [ecx+edx] ; 即[ebp+var_58+0Ch]，即[ebp+var_4C].text:0046430F push eax.text:00464310 mov ecx, 8.text:00464315 shl ecx, 0 ; ecx=8*2^0=8.text:00464318 lea edx, [ebp+ecx+var_58] ; 即[ebp+var_58+8]，即[ebp+var_50].text:0046431C mov eax, 4.text:00464321 imul ecx, eax, 0 ; ecx=0.text:00464324 mov edx, [edx+ecx] ; 即[ebp+var_50].text:00464327 push edx.text:00464328 mov eax, 8.text:0046432D imul ecx, eax, 0 ; ecx=8*0=0.text:00464330 lea edx, [ebp+ecx+var_58] ; 即[ebp+var_58].text:00464334 mov eax, 4.text:00464339 shl eax, 0 ; eax=4*2^0=4.text:0046433C mov ecx, [edx+eax] ; 即[ebp+var_54].text:0046433F push ecx.text:00464340 mov edx, 8.text:00464345 imul eax, edx, 0 ; eax=8*0=0.text:00464348 lea ecx, [ebp+eax+var_58] ; 即[ebp+var_58].text:0046434C mov edx, 4.text:00464351 imul eax, edx, 0 ; ecx=4*0=0.text:00464354 mov ecx, [ecx+eax] ; 即[ebp+var_58].text:00464357 push ecx.text:00464358 push offset aDDDD ; &quot;%d,%d,%d,%d&quot;.text:0046435D call sub_45DB59 ; printf.text:00464362 add esp, 14h 源码 12int num[2][2] = { {1,2},{3,4} };printf(&quot;%d,%d,%d,%d&quot;, num[0][0], num[0][1], num[1][0], num[1][1]);","link":"/2025/07/17/Day7-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E8%AF%86%E5%88%AB/"},{"title":"Day6:if-else语句识别、switch语句识别、循环语句识别","text":"if-else语句识别、switch语句识别、循环语句识别 if-else语句识别 第一种，数值比较作为条件（x86debug为例，其余类似，仅是比较方法（如使用sub而不是cmp）和模式特征上的差异） 1234567891011121314151617.text:004702D0 lea eax, [ebp+var_C].text:004702D3 push eax.text:004702D4 push offset unk_545E50 ; %d.text:004702D9 call sub_4681E0 ; scanf.text:004702DE add esp, 8.text:004702E1 cmp [ebp+var_C], 1.text:004702E5 jnz short loc_4702F6 ; if [ebp+var_C]!=1, jump to loc_4702f6.text:004702E7 push offset aNEquales1 ; &quot;n equales 1&quot;.text:004702EC call sub_468D1B ; printf.text:004702F1 add esp, 4.text:004702F4 jmp short loc_470303.text:004702F6 ; ---------------------------------------------------------------------------.text:004702F6.text:004702F6 loc_4702F6: ; CODE XREF: main+45↑j.text:004702F6 push offset aNDoesNotEqual1 ; &quot;n does not equal 1&quot;.text:004702FB call sub_468D1B ; printf.text:00470300 add esp, 4 源码： 123456int n;scanf(&quot;%d&quot;, &amp;n);if (n == 1) printf(&quot;n equales 1&quot;);else printf(&quot;n does not equal 1&quot;); 第二种，变量直接作为条件 12345678910.text:00470303 lea eax, [ebp+var_18].text:00470306 push eax.text:00470307 push offset unk_545E50 ; %d.text:0047030C call sub_4681E0 ; scanf.text:00470311 add esp, 8.text:00470314 cmp [ebp+var_18], 0 ; 和'0'比较.text:00470318 jz short loc_470327 ; if [ebp+var_18]==0, jump to loc_470327, 跳过printf.text:0047031A push offset aJudgeIsNotZero ; &quot;judge is not zero&quot;.text:0047031F call sub_468D1B ; printf.text:00470324 add esp, 4 源码： 1234int judge;scanf(&quot;%d&quot;, &amp;judge);if (judge) printf(&quot;judge is not zero&quot;); 第三种，返回值（函数式）作为条件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.text:00470387 lea eax, [ebp+var_24].text:0047038A push eax.text:0047038B push offset unk_545E50 ; %d.text:00470390 call sub_4681E0 ; scanf.text:00470395 add esp, 8.text:00470398 mov eax, [ebp+var_24].text:0047039B push eax ; 输入的值入栈，即函数传参.text:0047039C call sub_46B214 ; 自定义函数.text:004703A1 add esp, 4.text:004703A4 test eax, eax ; 1 &amp; 1 = 0； 0 &amp; 0 = 1.text:004703A6 jz short loc_4703B5.text:004703A8 push offset aItS0 ; &quot;it's 0\\n&quot;.text:004703AD call sub_468D1B.text:004703B2 add esp, 4;sub_46b214.text:00470110 arg_0 = dword ptr 8.text:00470110.text:00470110 push ebp.text:00470111 mov ebp, esp.text:00470113 sub esp, 0C0h.text:00470119 push ebx.text:0047011A push esi.text:0047011B push edi.text:0047011C mov edi, ebp.text:0047011E xor ecx, ecx.text:00470120 mov eax, 0CCCCCCCCh.text:00470125 rep stosd.text:00470127 mov ecx, offset unk_57500E.text:0047012C call sub_46B660.text:00470131 nop.text:00470132 cmp [ebp+arg_0], 0 ; [ebp+8], eax在栈上的位置.text:00470136 jnz short loc_470141 ; eax=0.text:00470138 mov eax, 1 ; if [ebp+arg_0]==0, eax=1, return 1(eax).text:0047013D jmp short loc_470143.text:0047013F ; ---------------------------------------------------------------------------.text:0047013F jmp short loc_470143.text:00470141 ; ---------------------------------------------------------------------------.text:00470141.text:00470141 loc_470141: ; CODE XREF: sub_470110+26↑j.text:00470141 xor eax, eax ; eax=0.text:00470143.text:00470143 loc_470143: ; CODE XREF: sub_470110+2D↑j.text:00470143 ; sub_470110+2F↑j.text:00470143 pop edi.text:00470144 pop esi.text:00470145 pop ebx.text:00470146 add esp, 0C0h.text:0047014C cmp ebp, esp.text:0047014E call sub_46A62A.text:00470153 mov esp, ebp.text:00470155 pop ebp.text:00470156 retn 源码 1234567891011121314int IfZero(int a) { if (a == 0) return 1; else return 0;}int main(){ int a; scanf(&quot;%d&quot;, &amp;a); if(IfZero(a)) printf(&quot;it's 0\\n&quot;); return 0;} switch语句识别 比较简单的情况下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.text:00470327 lea eax, [ebp+var_24].text:0047032A push eax.text:0047032B push offset unk_545E50 ; %d.text:00470330 call sub_4681E0 ; scanf.text:00470335 add esp, 8.text:00470338 mov eax, [ebp+var_24].text:0047033B mov [ebp+var_EC], eax ; [ebp+var_EC]==[ebp+var_24], 用临时变量[ebp+var_EC]来检验case.text:00470341 cmp [ebp+var_EC], 1.text:00470348 jz short loc_47035E ; case1输出.text:0047034A cmp [ebp+var_EC], 5.text:00470351 jz short loc_470371 ; case5输出.text:00470353 cmp [ebp+var_EC], 0Ah.text:0047035A jz short loc_470384 ; case10输出.text:0047035C jmp short loc_470395 ; break然后system(&quot;pause&quot;).text:0047035E ; ---------------------------------------------------------------------------.text:0047035E.text:0047035E loc_47035E: ; CODE XREF: main+A8↑j.text:0047035E mov eax, [ebp+var_24].text:00470361 push eax.text:00470362 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470367 call sub_468D1B ; printf.text:0047036C add esp, 8.text:0047036F jmp short loc_470395.text:00470371 ; ---------------------------------------------------------------------------.text:00470371.text:00470371 loc_470371: ; CODE XREF: main+B1↑j.text:00470371 mov eax, [ebp+var_24].text:00470374 push eax.text:00470375 push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047037A call sub_468D1B ; printf.text:0047037F add esp, 8.text:00470382 jmp short loc_470395.text:00470384 ; ---------------------------------------------------------------------------.text:00470384.text:00470384 loc_470384: ; CODE XREF: main+BA↑j.text:00470384 mov eax, [ebp+var_24].text:00470387 push eax.text:00470388 push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047038D call sub_468D1B ; printf.text:00470392 add esp, 8.text:00470395.text:00470395 loc_470395: ; CODE XREF: main+BC↑j.text:00470395 ; main+CF↑j ....text:00470395 push offset aPause ; &quot;pause&quot;.text:0047039A call sub_46AFAD ; system(&quot;pause&quot;).text:0047039F add esp, 4 源码： 1234567891011121314int number;scanf(&quot;%d&quot;, &amp;number);switch (number) {case 1: printf(&quot;n equals %d&quot;, number); break;case 5: printf(&quot;n equals %d&quot;, number); break;case 10: printf(&quot;n equals %d&quot;, number); break;}system(&quot;pause&quot;); 再复杂点，会优化出跳转表，即每个case跳转的地址会被集合成一个数组，像表一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889.text:004702D3 push eax.text:004702D4 push offset unk_545E50 ; %d.text:004702D9 call sub_4681E0 ; scanf.text:004702DE add esp, 8.text:004702E1 mov eax, [ebp+var_C].text:004702E4 mov [ebp+var_D4], eax.text:004702EA mov ecx, [ebp+var_D4] ; 把输入值传到ecx，下一步减去1，减1的原因见后面的解释.text:004702F0 sub ecx, 1 ; switch 67 cases.text:004702F3 mov [ebp+var_D4], ecx.text:004702F9 cmp [ebp+var_D4], 42h ; 把输入值和42h(66)比较，下一步是大于66就跳出case的判断.text:00470300 ja def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470306 mov edx, [ebp+var_D4].text:0047030C movzx eax, ds:byte_470418[edx] ; 跳转表索引值表，即预判了输入值的范围并且为每个可能的值建立了索引值表（比如说现在确定了范围是0-66，就枚举了0-66这些数值对应的索引，然后再根据索引找到应改跳转的地址.text:00470313 jmp ds:jpt_470313[eax*4] ; switch jump.text:0047031A ; ---------------------------------------------------------------------------.text:0047031A.text:0047031A loc_47031A: ; CODE XREF: sub_4702A0+73↑j.text:0047031A ; DATA XREF: .text:jpt_470313↓o.text:0047031A mov eax, [ebp+var_C] ; jumptable 00470313 case 1.text:0047031D push eax.text:0047031E push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470323 call sub_468D1B ; printf.text:00470328 add esp, 8.text:0047032B jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:0047032D ; ---------------------------------------------------------------------------.text:0047032D.text:0047032D loc_47032D: ; CODE XREF: sub_4702A0+73↑j.text:0047032D ; DATA XREF: .text:jpt_470313↓o.text:0047032D mov eax, [ebp+var_C] ; jumptable 00470313 case 5.text:00470330 push eax.text:00470331 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470336 call sub_468D1B ; printf.text:0047033B add esp, 8.text:0047033E jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470340 ; ---------------------------------------------------------------------------.text:00470340.text:00470340 loc_470340: ; CODE XREF: sub_4702A0+73↑j.text:00470340 ; DATA XREF: .text:jpt_470313↓o.text:00470340 mov eax, [ebp+var_C] ; jumptable 00470313 case 10.text:00470343 push eax.text:00470344 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470349 call sub_468D1B ; printf.text:0047034E add esp, 8.text:00470351 jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470353 ; ---------------------------------------------------------------------------.text:00470353.text:00470353 loc_470353: ; CODE XREF: sub_4702A0+73↑j.text:00470353 ; DATA XREF: .text:jpt_470313↓o.text:00470353 mov eax, [ebp+var_C] ; jumptable 00470313 case 17.text:00470356 push eax.text:00470357 push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047035C call sub_468D1B ; printf.text:00470361 add esp, 8.text:00470364 jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470366 ; ---------------------------------------------------------------------------.text:00470366.text:00470366 loc_470366: ; CODE XREF: sub_4702A0+73↑j.text:00470366 ; DATA XREF: .text:jpt_470313↓o.text:00470366 mov eax, [ebp+var_C] ; jumptable 00470313 case 11.text:00470369 push eax.text:0047036A push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047036F call sub_468D1B ; printf.text:00470374 add esp, 8.text:00470377 jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470379 ; ---------------------------------------------------------------------------.text:00470379.text:00470379 loc_470379: ; CODE XREF: sub_4702A0+73↑j.text:00470379 ; DATA XREF: .text:jpt_470313↓o.text:00470379 mov eax, [ebp+var_C] ; jumptable 00470313 case 67.text:0047037C push eax.text:0047037D push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470382 call sub_468D1B ; printf.text:00470387 add esp, 8.text:0047038A jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:0047038C ; ---------------------------------------------------------------------------.text:0047038C.text:0047038C loc_47038C: ; CODE XREF: sub_4702A0+73↑j.text:0047038C ; DATA XREF: .text:jpt_470313↓o.text:0047038C mov eax, [ebp+var_C] ; jumptable 00470313 case 3.text:0047038F push eax.text:00470390 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470395 call sub_468D1B ; printf.text:0047039A add esp, 8.text:0047039D.text:0047039D def_470313: ; CODE XREF: sub_4702A0+60↑j.text:0047039D ; sub_4702A0+73↑j ....text:0047039D push offset aPause ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:004703A2 call sub_46AFAD ; system.text:004703A7 add esp, 4 源码 1234567891011121314151617181920212223242526int number;scanf(&quot;%d&quot;, &amp;number);switch (number) {case 1: printf(&quot;n equals %d&quot;, number); break;case 5: printf(&quot;n equals %d&quot;, number); break;case 10: printf(&quot;n equals %d&quot;, number); break;case 17: printf(&quot;n equals %d&quot;, number); break;case 11: printf(&quot;n equals %d&quot;, number); break;case 67: printf(&quot;n equals %d&quot;, number); break;case 3: printf(&quot;n equals %d&quot;, number); break;}system(&quot;pause&quot;); 对跳转表和索引值表进行进一步解释： 先看跳转表： 可以看到跳转表只有简单的8种情况。但是编译器（反编译器？）只能根据case的最大值用笨方法枚举可能的值，这时候，就可以给这些枚举的值分成两种：一种是case里有的，一种是case里没有的。看跳转表的最后一个，叫def而不是loc，这个就是给case里没有的枚举值准备的。因为分为case里有的和没有的，因此，case里有的，会给出具体的索引值；case里没有的，统一导向跳转表的最后一个。再看索引值表： 可以看到，里面枚举了0到66对应的索引值。看汇编代码，是将输入的值作为索引值表的索引来用的，索引出来的值再作为跳转表的索引。注意看，索引值表的最小值为0，因此，跳转表和数组一样从0开始索引，而0-7对应跳转表的八种情况。通过进一步挖掘信息，还可以知道跳转表是把case按照从小到大的顺序排列的。因此，最开始会对输入值有一个减的操作。至于为什么减1，我们就可以推测最小的case是1了，因为索引从0开始，而最小的case在索引0处。 这样解释下来可能还有点绕，所以我们按照机器的动作走一遍： 首先，把case按顺序排出跳转表。 然后，假设我们拿到输入的值。作为机器，我们知道case有：1，3，5，10，17，11，67，所以先给输入的值减1，以便这个值是1的时候我们可以索引到跳转表下标0处。同时，如果这个值大于66，我们还可以直接跳过case检查，直接导出去（刚好和在case最大最小值范围内但不是case的值一样对待） 再然后，我们枚举0-66的值，并且把这些值和case里有的值一一比较，分出两种值：一种在case里，一种不再case里。 ok，然后我们建立索引值表，给在case里的枚举值对应的跳转表索引值，比如说枚举值2（输入值是3），刚好case里有3，按顺序排第二，我们就给索引值1（从0开始索引）。回头看截出来的索引值表，在下标2的地方刚好是1（枚举值索引出跳转表索引）；给不在case里的值索引到7，对应跳转表最后一位（为没在case里的值专门准备的那一位）。 最后，我们就准备好我们的解决方案了，对于任意输入的值我们就都有对策了。 请务必真正理解上述内容，因为在逆向工程中，这么绕的操作很常见。在PE文件结构部分，我们或许还有机会再接触到这么绕的操作。（其实只需要写出程序拿到ida里点开跳转表和索引值表（如果有的话）看几眼就明白了，亲身实践总比阅读文字来的有效，因为文字还取决于书写者的表达水平(●’◡’●)） 循环语句识别 第一种，for循环 12345678910111213141516171819202122232425.text:00464096 mov [ebp+var_8], 0 ; 一个变量初始化为0.text:0046409D mov [ebp+var_14], 1 ; 另一个变量初始化为1.text:004640A4 jmp short loc_4640AF.text:004640A6 ; ---------------------------------------------------------------------------.text:004640A6.text:004640A6 loc_4640A6: ; CODE XREF: sub_464070+4E↓j.text:004640A6 mov eax, [ebp+var_14].text:004640A9 add eax, 1 ; 用eax过渡，给[ebp+var_14]加1.text:004640AC mov [ebp+var_14], eax.text:004640AF.text:004640AF loc_4640AF: ; CODE XREF: sub_464070+34↑j.text:004640AF cmp [ebp+var_14], 0Ah.text:004640B3 jg short loc_4640C0 ; [ebp+var_14]大于0Ah时跳转（出循环）.text:004640B5 mov eax, [ebp+var_8].text:004640B8 add eax, [ebp+var_14] ; 用eax过渡，把[ebp+var_14]的值加到[ebp+var_8]上.text:004640BB mov [ebp+var_8], eax.text:004640BE jmp short loc_4640A6 ; 跳回去，形成循环.text:004640C0 ; ---------------------------------------------------------------------------.text:004640C0.text:004640C0 loc_4640C0: ; CODE XREF: sub_464070+43↑j.text:004640C0 mov eax, [ebp+var_8].text:004640C3 push eax.text:004640C4 push offset aCountD ; &quot;count : %d &quot;.text:004640C9 call sub_45DB54 ; printf.text:004640CE add esp, 8 源码 12345int count = 0;for (int i = 1; i &lt;= 10; i++) { count += i;}printf(&quot;count : %d &quot;, count); 第二种，while循环 123456789101112131415161718192021.text:004640D1 mov [ebp+var_8], 0 ; 一个变量初始化为0.text:004640D8 mov [ebp+var_20], 0Ah ; 另一个变量初始化为10.text:004640DF.text:004640DF loc_4640DF: ; CODE XREF: sub_464070+87↓j.text:004640DF cmp [ebp+var_20], 0.text:004640E3 jle short loc_4640F9 ; [ebp+var_20]小于等于0时跳转（出循环）.text:004640E5 mov eax, [ebp+var_8].text:004640E8 add eax, [ebp+var_20] ; eax过渡，把[ebp+var_20]值加到[ebp+var_8]上.text:004640EB mov [ebp+var_8], eax.text:004640EE mov eax, [ebp+var_20].text:004640F1 sub eax, 1 ; eax过渡，给[ebp+var_20]减1.text:004640F4 mov [ebp+var_20], eax.text:004640F7 jmp short loc_4640DF ; 回跳，形成循环.text:004640F9 ; ---------------------------------------------------------------------------.text:004640F9.text:004640F9 loc_4640F9: ; CODE XREF: sub_464070+73↑j.text:004640F9 mov eax, [ebp+var_8].text:004640FC push eax.text:004640FD push offset aCountD ; &quot;count : %d &quot;.text:00464102 call sub_45DB54 ; printf.text:00464107 add esp, 8 源码 1234567int count = 0;int n = 10;while (n &gt; 0) { count += n; n--;}printf(&quot;count : %d &quot;, count); 第三种，do-while循环 1234567891011121314151617.text:0046410A mov [ebp+var_8], 0 ; 一个变量初始化为0.text:00464111 mov [ebp+var_2C], 0Ah ; 另一个变量初始化为10.text:00464118.text:00464118 loc_464118: ; CODE XREF: sub_464070+BE↓j.text:00464118 mov eax, [ebp+var_8].text:0046411B add eax, [ebp+var_2C] ; eax过渡，把[ebp+var_2C]值加到[ebp+var_8]上.text:0046411E mov [ebp+var_8], eax.text:00464121 mov eax, [ebp+var_2C].text:00464124 sub eax, 1 ; eax过渡，给[ebp+var_2C]减1.text:00464127 mov [ebp+var_2C], eax.text:0046412A cmp [ebp+var_2C], 0.text:0046412E jg short loc_464118 ; [ebp+var_2C]大于0时回跳.text:00464130 mov eax, [ebp+var_8].text:00464133 push eax.text:00464134 push offset aCountD ; &quot;count : %d &quot;.text:00464139 call sub_45DB54 ; printf.text:0046413E add esp, 8 源码 1234567int count = 0;int i = 10;do { count += i; i--;} while (i &gt; 0);printf(&quot;count : %d &quot;, count);","link":"/2025/07/15/Day6-switch%E8%AF%AD%E5%8F%A5%E8%AF%86%E5%88%AB/"},{"title":"Day9:壳与脱壳（一）","text":"壳、壳的加载过程、工具脱壳、手动脱壳流程、esp定律（基于Xdbg） 壳 先看ctf-wiki对壳的介绍： 壳 是在一些计算机软件里一段专门负责保护软件不被非法修改或反编译的程序。 它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。 因此，加壳程序包含壳程序和原程序两个部分，且原程序在壳程序运行后才恢复到独立可执行的状态。因此，可以借助动态调试器在壳程序运行完后进行dump，从而获得独立可执行的原程序 常见的壳有压缩壳和加密壳两种： 压缩壳：upx、ASpack、PECompat等 加密壳：VMProtect、Themida、ASProtector等 壳的加载过程 壳和原程序在逻辑上基本没有关联，因此，壳程序在解析加壳后的二进制文件前，会先保存各寄存器的值，通常用pushad/puahfd实现 解析完成后，是原程序的逻辑部分，此时，壳程序给出控制权，寄存器恢复到解析前的状态，通常用popad/popfd实现 最后，程序跳到原程序入口点开始执行 工具脱壳 直接使用工具脱壳的情况主要有两种：一种是无修改的、只使用加壳程序加壳；另一种是使用加壳程序加壳后修改了区块名的。前者可以直接使用加壳程序脱壳（如果具备脱壳功能的话），后者先修改区块名再使用加壳程序脱壳。 upx无修改加壳示例： 拿到可执行文件，先到DIE查看，发现有壳。对壳的信息描述没有出现“modified”字眼，因此判断是无修改加壳，直接使用工具脱壳 直接使用upx -d脱壳 再次用DIE打开，发现没有识别出壳了 upx修改区块名加壳示例： 先到DIE查看壳信息，发现是upx modified 点击“区块“下方的”&gt;“查看区块信息，发现区块名有改动 010editor修改区块名 再次查看壳信息，变成无修改加壳了，直接工具脱壳 手动脱壳流程 步骤： 查壳：使用DIE、ExeinfoPE、PEiD等工具查壳 寻找程序原入口点(OEP)：通过各种方法找到壳代码结束、程序真正开始的地方 dump内存：借助插件从OEP开始dump出原程序 输入表(IAT)重建：借助插件重建输入表 关闭程序重定位：使用DIE等工具关闭程序重定位 寻找OEP的方法有很多，而dump和IAT重建以及关闭重定位的方法基本固定。先用一个例子展示整体流程，再详细展开寻找OEP的方法。upx手动脱壳示例： 查壳：显示是upx 寻找OEP： 采用esp定律法（详见下文）找到push ebp开头的一段代码 dump内存： 打开插件scylla，点击“转储”栏中的“转储”，会获得一个_dump后缀的exe文件 IAT重建： 点击“IAT自动搜索”，会有弹窗问是否使用高级搜索结果，点“是”。这时候，VA和“大小”两个框会被填充。 接下来点“获取导入”，上方的大框中会出现dll结尾的东西，需要把带红色X的取消勾选 然后点击修复转储，选择刚刚dump出来的文件，会得到一个再加上_SCY的exe文件。 此时程序大概率运行不了，会闪退。但是对于静态分析来说，到这一步已经足够了。 关闭重定位：把得到的_dump_SCY.exe文件拖到DIE，点击“区块”栏的“&gt;”，会弹出文件结构界面 先取消勾选右上角的“只读” 点击IMAGE_NT_HEADERS下的IMAGE_FILE_HEADER，在“标志”选项中勾选“RELOCS_STRIPPED”（图中未勾选） 再点击IMAGE_OPTIONAL_HEADERS，找到另一个标志(DllCharacteristics)，取消勾选“DYNAMIC_BASE”（图中未取消） 这样子，我们的程序就脱完壳并且可以正常运行了 PS：关于IAT重建这一步骤，为什么不能IAT自动搜索再转储一步到位？ 结合AI的解释，个人见解是IAT自动搜索的过程可能会运行程序，导致地址刷新，OEP失效，dump出来的程序不完整或者不对。因此，dump和IAT重建实际上是两个步骤，不过被集成到了一个界面。其实还有手动重建IAT的方法，这种情况下就确确实实需要先dump再导入重建的IAT了，因为在调试器中找到OEP后还要继续找IAT 寻找OEP的方法（一）ESP定律 前文，我们知道了壳程序解析时会有pushad\\popad或者pushfd\\popfd的操作。pushad时，随着通用寄存器值的入栈，esp的值会发生变化，又因为栈平衡的特性，最终esp的值会回到pushad后的这个值。因此，可以借助这一点，给pushad后的esp值下硬件访问断点，popad后就会触发断点，中断调试，进而实现跳过整个壳解析过程。当然，中断处还不是OEP，一般在中断处后会有一个跨度明显的jmp，甚至jmp后还有一个跳转表jmp才会到达真正的OEP 具体操作如下： xdbg打开，F9到程序所在内存区域 可以看到EIP所在就是pushad F8步过，esp更新 在右下角栈窗口设上硬件访问断点 点击工具栏“视图”下方的“-&gt;”，程序会执行过popad。可以看到下方不远处有个大跳 F8到大跳处F7步入，有跳转表继续F7步入，可以看到开辟栈帧操作，这里就是OEP了，在此处直接使用scylla dump出程序 单步跟踪法 如名，就是一直按F8，让程序尽量向下走，遇到循环就跳过，遇到近call就步入，重点关注大跳 参考ctf-wiki https://ctf-wiki.org/reverse/platform/windows/unpack/trace/","link":"/2025/07/29/Day9-%E5%A3%B3/"},{"title":"Day8:thiscall、类","text":"thiscall、类 调用约定：thiscall 对于C++this指针的特性，有一种专门的调用约定叫thiscall，主要用于类出现的场景 无论x86/x64，this指针均由ecx/rcx扮演，指向对象的内存地址 thiscall由被调用者清理参数占用的栈空间 类（一） 简单的构造析构分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130;main函数.text:004641E0 var_EC = dword ptr -0ECh.text:004641E0 var_30 = byte ptr -30h.text:004641E0 var_20 = dword ptr -20h.text:004641E0 var_4 = dword ptr -4.text:004641E0.text:004641E0 push ebp.text:004641E1 mov ebp, esp.text:004641E3 sub esp, 0F0h.text:004641E9 push ebx.text:004641EA push esi.text:004641EB push edi.text:004641EC lea edi, [ebp+var_30].text:004641EF mov ecx, 0Ch.text:004641F4 mov eax, 0CCCCCCCCh.text:004641F9 rep stosd.text:004641FB mov eax, ___security_cookie.text:00464200 xor eax, ebp.text:00464202 mov [ebp+var_4], eax.text:00464205 mov ecx, offset unk_54D014.text:0046420A call sub_45FF30.text:0046420F nop.text:00464210 push offset aXiaoming ; 参数&quot;xiaoming&quot;.text:00464215 push 1 ; 另一个参数.text:00464217 lea ecx, [ebp+var_20] ; [ebp+var_20]是一个对象，this指针指向该对象.text:0046421A call sub_46062E ; 构造函数.text:0046421F nop.text:00464220 push offset aPause ; &quot;pause&quot;.text:00464225 call sub_45F98B ; system.text:0046422A add esp, 4.text:0046422D mov [ebp+var_EC], 0.text:00464237 lea ecx, [ebp+var_20] ; this指针.text:0046423A call sub_45D38E ; 析构函数.text:0046423F mov eax, [ebp+var_EC].text:00464245 push edx.text:00464246 mov ecx, ebp.text:00464248 push eax.text:00464249 lea edx, dword_464274.text:0046424F call sub_45EC4D.text:00464254 pop eax.text:00464255 pop edx.text:00464256 pop edi.text:00464257 pop esi.text:00464258 pop ebx.text:00464259 mov ecx, [ebp+var_4].text:0046425C xor ecx, ebp ; StackCookie.text:0046425E call j_@__security_check_cookie@4 ; __security_check_cookie(x).text:00464263 add esp, 0F0h.text:00464269 cmp ebp, esp.text:0046426B call sub_45F175.text:00464270 mov esp, ebp.text:00464272 pop ebp.text:00464273 retn;构造函数.text:00463FC0 var_C = byte ptr -0Ch.text:00463FC0 var_8 = dword ptr -8.text:00463FC0 arg_0 = dword ptr 8.text:00463FC0 arg_4 = dword ptr 0Ch.text:00463FC0.text:00463FC0 push ebp.text:00463FC1 mov ebp, esp.text:00463FC3 sub esp, 0CCh.text:00463FC9 push ebx.text:00463FCA push esi.text:00463FCB push edi.text:00463FCC push ecx.text:00463FCD lea edi, [ebp+var_C].text:00463FD0 mov ecx, 3.text:00463FD5 mov eax, 0CCCCCCCCh.text:00463FDA rep stosd.text:00463FDC pop ecx.text:00463FDD mov [ebp+var_8], ecx ; 当前对象地址保存到[ebp+var_8].text:00463FE0 mov ecx, offset unk_54D014.text:00463FE5 call sub_45FF30.text:00463FEA nop.text:00463FEB mov eax, [ebp+var_8] ; 第一个对象成员.text:00463FEE mov ecx, [ebp+arg_0] ; 第一个参数1.text:00463FF1 mov [eax], ecx.text:00463FF3 push 4.text:00463FF5 mov eax, [ebp+arg_4] ; 第二个参数&quot;xiaoming&quot;.text:00463FF8 push eax.text:00463FF9 mov ecx, [ebp+var_8].text:00463FFC add ecx, 4 ; 第二个对象成员.text:00463FFF push ecx.text:00464000 call sub_45FCF1 ; memcpy().text:00464005 add esp, 0Ch.text:00464008 mov eax, [ebp+var_8] ; 返回的是对象地址.text:0046400B pop edi.text:0046400C pop esi.text:0046400D pop ebx.text:0046400E add esp, 0CCh.text:00464014 cmp ebp, esp.text:00464016 call sub_45F175.text:0046401B mov esp, ebp.text:0046401D pop ebp.text:0046401E retn 8;析构函数.text:00464040 var_C = byte ptr -0Ch.text:00464040 var_8 = dword ptr -8.text:00464040.text:00464040 push ebp.text:00464041 mov ebp, esp.text:00464043 sub esp, 0CCh.text:00464049 push ebx.text:0046404A push esi.text:0046404B push edi.text:0046404C push ecx.text:0046404D lea edi, [ebp+var_C].text:00464050 mov ecx, 3.text:00464055 mov eax, 0CCCCCCCCh.text:0046405A rep stosd.text:0046405C pop ecx.text:0046405D mov [ebp+var_8], ecx ; 把对象地址存到[ebp+var_8].text:00464060 mov ecx, offset unk_54D014.text:00464065 call sub_45FF30.text:0046406A nop.text:0046406B push offset aDestructing ; &quot;destructing......&quot;.text:00464070 call sub_45DB59 ; printf.text:00464075 add esp, 4.text:00464078 pop edi.text:00464079 pop esi.text:0046407A pop ebx.text:0046407B add esp, 0CCh.text:00464081 cmp ebp, esp.text:00464083 call sub_45F175.text:00464088 mov esp, ebp.text:0046408A pop ebp.text:0046408B retn 源码 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;class Student {private: int ID; char name[20];public: Student(int n = 0, const char* na = &quot;NONE&quot;) :ID(n) { memcpy(name, na, sizeof(na)); } void show(); ~Student();};void Student::show() { printf(&quot;%d %s\\n&quot;, ID, name);}Student::~Student() { printf(&quot;destructing......&quot;);}int main() { Student stu(001, &quot;xiaoming&quot;); system(&quot;pause&quot;); return 0;}","link":"/2025/07/21/Day8-%E7%B1%BB/"},{"title":"Re:从0到1的脚本之路","text":"python脚本做题记录 [SWPUCTF 2021 新生赛]fakebase12345678910111213141516#给的代码如下：flag = 'xxxxxxxxxxxxxxxxxxx's_box = 'qwertyuiopasdfghjkzxcvb123456#$'tmp = ''for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8)b1 = int(tmp,2)s = ''while b1//31 != 0: s += s_box[b1%31] b1 = b1//31print(s)# s = u#k4ggia61egegzjuqz12jhfspfkay 代码中，把flag逐字符转化为二进制，截掉前缀，填充为8位，再拼接这些二进制数得到tmp 然后把tmp转化为十进制b1，不断除31，同时用余数做S_box索引，把索引值拼接得到S 所以，解密思路是，首先，还原b1： b1利用后得到一系列索引值，所以由索引值反推b1 逆序s对照s_box得出索引（为了从最后一个余数开始还原b1）并组成一个列表。因为循环终止条件是b1//31==0，所以最后一次除只利用了商等于0，而余数未知，于是从0-30假设被弃掉的余数，枚举各种可能。 而如何判断哪种可能是我们需要的呢？就需要还原出flag并判断。把还原出来的b1转二进制，去掉前缀，填充到8的倍数方便截取二进制数，然后8个8个还原出字符，最后判断是不是flag就行了。 EXP： 1234567891011121314151617181920212223242526buf=&quot;u#k4ggia61egegzjuqz12jhfspfkay&quot;s_box = 'qwertyuiopasdfghjkzxcvb123456#$'index_list=[]#求索引值列表for i in buf[::-1]: for j in range(len(s_box)): if i == s_box[j]: index_list.append(j)#print(index_list)#枚举达到终止条件时的余数for i in range(31): #开始还原b1 b1=i for j in range(len(buf)): b1=b1*31+index_list[j]#不断加余数，乘31 tmp=str(bin(b1)[2:])#加密流程是把tmp从2进制转10进制，这里就反着来，把b1从10进制转2进制，截去前缀 tmp=tmp.zfill((len(tmp)//8+1)*8)#加密时字符转成8位2进制数，反着来就是把8位2进制数转为字符，所以先把tmp 8位对齐方便后续截取 flag='' for i in range(0,len(tmp),8): flag+=chr(int(tmp[i:i+8],2)) if 'NSSCTF' in flag: print(flag) #flag = &quot;NSSCTF{WHAt_BASe31}&quot; [SWPUCTF 2021 新生赛]非常简单的逻辑题 题目给的代码如下： 123456789flag = 'xxxxxxxxxxxxxxxxxxxxx's = 'wesyvbniazxchjko1973652048@$+-&amp;*&lt;&gt;'result = ''for i in range(len(flag)): s1 = ord(flag[i])//17 s2 = ord(flag[i])%17 result += s[(s1+i)%34]+s[-(s2+i+1)%34]print(result)# result = 'v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i' 加密思路是：逐字符取flag，通过//和%操作得到两个值s1和s2，把这两个值处理后，作为索引在s中索引出字符，拼接得到result 逆着来应该是把result错位分开，分成和s1有关的与和s2有关的，然后求出索引值，逆两个取余过程得到s1和s2，再把s1和s2运算得到flag字符 很显然，这个过程十分复杂，因为涉及取模的还原 所以考虑顺着加密的思路走，从常见的字符十进制值枚举，遇到加密后结果和result一样的就拿来拼接flag EXP: 123456789101112131415161718192021222324s = 'wesyvbniazxchjko1973652048@$+-&amp;*&lt;&gt;'result = 'v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i'tmp=''flag=''#提取出result里和s1、s2相关的字符s1_list=[]s2_list=[]for i in range(0,len(result),2): s1_list.append(result[i]) s2_list.append(result[i+1])#开始爆破#先求出加密过程两个索引值for i in range(len(s1_list)): index1=s.index(s1_list[i]) index2=s.index(s2_list[i]) #以索引值为判断条件，在常见字符的范围内重现加密过程，加密结果和索引值一致即为flag的字符 for j in range(33,126): s1=j//17 s2=j%17 if (s1 + i) % 34==index1 and -(s2 + i + 1) % 34==index2: flag+=chr(j) breakprint(flag)#flag = &quot;NSSCTF{Fake_RERE_QAQ}&quot;&quot; [SWPUCTF 2021 新生赛]re2 IDA打开，代码如下： 简单的字符处理，先判断字符是否在范围内，然后采用不同处理方式 直接正向利用代码，省点脑子。 EXP: 12345678910111213alpha='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890{}-_'dic={}str='ylqq]aycqyp{'flag=''for i in alpha: if (ord(i)&lt;=96 or ord(i)&gt;98) and (ord(i)&lt;=64 or ord(i)&gt;66): dic[chr(ord(i)-2)]=i else: dic[chr(ord(i)+24)]=ifor i in str: flag+=dic[i]print(flag)#flag = 'NSSCTF{nss_caesar}' 直接得出来的结果是{nss_c{es{r}，显然不对，猜测对应关系不唯一。打印出alpha经过处理后的结果，发现’{‘和’a’都对应’y’，所以把显然不对劲的两个’ { ‘改成’ a ‘ [WUSTCTF 2020]level1 附件给了ELF文件和一个txt，反汇编代码如下： 逻辑就是从flag文件里读数据，然后存到ptr里。后面是简单的可逆处理，但是要注意ptr是从下标1开始用的。给的txt应该就是处理后的结果，把它转成一个列表，第一位随便填一个数。然后逆。 EXP: 123456789output=[0, 198, 232, 816, 200, 1536, 300, 6144, 984, 51200, 570, 92160, 1200, 565248, 756, 1474560, 800, 6291456, 1782, 65536000]flag=''for i in range(1,len(output)): if (i&amp;1)!=0: flag+=chr(output[i]&gt;&gt;i) else: flag+=chr(output[i]//i)print(flag)#flag = 'NSSCTF{d9-dE6-20c}'（改了前缀） [SWPUCTF 2021 新生赛]简简单单的解密 给的python代码如下： 12345678910111213141516171819202122232425import base64,urllib.parsekey = &quot;HereIsFlagggg&quot;flag = &quot;xxxxxxxxxxxxxxxxxxx&quot;s_box = list(range(256))j = 0for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i]res = []i = j = 0for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k))cipher = &quot;&quot;.join(res)crypt = (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))enc = str(base64.b64decode(crypt),'utf-8')enc = urllib.parse.quote(enc)print(enc)# enc = %C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA 采用的加密算法是标准RC4，加密两遍恢复明文。最后面的调用base的两行经过调试发现相互抵消，所以整个逻辑就是先RC4加密，然后用urllib.parse.quote()方法编码，编码部分用原库自带的urllib.parse.unquote()就行了 EXP: 12345678910111213141516171819202122232425262728293031import urllib.parseenc = '%C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA'buf=urllib.parse.unquote(enc)result=[]for i in buf: result.append(i)key = &quot;HereIsFlagggg&quot;flag = ''def RC4(flag): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) cipher = &quot;&quot;.join(res) return cipherflag+=RC4(result)print(flag)# flag = 'NSSCTF{REAL_EZ_RC4}' [LitCTF 2023]ez_XOR IDA打开，如图 用XOR函数对输入做处理后，与str比较。打开XOR： 功能就是遍历字符，异或处理，再异或一遍就可以了 EXP: 123456str='E`}J]OrQF[V8zV:hzpV}fVF[t'flag=''for i in range(len(str)): flag+=chr(ord(str[i])^9)print(flag)# flag = 'NSSCTF{XOR_1s_3asy_to_OR}'(前缀做了改动) [HUBUCTF 2022 新生赛]simple_RE IDA打开，如图 加密函数看起来逻辑很复杂，但是点开名字很奇怪的数组，发现一个编码表，可以推测是base64编码。 回过头看给的用来比较的字符串，基本可以确定是base64换表编码 找到了一个可以自定义编码表的python库cusbase64，可以用config指定编码表，这样就容易多了 EXP: 1234567import cusbase64table='qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD'enc='5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8=='b=cusbase64.CusBase64()b.config(table)b.decode(enc)#flag = 'NSSCTF{a8d4347722800e72e34e1aba3fe914ae}' [NSSCTF 2022 Spring Recruit]easy C 题目给的是c源文件，如下： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){ char a[]=&quot;wwwwwww&quot;; char b[]=&quot;d`vxbQd&quot;; //try to find out the flag printf(&quot;please input flag:&quot;); scanf(&quot; %s&quot;,&amp;a); if(strlen(a)!=7){ printf(&quot;NoNoNo\\n&quot;); system(&quot;pause&quot;); return 0; } for(int i=0;i&lt;7;i++){ a[i]++; a[i]=a[i]^2; } if(!strcmp(a,b)){ printf(&quot;good!\\n&quot;); system(&quot;pause&quot;); return 0; } printf(&quot;NoNoNo\\n&quot;); system(&quot;pause&quot;); return 0; //flag 记得包上 NSSCTF{} 再提交!!!} 分析逻辑，把输入的flag按字符先递增，再和2异或，得到的新数组应该和b一样。逆着来就是先异或再递减。 EXP： 123456str='d`vxbQd'flag=''for i in str: flag+=chr((ord(i)^2)-1)print(flag)#flag = 'NSSCTF{easy_Re}' [NSSCTF 2022 Spring Recruit]easy Python 题目给的py源码，如下： 12345678910111213141516171819202122232425262728293031import stringdef encode(string,string2): tmp_str = str() ret = str() bit_string_str = string.encode() remain = len( string ) % 3 remain_str = str() for char in bit_string_str: b_char = (bin(char)[2:]) b_char = '0'*(8-len(b_char)) + b_char tmp_str += b_char for i in range(len(tmp_str)//6): temp_nub = int(tmp_str[i*6:6*(i+1)],2) ret += string2[temp_nub] if remain==2: remain_str = tmp_str[-4:] + '0'*2 temp_nub = int(remain_str,2) ret += string2[temp_nub] + &quot;=&quot; elif remain==1: remain_str = tmp_str[-2:] + '0'*4 temp_nub = int(remain_str,2) ret += string2[temp_nub] + &quot;=&quot;*2 return ret.replace(&quot;=&quot;,&quot;&quot;)res = encode(input(),string.ascii_uppercase+string.ascii_lowercase+string.digits+'+/')if res == &quot;TlNTQ1RGe2Jhc2U2NCEhfQ&quot;: print(&quot;good!&quot;)else: print(&quot;bad!&quot;) 细细一看，encode()里面有加“=”的操作，并且使用的string2是字母大小写+数字+’+/‘，推测是base64，但是注意到encode()返回的时候把“=”替换成了“”，也就是删除了“==”，所以要把后面用于比较的也就是加密后的字符串加上“=” EXP: 12345import pybase64str='TlNTQ1RGe2Jhc2U2NCEhfQ=='flag=pybase64.b64decode(str)print(flag)#flag = 'NSSCTF{base64!!}' [SWPUCTF 2021 新生赛]fakerandom 依旧是Py源码： 12345678910111213import randomflag = 'xxxxxxxxxxxxxxxxxxxx'random.seed(1)l = []for i in range(4): l.append(random.getrandbits(8))result=[]for i in range(len(l)): random.seed(l[i]) for n in range(5): result.append(ord(flag[i*5+n])^random.getrandbits(8))print(result)# result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] 逻辑就是，用生成的伪随机数来异或flag的特定位。异或可逆，已知种子，伪随机数可以确定。所以只需要在源码的基础上稍作改动，把result和flag的位置调换一下就可以了 EXP： 12345678910111213import randomflag = ''result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244]random.seed(1)l = []for i in range(4): l.append(random.getrandbits(8))for i in range(len(l)): random.seed(l[i]) for n in range(5): flag+=chr(result[i*5+n]^random.getrandbits(8))print(flag)#flag = 'NSSCTF{FakeE_random}' [HNCTF 2022 Week1]X0r IDA打开，main函数如下： 可以看出，逻辑就是对输入的字符串按字符异或处理，最后与给定的arr比较 EXP： 123456arr=[0x000003FE, 0x000003EB, 0x000003EB, 0x000003FB, 0x000003E4, 0x000003F6, 0x000003D3, 0x000003D0, 0x00000388, 0x000003CA, 0x000003EF, 0x00000389, 0x000003CB, 0x000003EF, 0x000003CB, 0x00000388, 0x000003EF, 0x000003D5, 0x000003D9, 0x000003CB, 0x000003D1, 0x000003CD]flag=''for i in range(0,len(arr)): flag+=chr((arr[i]-900)^0x34)print(flag)flag = 'NSSCTF{x0r_1s_s0_easy}' [HGAME 2023 week1]easyenc IDA打开，main函数如图 可以看到逻辑就是先遍历出输入字符串的长度（ * ( ( _BYTE *) v9 + v4 )这样的格式可以看成：v9[v4]，算是一种经验吧）然后循环对输入的字符串按字符进行运算，最后与给定的数据比较。 难点在于，给的是10个元素的数组，而输入的字符串却要求是41个字符。看来V7的格式不是很对，要把这么多位的数据进行划分才行。v7是DWORD类型，而参与运算的v9用的是BYTE类型，1DWORD=4BYTE，要把v7的数分成4部分，这里的数据不好提取，可以直接丢给AI。当然手动复制也可以。 EXP： 12345678910111213buf=[0x9FDFF04,0xB0F301,0xADF00500,0x5170607,0x17FD17EB,0x1EE01EA,0xFA05B1EA,0xAC170108,0xFDEA01EC,0x60705F0]flag=''buf1 = []for num in buf: bytes_data = num.to_bytes(4, byteorder='little') for byte in bytes_data: buf1.append(hex(byte))#print(buf1)for num in buf1: tmp=((int(num,16)+86)^0x32)&amp;0xff flag+=chr(tmp)print(flag)#flag = 'NSSCTF{4ddit1on_is_a_rever5ible_0peration}'（修改了前缀） 当然得多学一点，所以手搓v7，找DS问一下怎么处理数据，得到如上的方法。 用to_bytes把v7的数转成字节形式，byteorder指定了小端序，然后hex转换成十六进制数存入新列表。至于为什么要转成十六进制数，和下面的代码有关。 然后用新列表的元素进行逆运算。因为直接使用这些元素会被判成字符，所以前面先转成十六进制数，再用int转成十进制数，这样就可以正常运算了 最后还要&amp;0xff，因为逆出来的数据有点超出ascii码范围了 还有就是，这样得出来的flag其实缺了一个“ } ”。回头看反编译的代码，那个未命名的用来输入v9的实际上不是纯粹的scanf那样的函数。里面有个FILE指针，推测是读文件的函数。所以读取的内容结尾按道理会有’\\0’。但是，加上了’\\0’算出来的flag也没有’ } ‘。所以，凭常识加上’ } ‘。","link":"/2025/06/02/Re-%E4%BB%8E0%E5%88%B01%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8B%E8%B7%AF/"},{"title":"week27-week30","text":"2025年9月篇 week27 (2025.9.1-2025.9.7) 接下来打算把周记分成四周一篇了，每周照样更新，但是四周一篇文章 这周（其实是上周，这段是补的）把博客主题给换了。原先想着先配置完，到时候直接把文章移到新的博客文件里，但是进度太慢了。这周直接给原博客换皮😋还更了一篇博客,真好😋(虽然还是AI出力) moe week4上新题了,但是week3甚至week2还有没写完的题 安卓这块的笔记还没更,开学了找找时间补上 week28 (2025.9.8-2025.9.14) 好的手忙脚乱的开学第一周，目前学习计划有待更新。","link":"/2025/09/08/week27-week30/"},{"title":"icarus主题优化","text":"icarus主题复制功能重构（仿照next主题）、firebase统计阅读人数 复制功能重构 icarus主题自带的复制功能是带文字选中的（如下图），个人感觉麻烦了点，于是考虑借鉴next的复制风格，一键复制 实现： hexo-theme-icarus/source/js/main.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 if (clipboard) {- new ClipboardJS('.highlight .copy', {- target: function(trigger) {- return trigger.parentNode.nextElementSibling;- }- }).on('success', function(e) {- e.clearSelection();- const tmp = e.trigger.innerHTML;- e.trigger.innerHTML = '&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt;';- setTimeout(function() {- e.trigger.innerHTML = tmp;- }, 2000);- });+ $('figure.highlight').each(function() {+ const target = $(this).find('figcaption div.level-right')[0];+ if (target) {+ registerCopyButton(target, this);+ }+ }); } ----------------------------------------------------------------------------------... $('.article &gt; .content &gt; table').each(function() { if ($(this).width() &gt; $(this).parent().width()) { $(this).wrap('&lt;div class=&quot;table-overflow&quot;&gt;&lt;/div&gt;'); } });+ // 注册复制按钮功能，仿照Next主题实现+ function registerCopyButton(target, element) {+ // 添加复制按钮+ target.insertAdjacentHTML('beforeend', '&lt;a href=&quot;javascript:;&quot; class=&quot;copy&quot; title=&quot;Copy&quot;&gt;&lt;i class=&quot;fas fa-copy&quot;&gt;&lt;/i&gt;&lt;/a&gt;');+ const button = target.querySelector('.copy');+ + button.addEventListener('click', function() {+ const code = element.querySelector('.code').innerText;+ + if (navigator.clipboard) {+ // 使用现代的Clipboard API+ navigator.clipboard.writeText(code).then(function() {+ button.querySelector('i').className = 'fas fa-check-circle';+ }, function() {+ button.querySelector('i').className = 'fas fa-times-circle';+ });+ } else {+ // 兼容性回退方案+ const ta = document.createElement('textarea');+ ta.style.top = window.scrollY + 'px';+ ta.style.position = 'absolute';+ ta.style.opacity = '0';+ ta.readOnly = true;+ ta.value = code;+ document.body.append(ta);+ ta.select();+ ta.setSelectionRange(0, code.length);+ ta.readOnly = false;+ const result = document.execCommand('copy');+ button.querySelector('i').className = result ? 'fas fa-check-circle' : 'fas fa-times-circle';+ ta.blur();+ button.blur();+ document.body.removeChild(ta);+ }+ });+ + // 鼠标离开300ms后恢复复制图标+ element.addEventListener('mouseleave', function() {+ setTimeout(function() {+ const icon = button.querySelector('i');+ if (icon) {+ icon.className = 'fas fa-copy';+ }+ }, 300);+ });+ } function adjustNavbar() { const navbarWidth = $('.navbar-main .navbar-start').outerWidth() + $('.navbar-main .navbar-end').outerWidth(); if ($(document).outerWidth() &lt; navbarWidth) { $('.navbar-main .navbar-menu').addClass('justify-content-start'); } else { $('.navbar-main .navbar-menu').removeClass('justify-content-start'); } } hexo-theme-icarus/layout/common/scripts.jsx 12345678910 return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt; &lt;script data-pjax src={url_for('/js/column.js')}&gt;&lt;/script&gt; &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt;- {clipboard &amp;&amp; &lt;script src={cdn('clipboard', '2.0.4', 'dist/clipboard.min.js')} defer&gt;&lt;/script&gt;} &lt;script data-pjax src={url_for('/js/main.js')} defer&gt;&lt;/script&gt; &lt;/Fragment&gt;; 使用firebase统计阅读人数config文件添加配置_config.icarus.yml 1234567+# Firebase Firestore 阅读人数统计+services:+ firebase:+ enable: true+ collection: articles # Firestore数据库中的集合名称+ apiKey: # 你的Firebase API Key+ projectId: # 你的Firebase项目ID 文章head增加人数统计hexo-theme-icarus/layout/common/articles.jsx 123456789 {/* Visitor counter */} {!index &amp;&amp; plugins &amp;&amp; plugins.busuanzi === true ? &lt;span class=&quot;level-item&quot; id=&quot;busuanzi_container_page_pv&quot; dangerouslySetInnerHTML={{ __html: _p('plugin.visit_count', '&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt;') }}&gt;&lt;/span&gt; : null}+ {/* Firebase Visitor counter */}+ {config.services &amp;&amp; config.services.firebase &amp;&amp; config.services.firebase.enable ? &lt;span class=&quot;level-item&quot;&gt;+ &lt;i class=&quot;far fa-eye mr-1&quot;&gt;&lt;/i&gt;+ &lt;span class=&quot;firestore-visitors-count&quot;&gt;0&lt;/span&gt;+ &lt;/span&gt; : null} 基于firebase的统计功能实现source/js/firebase_counter.js（新建） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187+/* global IcarusThemeSettings, firebase */++// Firebase Counter - 阅读量统计功能++if (IcarusThemeSettings &amp;&amp; IcarusThemeSettings.services &amp;&amp; IcarusThemeSettings.services.firebase &amp;&amp; IcarusThemeSettings.services.firebase.enable) {+ + // 初始化Firebase+ try {+ // 确保firebase对象存在+ if (typeof firebase === 'undefined') {+ console.error('Firebase library not loaded');+ // 如果Firebase库未加载，隐藏计数器元素+ document.querySelectorAll('.firestore-visitors-count').forEach(el =&gt; {+ el.style.display = 'none';+ });+ } else {+ + firebase.initializeApp({+ apiKey: IcarusThemeSettings.services.firebase.apiKey,+ projectId: IcarusThemeSettings.services.firebase.projectId+ });+ + // 开发环境检测+ const isLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname);+ const isDevelopment = isLocalhost || window.location.hostname.includes('192.168.');+ + // 移除所有调试日志输出+ + // 获取数据库引用+ const db = firebase.firestore();+ const articlesCollection = IcarusThemeSettings.services.firebase.collection || 'articles';+ const articles = db.collection(articlesCollection);+ + // 获取阅读次数函数+ const getCount = (doc, increaseCount) =&gt; {+ // 获取文档数据+ return doc.get().then(d =&gt; {+ // 初始化计数+ let count = d.exists ? d.data().count : 0;+ + // 如果需要增加计数（只在文章页面且未在同一会话访问过）+ if (increaseCount) {+ // 增加计数+ count++;+ return doc.set({ count }).then(() =&gt; {+ if (isDevelopment) console.log('计数已更新:', count);+ return count;+ }).catch(error =&gt; {+ console.error('Error updating count:', error);+ return count; // 返回增加前的计数+ });+ }+ + return count;+ }).catch(error =&gt; {+ console.error('Error getting count:', error);+ // 出错时返回默认值0+ return 0;+ });+ };++ // 处理阅读计数的函数+ const handleViewCount = () =&gt; {+ // 获取当前URL路径+ const currentPath = window.location.pathname;+ + // 增强首页识别：使用多个可能的选择器+ const isIndexPage = document.querySelector('.article-list') !== null ||+ document.querySelector('.article-card-list') !== null ||+ document.querySelectorAll('.article-card').length &gt; 0 || // 降低阈值以适应首页+ (currentPath === '/' &amp;&amp; document.querySelector('article.article') !== null); // 特殊处理：根路径+article.article元素+ + // 增强文章页面识别：使用更精确的选择器组合+ // 重要：首页优先判断，且文章页判断要排除首页的情况，并增加特定的文章页特征+ const isArticlePage = !isIndexPage &amp;&amp; (+ // 传统文章页选择器+ (document.querySelector('.article-container') !== null &amp;&amp; document.querySelector('.article-content') !== null) ||+ (document.querySelector('article.post') !== null &amp;&amp; document.querySelector('.article-content') !== null) ||+ document.querySelector('[id=&quot;post-content&quot;]') !== null ||+ // 针对hexo s环境的增强选择器，但需要确保不是首页+ (document.querySelector('article.article') !== null &amp;&amp; + document.querySelector('article.card-content.article') !== null &amp;&amp;+ document.querySelectorAll('.article-card').length === 0 &amp;&amp;+ currentPath !== '/')+ );+ + // 页面类型信息 - 仅在开发环境显示+ if (isDevelopment) {+ console.log(`[Firebase] 当前页面类型: ${isArticlePage ? '文章页' : isIndexPage ? '首页' : '其他页面'}`);+ }++ if (isArticlePage) {+ // 文章页面处理+ const titleElement = document.querySelector('.title.is-3, .title.is-4-mobile');+ const countElement = document.querySelector('.firestore-visitors-count');+ + if (titleElement &amp;&amp; countElement) {+ const title = titleElement.textContent.trim();+ const doc = articles.doc(title);+ + // 确定是否增加计数：不在本地开发环境且同一会话未访问过+ let increaseCount = !isDevelopment;+ + if (sessionStorage.getItem(title)) {+ increaseCount = false;+ } else {+ // 标记为在当前会话中已访问+ sessionStorage.setItem(title, true);+ }+ + getCount(doc, increaseCount).then(count =&gt; {+ countElement.innerText = count;+ }).catch(e =&gt; {+ // 移除错误日志+ });+ } else {+ // 静默处理：未找到文章标题或计数元素+ }+ } else if (isIndexPage) {+ // 首页文章列表处理+ // 修改选择器以匹配实际HTML结构+ // 首页文章结构: .card &gt; .card-content.article &gt; .title.is-3.is-size-4-mobile+ const titleElements = document.querySelectorAll(+ '.card .article .title.is-3, .card .article .title.is-4-mobile, ' ++ '.card article .title.is-3, .card article .title.is-4-mobile, ' ++ '.card .article p.title, .card article p.title'+ );+ const countElements = document.querySelectorAll('.card .article .firestore-visitors-count, .card article .firestore-visitors-count');+ + // 移除首页元素检测日志+ + if (titleElements.length &gt; 0 &amp;&amp; countElements.length &gt; 0) {+ const promises = [...titleElements].map(element =&gt; {+ const title = element.textContent.trim();+ const doc = articles.doc(title);+ // 首页只获取计数，不增加计数+ return getCount(doc, false).then(count =&gt; {+ return count;+ });+ });+ + Promise.all(promises).then(counts =&gt; {+ counts.forEach((val, idx) =&gt; {+ if (countElements[idx]) {+ countElements[idx].innerText = val;+ }+ });+ }).catch(e =&gt; {+ // 错误处理：尝试显示一些默认值或替代文本+ countElements.forEach(el =&gt; {+ if (el.innerText === '0') {+ el.innerText = '加载中...';+ }+ });+ });+ } else {+ // 尝试使用更通用的选择器+ const fallbackTitleElements = document.querySelectorAll('.article-card a[href^=&quot;/&quot;]');+ const fallbackCountElements = document.querySelectorAll('.article-card .firestore-visitors-count');+ + if (fallbackTitleElements.length &gt; 0 &amp;&amp; fallbackCountElements.length &gt; 0) {+ // 这里可以添加备选逻辑+ }+ }+ } else {+ // 静默处理：当前页面既不是文章页也不是首页+ }+ };+++ // 监听传统页面加载完成事件+ document.addEventListener('DOMContentLoaded', () =&gt; {+ handleViewCount();+ });+ + // 监听PJAX页面加载完成事件（适配Icarus主题的PJAX机制）+ document.addEventListener('page:loaded', () =&gt; {+ handleViewCount();+ });+ }+ } catch (error) {+ // 移除初始化失败日志+ // 如果初始化失败，尝试隐藏计数器元素以避免显示为0+ document.querySelectorAll('.firestore-visitors-count').forEach(el =&gt; {+ el.style.display = 'none';+ });+ }+} 其他一些优化hexo-theme-icarus/layout/common/scripts.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const { Component, Fragment } = require('inferno');const { toMomentLocale } = require('hexo/dist/plugins/helper/date');const Plugins = require('./plugins');module.exports = class extends Component { render() { const { site, config, helper, page } = this.props; const { url_for, cdn } = helper; const { article } = config; const language = toMomentLocale(page.lang || page.language || config.language || 'en'); let fold = 'unfolded'; let clipboard = true; if (article &amp;&amp; article.highlight) { if (typeof article.highlight.clipboard !== 'undefined') { clipboard = !!article.highlight.clipboard; } if (typeof article.highlight.fold === 'string') { fold = article.highlight.fold; } } const embeddedConfig = `var IcarusThemeSettings = { article: { highlight: { clipboard: ${clipboard}, fold: '${fold}' }+ },+ services: {+ firebase: ${config.services &amp;&amp; config.services.firebase ? JSON.stringify(config.services.firebase) : 'false'} } };`; return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt;+ {/* Firebase Firestore */}+ {config.services &amp;&amp; config.services.firebase &amp;&amp; config.services.firebase.enable ? (+ &lt;Fragment&gt;+ &lt;script src=&quot;https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js&quot;&gt;&lt;/script&gt;+ &lt;script src=&quot;https://www.gstatic.com/firebasejs/9.6.11/firebase-firestore-compat.js&quot;&gt;&lt;/script&gt;+ &lt;/Fragment&gt;+ ) : null} &lt;script data-pjax src={url_for('/js/column.js')}&gt;&lt;/script&gt; &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt; &lt;script data-pjax src={url_for('/js/main.js')} defer&gt;&lt;/script&gt;+ {/* Firebase counter script */}+ {config.services &amp;&amp; config.services.firebase &amp;&amp; config.services.firebase.enable ? (+ &lt;script data-pjax src={url_for('/js/firebase_counter.js')} defer&gt;&lt;/script&gt;+ ) : null} &lt;/Fragment&gt;; }};","link":"/2025/09/02/icarus%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"},{"title":"Day5:函数调用约定","text":"函数调用约定 函数调用约定 主要有三种：cdecl、stdcall、fastcall。以求和函数为例 12345678910//求和#include&lt;stdio.h&gt;int sum(int a,int b,int c){ return a+b+c;}int main(){ int res=sum(1,2,3); printf(&quot;%d\\n&quot;,res); return 0;} cdecl：完全栈传参，参数从右往左入栈，由调用者清理参数占用的栈空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283; int __cdecl main()_main proc near ; CODE XREF: j__main↑j var_C = byte ptr -0Chres = dword ptr -8 push ebp mov ebp, esp sub esp, 0CCh push ebx push esi push edi __$EncStackInitStart_2: lea edi, [ebp+var_C] mov ecx, 3 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd_2: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop push 3 ; 参数c入栈 push 2 ; 参数b入栈 push 1 ; 参数a入栈 call j_?sum@@YAHHHH@Z ; sum(int,int,int) add esp, 0Ch ;这里调用者进行了清理参数占用的栈空间的操作(3个参数×4字节)，被调用者不负责 mov [ebp+res], eax mov eax, [ebp+res] push eax push offset _Format ; &quot;%d\\n&quot; call j__printf add esp, 8 xor eax, eax pop edi pop esi pop ebx add esp, 0CCh cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn_main endp; int __cdecl sum(int a, int b, int c)?sum@@YAHHHH@Z proc near ; CODE XREF: sum(int,int,int)↑j a = dword ptr 8b = dword ptr 0Chc = dword ptr 10h push ebp mov ebp, esp sub esp, 0C0h ;sum函数自身的栈空间 push ebx push esi push edi __$EncStackInitStart: mov edi, ebp xor ecx, ecx mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop mov eax, [ebp+a] add eax, [ebp+b] add eax, [ebp+c] pop edi pop esi pop ebx add esp, 0C0h ;清理自身栈空间 cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn?sum@@YAHHHH@Z endp stdcall：完全栈传参，参数从右往左入栈，由被调用者清理参数占用的栈空间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182; int __cdecl main()_main proc near ; CODE XREF: j__main↑j var_C = byte ptr -0Chres = dword ptr -8 push ebp mov ebp, esp sub esp, 0CCh push ebx push esi push edi __$EncStackInitStart_2: lea edi, [ebp+var_C] mov ecx, 3 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd_2: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop push 3 ; 参数c入栈 push 2 ; 参数b入栈 push 1 ; 参数a入栈 call j_?sum@@YGHHHH@Z ; sum(int,int,int) mov [ebp+res], eax ;这里直接到把返回值给res了，调用者不负责清理参数占用的栈空间 mov eax, [ebp+res] push eax push offset _Format ; &quot;%d\\n&quot; call j__printf add esp, 8 xor eax, eax pop edi pop esi pop ebx add esp, 0CCh cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn_main endp ; int __stdcall sum(int a, int b, int c)?sum@@YGHHHH@Z proc near ; CODE XREF: sum(int,int,int)↑j a = dword ptr 8b = dword ptr 0Chc = dword ptr 10h push ebp mov ebp, esp sub esp, 0C0h ;sum的栈空间 push ebx push esi push edi __$EncStackInitStart: mov edi, ebp xor ecx, ecx mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop mov eax, [ebp+a] add eax, [ebp+b] add eax, [ebp+c] pop edi pop esi pop ebx add esp, 0C0h ;清理自身栈空间 cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn 0Ch ;被调用者通过返回指令给esp增加0Ch，清理参数占用的栈空间?sum@@YGHHHH@Z endp fastcall：寄存器+栈传参，优先使用寄存器，剩余参数从右往左入栈，由被调用者清理参数占用的栈空间 寄存器传参优先级： x86：ecx edx 栈 x64：rcx rdx r8 r9 栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687; int __cdecl main()_main proc near ; CODE XREF: j__main↑j var_C = byte ptr -0Chres = dword ptr -8 push ebp mov ebp, esp sub esp, 0CCh push ebx push esi push edi __$EncStackInitStart_2: lea edi, [ebp+var_C] mov ecx, 3 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd_2: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop push 3 ; 参数c入栈 mov edx, 2 ; 参数b存入寄存器 mov ecx, 1 ; 参数a存入寄存器 call j_?sum@@YIHHHH@Z ; sum(int,int,int) mov [ebp+res], eax ;这里也是没有调用者对参数占用的栈空间的清理 mov eax, [ebp+res] push eax push offset _Format ; &quot;%d\\n&quot; call j__printf add esp, 8 xor eax, eax pop edi pop esi pop ebx add esp, 0CCh cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn_main endp; int __fastcall sum(int a, int b, int c)?sum@@YIHHHH@Z proc near ; CODE XREF: sum(int,int,int)↑j var_18 = byte ptr -18hb = dword ptr -14ha = dword ptr -8c = dword ptr 8 push ebp mov ebp, esp sub esp, 0D8h ;sum开辟栈空间 push ebx push esi push edi push ecx __$EncStackInitStart: lea edi, [ebp+var_18] mov ecx, 6 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd: pop ecx mov [ebp+b], edx mov [ebp+a], ecx mov ecx, offset _6005466B_entry@cpp ; JMC_flag call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop mov eax, [ebp+a] add eax, [ebp+b] add eax, [ebp+c] pop edi pop esi pop ebx add esp, 0D8h ;sum清理栈空间 cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn 4 ;由于只有一个参数被push到栈上，所以被调用者返回4，清理参数占用的栈空间?sum@@YIHHHH@Z endp","link":"/2025/07/12/Day5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"},{"title":"周记","text":"简单记录每周收获 week1 (2025.3.4-2025.3.9) 看到群友讲到周报，灵光一闪觉得可以写写周记来记录自己的学习，也当作一种督促 这周主要学习李承远老师的《逆向工程核心原理》（去年12月图书馆借的，这周才正式开始看😓） 主要学习了动态调试的基础技能。有： 调试器的基础操作，查找目标代码的方法（干找，字符串检索，下断点，API检索及下断点） 打补丁patch修改输出的字符串（直接修改或者导向修改的NULL填充区域）并导出新的可执行文件 字节序、寄存器基础 栈、栈帧 函数调用约定（cdecl（调用者处理栈）、stdcall（被调用者处理栈）、fastcall（同stdcall，但是结合了栈和寄存器）） week2 (2025.3.10-2025.3.16) 这周主要学习了PE文件结构的内容，同步更新了学习笔记 ，主要是PE文件的基本组成介绍，理论知识 周末本想接着下一章的学习，但是摆大烂了，甚至PE笔记还没写完 下周末就是NCTF了，一点准备没有，要炸掉了 week3 (2025.3.17-2025.3.23) 这周过得又忙又不知道在忙什么，PE文件结构最后的EAT部分没看懂，(T_T)，笔记还没补完 NCTF爆零了，编码能力是硬伤，知识更是伤上加伤 (T_T) 好了，真是糟糕的一周 week4 (2025.3.24-2025.3.30) offline一周 week5 (2025.3.31-2025.4.6) 想了想，发现自己一直存在一个错误，就是为了笔记而做笔记，纯粹的是记录；但是好像以总结或者说复述的方式来做笔记才比较有用 这周碰上清明了，有个三天假。虽然但是，依旧是没怎么学新东西 但是至少是做了点什么。周日把PE文件格式收尾了（还是有点难度的，因为回头看了前面做的笔记，发现对IAT和EAT的认识有点不对劲，重新梳理了一遍，删删改改）。学聪明了，这次是看完书完整地把例子先走了一遍再做的笔记 这周在咸鱼2元淘到了一包课，后面发现里面有一套课体系挺完整的，也是有课跟了 还有就是尝试了自己写python解密脚本，发现没体系学过一遍真不能硬上 week6 (2025.4.7-2025.4.13) 这周找了个短一些的python视频，跟着过了一遍，然后试着做题写脚本，您猜怎么着，还是不太会🤡 解密实在是太吃操作了，细细一想，好像解密这玩意更吃数学，一个取模逆向DS直接上公式，我还在循环爆破被除数🤡 不得不拿出四字真言：菜就多练。所以，这周就试着刷题来了 节奏还是慢了点，唉 week7 (2025.4.14-2025.4.20) emmm怎么说，这周前面几天倒是抽时间刷题了，但是一到周末，明显感到懒了 周三花了一个下午搞明白重定位表，笔记写了，但是切入点好像不是很对。这次的笔记，因为参考了DS给的辅助讲解，所以跟前面的有点不一样。感觉用形象的例子来类比以及从设计者角度描述细节，更有利于后期复习再理解 还是感觉效率上不来🤔，我在想要不然先跟课走，不懂的地方再看书，会不会学的清楚一点，省的老啃一处 本来打算周末来个脱壳练习的，鸽了（；´д｀）ゞ week8 (2025.4.21-2025.4.27) 这几天图床崩了，图片上传不了，之前的图在博客里也有点显示不出来，找了好久没找到问题在哪里，只能传到本地和其他文件一起打包传github了 五一调休使我本就短暂的周末更加短暂（虽然目前为止周末还没有被我真正利用过），这周拿得出手的就只是一道题目 em…实际上这周花了不少时间搞脱壳练习的环境。买的课里头老师说用vs2008练习，但是该死的虚拟机没联网得自己安装netframework，这就花了不少时间，以及灵机一动把环境搭在win11上了，这又花了一点时间。还有一点时间尝试用自己写的程序加壳脱壳，但是没折腾成功。 还有，我有点怀疑这个老师的成分了，一口一个抛砖引玉，一口一个自己看（我要是自己会学还看课干什么）🫠。但是找不到比他的课更完整的win逆向资源了😔 week9 (2025.4.28-2025.5.4) 这周碰上了实验周和五一假期，看似空闲时间很多，但实际上并非如此（借口 CS啊，三天速通数学实验，还要写老厚一本的实验报告，甚至报告还包括两篇论文，离谱了🫠 好的，看来这周依旧是没什么学习收获的一周。除了单开了一个IDApro的学习笔记（四处碰壁只能学学工具的使用了） week10 (2025.5.5-2025.5.11) 这周折腾电装实习和数学实验，还要复习大物和高数，忙死了，唉 week11 (2025.5.12-2025.5.18) 诶，浅摆一周 week12 (2025.5.19-2025.5.25) 快期末月了啊，哎呀，一学期又要过去了 开始有点考试前的紧张感了，这周主要拿来搞学业了，大物、高数、电工模电还有六级多手抓🙃 诶，但是优化了一下博客的界面，折腾了快有三天时间。主要就是给主页改成了分类卡片，下一级才是文章，这样子结构更清晰一点。还有一些小地方的美化，以及阅读次数统计的问题（从leancloud国内版到不蒜子到leancloud国际版又回到leancloud国内版…哇，看来我和DS老师的协调能力还不是很好，毕竟光这一项就要了差不多1天时间🙃头都大了） 本来打算周末把没跟上的课业补上，但是优化博客就占了周六一个上午，周六一个下午搞那个C++慕课（不当人啊，题目让直接复制的输出实现代码和输出要求一模两样），但是我还有高数大物特别是模电和六级以及还有个电装实习报告和物理实验报告，压力都给到周日，可想而知 还有一件事，这周逮空看了看hello算法（就是这个：https://www.hello-algo.com/chapter_hello_algo/ ，上学期囤下来的资源）最近刚好买的课里头讲C和C++的时候提到了数据结构，但是实在找不到时间看视频，就只能看看书了。哇，U1S1是真优质资料啊。回头看看再加一个数据结构与算法的分类，反正下学期好像也要学了 其实还有点事情，写这个博客的初心其实不是什么记录收获，而是因为我没有找到可以学习效仿的对象，看大佬的博客都是更新知识，很少有人提到为什么会想到去学这些知识，就是，没人会告诉你下一步该干什么，知识那么多却又找不到学习的方向，就是这种感觉。所以想记录记录自己的学习经历，方便梳理学习路线，也希望多少可以给将来像我一样迷茫的人一些指引。 其实开始学习的时候，我会时不时去看看同级的大佬的博客，看到他们更新的都是我没有听说过的知识，看着他们变得越来越专业越来越厉害，长久下来心里很不是滋味。高中时候那种无力感就又出现了。后来我就隐约觉得不对劲，这不就把大学又过成高中了吗？“比较的终点是自卑，专注的终点是自由”，想想当初想学信安不就是因为喜欢吗（虽然那时候确实不知道具体得学什么），为什么要和别人比呢？高中的时候我总是刻意不融入比较的氛围，而现在没有了那样厚重的学习环境，我却不自觉开始比较起来了，唉😔所以这些天其实一直在调整自己的心态，好在现在我感觉慢慢地不再频繁站在外界去审视自己了，开始觉得每天能看见阳光、能够在晚自习上下课的路上边听歌边走路、能够实现引体向上拉0个到拉6个（尽管是在有弹力带辅助的情况下、能够在社团的宣讲活动上承担一部分发言的责任……这些都让我的生活变得越来越美好。这可能就是知足常乐的感觉吧，反正活得更开心了，也更有行动的能量了，也挺好 今天的字数有点超标了哈哈😄但是不管了 接下来一个月多不知道会不会还有机会更新点知识笔记，但是希望暑假可以好好学学吧（求求我自己了 既然提到了学习路线，要不然这里梳理一段吧，其实有些东西没记上来。刚开始是从《逆向工程核心原理》开始学的，但是学了快一个月感觉效率也不行啊，后面开始找课，找到了一个全路线的课（目录里是包含了渗透测试和逆向免杀的）但是感觉逆向那部分老师有点混啊，上课就展示笔记 ，说话也含含糊糊的，还时不时来句主要是抛砖引玉，就感觉这样下来也学得迷迷糊糊的，所以又去找新的课。现在是找到了另外两套，一套是windows内核安全，一套是红队免杀（两套课同一家机构的，jayx），这个体系感觉也很清晰，老师讲课（至少看了几节课下来）倒也清楚，实践为主。所以现在确定下来是跟着最新的两套学。后面可能会考虑改改之前记的笔记。 啊对了，还得狡辩一下。我发现week2开始就不是记录收获了，像是报备干了什么😄其实也没什么写的，因为还在摸索。 week13 (2025.5.26-2025.6.1) 这周本来是试着把博客部署到vercel上方便国内访问的（DeepSeek说可以的），但是没折腾明白，所以本来没打算写什么的。结果，周日晚上11点多打开博客文件夹，发现有点不对劲，一访问，博客崩了😅 千错万错就不该错在什么都不懂还跟着DeepSeek走，哇，真的，难以描述这种感觉，光这篇周记就有77天了啊，😅 这段话其实是6.2写的，周日晚上修博客修到1点，尝试修复但是行不通😅 哇，这个人工智能，它教我用rm rf，虽然不是windows的指令，但是它能在教程里用上这样的指令，哇，真的，真是这个👍。我真的，哇，要无语死了 6.2就折腾一天的博客，把原来的博客废掉了，重构了一个。哇，一搜教程，和当初刚开始搞博客时看到的完全不一样了，下下来的NexT还是新版的，配置变了不是一点，哇😅 吃一堑长一智了，以后找教程不先搜别人写的直接问AI我就是这个👍 week14 (2025.6.2-2025.6.8) OK，这周主要任务就是重新搭了一个博客。博客建了半年了，都忘了怎么建起来的了，重搭去找教程，搜出来的结果和印象里半年前的还不一样，迭代速率真快啊 好在旧的博客没有全毁，在残存的next文件里找到了一些还能抄的配置 才半年NexT都更新到8.23了，评论系统和访客系统变了不少，老配置用不上只能换新的配置了 完了都没什么可以写的了 预计接下来几周就不会有什么内容了，马上就是期末周了。唉，大大小小的作业报告考试又来了🫠 week15,16,17 (2025.6.9-2025.6.29) 期末月断更 week18 (2025.6.30-2025.7.6) OK，也是考完试了。回家两天也是闲里偷忙地看了一点课 接下来看看能不能持续更个几十天，我已经“计划”好了一些要更的内容了，能不能更成就看我自己了（ week19 (2025.7.7-2025.7.13) 这周开始学习基础一点的知识，主要是汇编。下周应该是程序逆向基础的东西了。 笔记有点乱。这周主要围绕汇编，学习了不同架构不同模式下的汇编的基础知识，包括最基本的寄存器、汇编指令、函数的汇编形式、栈帧、不同架构模式的汇编差异等。整体而言其实不是很繁杂的东西，内容也不多，所以说其实这周还是处于想起来该学了的时候才学的状态。看了看其他的囤起来的资料，有一说一，开学后还真不一定可以有连续的时间学，这样子没有先起个体系感觉还是很难真正学懂。 week20 (2025.7.14-2025.7.20) 一言难尽属于是，总而言之这周没怎么集中精力去给第一部分的汇编学习收尾 还有结构体、类什么的还没有尝试，为了降低难度没有引入C++复杂的语法，但是总感觉哪里有点不对劲 这样下去不是很ok啊(ˉ▽ˉ；)… week21 (2025.7.21-2025.7.27) 摆烂一周🤪🤪 其实这一周我没写周记，甚至把它隐藏了。week22学了几天良心过不去又恢复文章了(～￣▽￣)～ week22 (2025.7.28-2025.8.3) 这周收获颇丰啊，脱壳这一块卡了半年多了应该有，也是终于走到逆向真正有魅力的地方了，脱壳、花指令、反调试都学上了，虽然偏理论，但是至少有点见识了 美中不足的是，代码编译着编译着突然冒出了一个调用约定冲突（x86环境）🫠花指令之前都没发现这个问题，真是奇了怪了🫠重装一遍VS甚至还是有这个问题 这周找校队师傅沟通了一下，好像参加考核得跟着新一轮招新时间线来，不然要有拿得出手的实力才可以打破人家的招新计划🫠🫠 week23 (2025.8.4-2025.8.10) 上周末开始想着给博客换个主题（这个主题感觉被我搞得有点老了），一如既往的遭罪啊🫠这周本来想找机会把要换的主题准备好，但是，一折腾就是半天🫠 x2c开始招新了，唉，还没准备好🫠 本来这周到OLLVM了，但是尝试后发现自己写的程序OLLVM没有效果，不知道是逻辑太简单还是IDA太强大了还是什么，另外解法还有牵扯到angr的，索性深的就往后延延了，先把知识面拓开，安卓还没看呢，py还有其它语言的逆向也没怎么接触过呢🫠 怎么感觉状态起起落落的😅 week24 (2025.8.11-2025.8.17) 这周开始赶进度，学了点安卓逆向基础，然后投了简历。也算是见识到了招新考核了。感谢师傅手下留情，也是终于被收留了🫡。 然后就是打moe，感觉比0xGame还上了点难度，第一周就有upx的题了，还有C++的。顺道打了LILCTF，做出了一题😋但是其他题没思路了（加上准备科目一🫠，就没往下做，后面再学学再复现😋 考虑到Win逆向还没更完，所以安卓这部分就没有写笔记了，回头再熟悉熟悉再补 week25 (2025.8.18-2025.8.24) moe上强度了，但是第二周的题还没写完 这周摆烂了 week26 (2025.8.25-2025.8.31) 这周主要还是研究moe的题，没有学什么新知识。","link":"/2025/06/02/%E5%91%A8%E8%AE%B0/"},{"title":"记一次blog优化","text":"Hexo+NexT博客的小优化 (注：此篇记录的是笔者原来崩溃的博客的优化，是旧版NexT优化) 这几天突然产生一个想法：博客主页改成分类的样式会不会更好看一点，主页是主题集合，每个主题里面才是相关的文章 心动不如行动，直接开干！ 首页分类卡片实现 这部分其实花了不少时间，因为没有具体学过Hexo+NexT的结构，好在有Deepseek老师的帮助 修改的部分主要在themes/next/layout/index.swig，下面直接贴代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162{% extends '_layout.swig' %}{% import '_macro/sidebar.swig' as sidebar_template with context %}{% block title %}{{ title }}{%- if theme.index_with_subtitle and subtitle %} - {{ subtitle }}{%- endif %}{% endblock %}{% block class %}index categories-page{% endblock %}{% block content %}{# 这部分是实现category卡片，最后面还有没category的文章的处理，因为我严格了每篇文章有category，就没管画面如何了 #}{% if site.categories.length &gt; 0 %} &lt;div class=&quot;category-cards-container&quot;&gt; {% for cat in site.categories.toArray() %} &lt;div class=&quot;category-card&quot;&gt; &lt;div class=&quot;category-header&quot;&gt; &lt;h2 class=&quot;category-name&quot;&gt;{{ cat.name }}&lt;/h2&gt; &lt;span class=&quot;post-count&quot;&gt;{{ cat.posts.length }}篇文章&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; {# 这一部分实现卡片显示包含的文章的标题，数量可以改下面的limit()的数字 #} &lt;div class=&quot;recent-posts-list&quot;&gt; {% for post in cat.posts.sort('date', -1).limit(3).toArray() %} &lt;div class=&quot;recent-post-item&quot;&gt; &lt;a href=&quot;{{ url_for(post.path) }}&quot; class=&quot;post-title&quot; title=&quot;{{ post.title }}&quot;&gt; {{ post.title | truncate(18) }} &lt;/a&gt; &lt;span class=&quot;post-date&quot;&gt; {% if post.updated %} {{ post.updated.format('MM/DD') }} {% else %} {{ post.date.format('MM/DD') }} {% endif %} &lt;/span&gt; &lt;/div&gt; {% endfor %} &lt;div class=&quot;more-posts-wrapper&quot;&gt; &lt;a href=&quot;{{ url_for('/categories/' + cat.name + '/') }}&quot; class=&quot;more-posts-button&quot;&gt; 更多文章 → &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; {% endfor %} &lt;/div&gt;{% else %} &lt;div class=&quot;no-categories-notice&quot;&gt; &lt;p&gt;暂无分类数据，请为文章添加分类&lt;/p&gt; &lt;/div&gt;{% endif %}{% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} 还有source/_data/styles.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/* 分类卡片样式 - 安全追加 */.category-cards-container { margin: 40px auto; max-width: 1200px; padding: 0 20px; .category-card { background: rgba(255,255,255,0.85); /* 半透明白色，与你的opacity 0.85协调 */ border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.1); margin-bottom: 25px; padding: 25px; transition: all 0.3s ease; backdrop-filter: blur(2px); /* 毛玻璃效果增强背景融合 */ border: 1px solid rgba(255,255,255,0.3); /* 柔和边框 */ &amp;:hover { transform: translateY(-5px); box-shadow: 0 5px 25px rgba(0,0,0,0.15); } .category-name { color: #2c3e50; font-size: 1.4em; margin: 0 0 8px 0; font-weight: 600; } .post-count { color: #7f8c8d; font-size: 0.9em; display: block; } }}/* 这部分是我自己用的背景图的设置 */body { background-image: url(/images/background.jpg); background-repeat: no-repeat; background-attachment: fixed; background-size: 100% 100%; opacity: 0.85;}/* ======================== *//* 分类卡片内的文章列表样式 *//* ======================== */.category-card { position: relative; /* 为毛玻璃效果提供定位上下文 */ .category-header { margin-bottom: 15px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.08); } .recent-posts-list { margin-top: 10px; .recent-post-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; transition: all 0.2s ease; &amp;:hover { transform: translateX(3px); } .post-title { color: #34495e; font-size: 0.95em; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; &amp;:hover { color: #3498db; text-decoration: underline; } } .post-date { color: #95a5a6; font-size: 0.8em; font-family: 'Arial', sans-serif; flex-shrink: 0; } } } * { border-bottom: none !important; box-shadow: none !important; } .category-header, .recent-post-item, .recent-posts-list { border: none !important; border-bottom: none !important; }}/* 更多文章按钮样式 */.more-posts-wrapper { text-align: left; margin-top: 12px; padding-top: 10px; .more-posts-button { display: inline-block; color:rgb(72, 168, 241); font-size: 0.9em; padding: 6px 12px; border-radius: 4px; transition: all 0.3s ease; background: rgba(52, 152, 219, 0.1); &amp;:hover { background: rgba(52, 152, 219, 0.2); transform: translateX(3px); } &amp;:hover::after { margin-left: 8px; } }}/* 响应式调整 */@media (max-width: 767px) { .category-card { padding: 18px; .recent-post-item { flex-direction: column; align-items: flex-start; .post-date { margin-top: 3px; align-self: flex-end; } } }} 效果： 点击更多文章后的文章列表实现 这部分主要基于原来的Index.swig，因为我觉得原来的风格就挺简洁好看的 找到themes/next/layout/category.swig，改成： 1234567891011121314151617181920212223242526{% extends '_layout.swig' %}{% import '_macro/sidebar.swig' as sidebar_template with context %}{% block title %} {{ page.category }} | {{ __('title.category') }} | {{ config.title }} {%- if theme.index_with_subtitle and config.subtitle %} - {{ config.subtitle }}{%- endif %}{% endblock %}{% block class %}category posts-expand{% endblock %}{% block content %} &lt;div class=&quot;category-title&quot; style=&quot;text-align: center; margin: 30px 0;&quot;&gt;//这里把分类名称置中了 &lt;h1&gt;{{ page.category }}&lt;/h1&gt; &lt;/div&gt; {%- for post in page.posts.toArray() %} {{ partial('_macro/post.swig', {post: post, is_index: true}) }} {%- endfor %} {% include '_partials/pagination.swig' %}{% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} 效果： 删除文章侧边栏目录难看的下划线 在themes/next/layout/_partials/head.swig最后加上： 1234567891011121314151617181920&lt;!-- 强制移除目录下划线 --&gt;&lt;style&gt; /* 覆盖所有可能的目录容器 */ [class*=&quot;toc&quot;] .nav-item a, [class*=&quot;TOC&quot;] .nav-item a, .active &gt; a, .active-current &gt; a { border-bottom: none !important; text-decoration: none !important; box-shadow: none !important; } /* 覆盖伪元素下划线 */ [class*=&quot;toc&quot;] a::after, [class*=&quot;TOC&quot;] a::after { display: none !important; }&lt;/style&gt; 效果： 删除文末标签文字前的“#” 先说文件：themes/next/layout/_macro/post.swig 这个问题，网上找到的解决方法都是删掉11行的“#” 123456789101112//这是原来的代码，可以ctrl+F搜post-footer&lt;footer class=&quot;post-footer&quot;&gt; {%- if post.tags and post.tags.length %} {%- if theme.tag_icon %} {%- set tag_indicate = '&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;' %} {% else %} {%- set tag_indicate = '#' %} {%- endif %} &lt;div class=&quot;post-tags&quot;&gt; {%- for tag in post.tags.toArray() %} &lt;a href=&quot;{{ url_for(tag.path) }}&quot; rel=&quot;tag&quot;&gt;#&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;{{ tag_indicate }} {{ tag.name }}&lt;/a&gt; {%- endfor %} 但是删除后发现“#”还在。把代码给DS看了下，发现第7行把tag_indicate设成了“#”，删掉这个就可以了 效果： 测试时阅读文章不计数 2025.6.2 注：在NexT8后的版本，valine不被支持了 博客搭起来后一直有个问题，就是自己看自己的博客文章会被计数，最开始是用ublock屏蔽统计网站来实现，但是这两天测试了一下发现这个方法用手机访问也不会计数，这不就意味着统计功能瘫痪了吗😮 所以开始和DS老师探讨新方法。DS老师这人不咋行，好方案藏着掖着，拷问了半天才有了下面的简洁的方法： themes/next/layout/_third-party/comments/valine.swig中，在new Valine({ })的括号里，把visitor设置成 1visitor : (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') ? false : {{ theme.valine.visitor }}, 这样子，在hexo s下访问localhost查看文章不会被计数。DS说这是把hexo s和hexo d两个环境隔离了，所以说如果hexo s下出现文章阅读数为零的情况算正常（我就是这样） 当然了，如果要看阅读数，就要访问hexo d部署后的网站了，记得不要点进文章去看，不然还是会被计数 麻烦是麻烦了点，但功能至少是实现了","link":"/2025/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1blog%E4%BC%98%E5%8C%96/"},{"title":"记一次blog重建","text":"部署Vercel失误后的blog重建（基于hexo+NexT8.23.0，采用utterances评论系统和firestore数据记录） OK，这是笔者在依赖AI盲目把博客部署到Vercel上导致博客崩溃后的博客重建记录 记录的原因首先是更新“记一次blog优化”的内容，还有新版本NexT的一些个人配置（新版本NexT的教程好像不多，评论系统和访客计数系统要自己琢磨好一会儿） 首页分类卡片实现 因为是对“记一次blog优化”的更新，所以这部分直接贴代码了（注：区别更多是在文件名从swig变成了njk） themes/next/layout/index.njk： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263{% extends '_layout.njk' %}{% import '_macro/sidebar.njk' as sidebar_template with context %}{% block title %}{{ title }}{%- if theme.index_with_subtitle and subtitle %} - {{ subtitle }}{%- endif %}{% endblock %}{% block class %}index categories-page{% endblock %}{% block content %}{# 这部分是实现category卡片，最后面还有没category的文章的处理，因为我严格了每篇文章有category，就没管画面如何了 #}{% if site.categories.length &gt; 0 %}&lt;div class=&quot;category-cards-container&quot;&gt; {% for cat in site.categories.toArray() %} &lt;div class=&quot;category-card&quot;&gt; &lt;div class=&quot;category-header&quot;&gt; &lt;h2 class=&quot;category-name&quot;&gt;{{ cat.name }}&lt;/h2&gt; &lt;span class=&quot;post-count&quot;&gt;{{ cat.posts.length }}篇文章&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;{# 这一部分实现卡片显示包含的文章的标题，数量可以改下面的limit()的数字 #} &lt;div class=&quot;recent-posts-list&quot;&gt; {% for post in cat.posts.sort('date', -1).limit(3).toArray() %} &lt;div class=&quot;recent-post-item&quot;&gt; &lt;a href=&quot;{{ url_for(post.path) }}&quot; class=&quot;post-title&quot; title=&quot;{{ post.title }}&quot;&gt; {{ post.title | truncate(18) }} &lt;/a&gt; &lt;span class=&quot;post-date&quot;&gt; {% if post.updated %} {{ post.updated.format('MM/DD') }} {% else %} {{ post.date.format('MM/DD') }} {% endif %} &lt;/span&gt; &lt;/div&gt; {% endfor %} &lt;div class=&quot;more-posts-wrapper&quot;&gt; &lt;a href=&quot;{{ url_for('/categories/' + cat.name + '/') }}&quot; class=&quot;more-posts-button&quot;&gt; 更多文章 → &lt;/a&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;{% endfor %}&lt;/div&gt;{% else %} &lt;div class=&quot;no-categories-notice&quot;&gt; &lt;p&gt;暂无分类数据，请为文章添加分类&lt;/p&gt; &lt;/div&gt; {% endif %}{% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} source/_data/styles.styl： 得先在next/config.yml里打开这个文件的支持（可能是新特性吧，笔者记得之前没改过config设置就有这个文件了，但是现在得打开支持并手动创建_data文件夹和styles.styl等文件），在custom_file_path里删除style的注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* 分类卡片样式 - 安全追加 */.category-cards-container { margin: 40px auto; max-width: 1200px; padding: 0 20px; .category-card { background: rgba(255,255,255,0.85); /* 半透明白色，与你的opacity 0.85协调 */ border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.1); margin-bottom: 25px; padding: 25px; transition: all 0.3s ease; backdrop-filter: blur(2px); /* 毛玻璃效果增强背景融合 */ border: 1px solid rgba(255,255,255,0.3); /* 柔和边框 */ &amp;:hover { transform: translateY(-5px); box-shadow: 0 5px 25px rgba(0,0,0,0.15); } .category-name { color: #2c3e50; font-size: 1.4em; margin: 0 0 8px 0; font-weight: 600; } .post-count { color: #7f8c8d; font-size: 0.9em; display: block; } }}/* 这部分是我自己用的背景图的设置 */body { background-image: url(/images/background.jpg); background-repeat: no-repeat; background-attachment: fixed; background-size: 100% 100%; opacity: 0.85;}/* ======================== *//* 分类卡片内的文章列表样式 *//* ======================== */.category-card { position: relative; /* 为毛玻璃效果提供定位上下文 */ .category-header { margin-bottom: 15px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.08); } .recent-posts-list { margin-top: 10px; .recent-post-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; transition: all 0.2s ease; &amp;:hover { transform: translateX(3px); } .post-title { color: #34495e; font-size: 0.95em; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; &amp;:hover { color: #3498db; text-decoration: underline; } } .post-date { color: #95a5a6; font-size: 0.8em; font-family: 'Arial', sans-serif; flex-shrink: 0; } } } * { border-bottom: none !important; box-shadow: none !important; } .category-header, .recent-post-item, .recent-posts-list { border: none !important; border-bottom: none !important; }}/* 更多文章按钮样式 */.more-posts-wrapper { text-align: left; margin-top: 12px; padding-top: 10px; .more-posts-button { display: inline-block; color:rgb(72, 168, 241); font-size: 0.9em; padding: 6px 12px; border-radius: 4px; transition: all 0.3s ease; background: rgba(52, 152, 219, 0.1); &amp;:hover { background: rgba(52, 152, 219, 0.2); transform: translateX(3px); } &amp;:hover::after { margin-left: 8px; } }}/* 响应式调整 */@media (max-width: 767px) { .category-card { padding: 18px; .recent-post-item { flex-direction: column; align-items: flex-start; .post-date { margin-top: 3px; align-self: flex-end; } } }}.posts-container{ margin: 40px auto; max-width: 1200px; padding: 0 20px;} 效果请见“记一次blog优化” 点击更多文章后的文章列表实现 仍然是基于原来的Index.njk themes/next/layout/category.njk： 123456789101112131415161718192021222324252627282930{% extends '_layout.njk' %}{% import '_macro/sidebar.njk' as sidebar_template with context %}{% block title %} {{ page.category }} | {{ __('title.category') }} | {{ config.title }}{% if theme.index_with_subtitle and subtitle %} - {{ subtitle }}{% endif %}{% endblock %}{% block class %}index posts-expand{% endblock %}{% block content %}&lt;div class=&quot;category-title&quot; style=&quot;text-align: center; margin: 30px 0;&quot;&gt; &lt;h1&gt;{{ page.category }}&lt;/h1&gt; &lt;/div&gt;{# 新增包裹容器并添加间距 class PS:这一部分是个人感觉列表太贴近侧边栏了，所以和首页分类卡片的位置设置保持一致了#} &lt;div class=&quot;posts-container&quot; style=&quot;margin-right: 30px ;&quot;&gt; {%- for post in page.posts.toArray() %} {{ partial('_macro/post.njk', {post: post, is_index: true}) }} {%- endfor %} {%- include '_partials/pagination.njk' -%} {% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} 效果仍见上一篇博客 删除侧边栏目录下划线与文末标签的“#” 这两个部分没有变动，除了文件名的后缀改变了，其余都一样。详见上一篇博客。 utterances评论系统 新版本NexT已经不支持valine了，给的选项只有： 所以笔者选了utterances。这个系统好像和github有点关系 在next/config.yml的comments里把active改成utterances 然后需要给github仓库安装utterances，访问https://github.com/apps/utterances ，然后点击Install 在跳转的页面勾选only select repositories，然后选择博客仓库 点击install就可以了 要注意的是，hexo s下是调试不了这个功能的（虽然不知道我为什么要在hexo s下调试这个功能），会报错，但是部署后是可以正常工作的 firestore统计访问人数 NexT8.23.0不支持Valine了，得重新选择数据统计系统。firestore是google的产品，因此需要科学上网。 参考大佬博客：https://weirenxue.github.io/2021/06/11/hexo_next_firestore_visitors/ 步骤很简洁完整了，但是个人实现的时候会有一些问题，接下来详细介绍相关步骤 首先，在next/config.yml里启用firestore： 有两个空需要填写，apikey和projectId。不急，需要先有firestore的项目。接下来访问firebase：https://console.firebase.google.com/ （科学上网） 登录后点击“创建项目” 接下来按照引导走下去，开发者计划、AI辅助、google analytics根据个人需求选择，点击继续并稍等片刻就创建成功了。 点击新项目，在左上角“项目概述”里点“项目设置” 这时候可以看见项目ID等信息了，但是api还没有显示 接下来在左侧边栏“构建”里找到“Authentication”，点击“开始”（哇，这个界面设置我还以为google不让手动设置只能用AI了，瞎按了半天才知道点”开始”） 接下来选择登陆方式登录即可。我选择谷歌，点击右上角启用，项目公开名称默认即可，项目支持邮箱选择个人谷歌邮箱 回到项目设置页面，可以看到api已经出现了 接下来就可以把next/config.yml里的projectId和apiKey填上了 然后打开左侧边栏“构建”里的“Firestore Database”，点击“创建数据库” 接下来的页面，设置位置（数据库ID似乎不能改动），然后下一步 接下来选择测试模式，等待预配Cloud Firestore 加载成功后长这样 接下来重新部署博客后就可以测试计数机制是否正常了。但是笔者在这一步折腾了很久，因为调试的时候发现： 1.数据库的信息在第一次启用计数机制后会自动生成，但是对这些信息进行改动后计数机制就失效了 2.即使在莫名其妙的情况下（可能是关闭firestore配置后再次开启的情况）重新初始化了数据库，计数1次之后再怎么访问（如刷新、关闭页面重新打开）也不会记录第2次 还有一些调试过程发现的问题，但是调试过程太乱了不好描述，所以下面直接指出问题并给出解决方案 首先，firestore的计数机制有点特别，它使用了localStorage来判断是否访问过文章，如果访问过文章，将不会出现第二次计数的情况（永远不会，除非重置localStorage）。这也解释了为什么改动数据信息后计数机制会失效：因为没有第二次计数，所以数据库信息不会再更新。因此需要对计数机制进行一些优化，优化方案来自DeepSeek，需要改动的配置为next/source/js/third-party/statistics/firestore.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* global CONFIG, firebase */firebase.initializeApp({ apiKey : CONFIG.firestore.apiKey, projectId: CONFIG.firestore.projectId});(function() { const getCount = (doc, increaseCount) =&gt; { // IncreaseCount will be false when not in article page return doc.get().then(d =&gt; { // Has no data, initialize count let count = d.exists ? d.data().count : 0; // If first view this article if (increaseCount) { // Increase count count++; doc.set({ count }); } return count; }); }; const db = firebase.firestore(); const articles = db.collection(CONFIG.firestore.collection); document.addEventListener('page:loaded', () =&gt; { if (CONFIG.page.isPost) { // Fix issue #118 // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent const title = document.querySelector('.post-title').textContent.trim(); const doc = articles.doc(title); let increaseCount = CONFIG.hostname === location.hostname; if (sessionStorage.getItem(title)) { increaseCount = false; } else { // Mark as visited in current session sessionStorage.setItem(title, true); } getCount(doc, increaseCount).then(count =&gt; { document.querySelector('.firestore-visitors-count').innerText = count; }).catch(e =&gt; console.error('Error updating count:', e)); } else if (CONFIG.page.isHome) { const promises = [...document.querySelectorAll('.post-title')].map(element =&gt; { const title = element.textContent.trim(); const doc = articles.doc(title); return getCount(doc); }); Promise.all(promises).then(counts =&gt; { const metas = document.querySelectorAll('.firestore-visitors-count'); counts.forEach((val, idx) =&gt; { metas[idx].innerText = val; }); }).catch(e =&gt; console.error('Error fetching counts:', e)); } });})(); 简单解释一下优化的主要思路：使用sessionStorage替换localStorage，计数机制变为会话级，即每次打开文章都会计数，而刷新不会计数 那么接下来就要设置一下数据库的规则了。大佬的安全规则好像有一些漏洞，下面是DeepSeek生成的安全规则： 1234567891011121314151617181920212223rules_version = '2';service cloud.firestore { match /databases/{database}/documents { // 针对文章集合的规则 match /articles/{articleId} { // 允许所有人读取 allow read: if true; // 创建新文档时的规则 allow create: if request.resource.data.keys().hasOnly([&quot;count&quot;]) &amp;&amp; request.resource.data.count == 1; // 更新文档时的规则（确保count只能+1） allow update: if request.resource.data.keys().hasOnly([&quot;count&quot;]) &amp;&amp; request.resource.data.count == resource.data.count + 1; } // 禁止其他所有操作 match /{document=**} { allow read, write: if false; } }} 打开“Firestore Database”的“规则”，把规则粘贴进去，点击发布即可","link":"/2025/06/05/%E8%AE%B0%E4%B8%80%E6%AC%A1blog%E9%87%8D%E5%BB%BA/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"周记","slug":"周记","link":"/tags/%E5%91%A8%E8%AE%B0/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"杂记","slug":"杂记","link":"/tags/%E6%9D%82%E8%AE%B0/"}],"categories":[{"name":"Reverse Engineering","slug":"Reverse-Engineering","link":"/categories/Reverse-Engineering/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"周记","slug":"周记","link":"/categories/%E5%91%A8%E8%AE%B0/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"}],"pages":[{"title":"about","text":"关于我 南京邮电大学2024级信息安全本科在读 学习方向是主要是逆向工程、二进制安全、红队免杀 本站主要是为了记录学习经历，希望可以为像我一样迷茫的人提供一些帮助 分享的文章会尽量保证可读性和可实践性 联系方式 微信：bywnxhx_ QQ：2175241477 博客：https://sydzi.github.io/ 欢迎师傅们提供指导建议","link":"/about/index.html"},{"title":"","text":"/* global IcarusThemeSettings, firebase */ // Firebase Counter - 阅读量统计功能 if (IcarusThemeSettings && IcarusThemeSettings.services && IcarusThemeSettings.services.firebase && IcarusThemeSettings.services.firebase.enable) { // 初始化Firebase try { // 确保firebase对象存在 if (typeof firebase === 'undefined') { console.error('Firebase library not loaded'); // 如果Firebase库未加载，隐藏计数器元素 document.querySelectorAll('.firestore-visitors-count').forEach(el => { el.style.display = 'none'; }); } else { firebase.initializeApp({ apiKey: IcarusThemeSettings.services.firebase.apiKey, projectId: IcarusThemeSettings.services.firebase.projectId }); // 开发环境检测 const isLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname); const isDevelopment = isLocalhost || window.location.hostname.includes('192.168.'); // 移除所有调试日志输出 // 获取数据库引用 const db = firebase.firestore(); const articlesCollection = IcarusThemeSettings.services.firebase.collection || 'articles'; const articles = db.collection(articlesCollection); // 获取阅读次数函数 const getCount = (doc, increaseCount) => { // 获取文档数据 return doc.get().then(d => { // 初始化计数 let count = d.exists ? d.data().count : 0; // 如果需要增加计数（只在文章页面且未在同一会话访问过） if (increaseCount) { // 增加计数 count++; return doc.set({ count }).then(() => { if (isDevelopment) console.log('计数已更新:', count); return count; }).catch(error => { console.error('Error updating count:', error); return count; // 返回增加前的计数 }); } return count; }).catch(error => { console.error('Error getting count:', error); // 出错时返回默认值0 return 0; }); }; // 处理阅读计数的函数 const handleViewCount = () => { // 获取当前URL路径 const currentPath = window.location.pathname; // 增强首页识别：使用多个可能的选择器 const isIndexPage = document.querySelector('.article-list') !== null || document.querySelector('.article-card-list') !== null || document.querySelectorAll('.article-card').length > 0 || // 降低阈值以适应首页 (currentPath === '/' && document.querySelector('article.article') !== null); // 特殊处理：根路径+article.article元素 // 增强文章页面识别：使用更精确的选择器组合 // 重要：首页优先判断，且文章页判断要排除首页的情况，并增加特定的文章页特征 const isArticlePage = !isIndexPage && ( // 传统文章页选择器 (document.querySelector('.article-container') !== null && document.querySelector('.article-content') !== null) || (document.querySelector('article.post') !== null && document.querySelector('.article-content') !== null) || document.querySelector('[id=\"post-content\"]') !== null || // 针对hexo s环境的增强选择器，但需要确保不是首页 (document.querySelector('article.article') !== null && document.querySelector('article.card-content.article') !== null && document.querySelectorAll('.article-card').length === 0 && currentPath !== '/') ); // 页面类型信息 - 仅在开发环境显示 if (isDevelopment) { console.log(`[Firebase] 当前页面类型: ${isArticlePage ? '文章页' : isIndexPage ? '首页' : '其他页面'}`); } if (isArticlePage) { // 文章页面处理 const titleElement = document.querySelector('.title.is-3, .title.is-4-mobile'); const countElement = document.querySelector('.firestore-visitors-count'); if (titleElement && countElement) { const title = titleElement.textContent.trim(); const doc = articles.doc(title); // 确定是否增加计数：不在本地开发环境且同一会话未访问过 let increaseCount = !isDevelopment; if (sessionStorage.getItem(title)) { increaseCount = false; } else { // 标记为在当前会话中已访问 sessionStorage.setItem(title, true); } getCount(doc, increaseCount).then(count => { countElement.innerText = count; }).catch(e => { // 移除错误日志 }); } else { // 静默处理：未找到文章标题或计数元素 } } else if (isIndexPage) { // 首页文章列表处理 // 修改选择器以匹配实际HTML结构 // 首页文章结构: .card > .card-content.article > .title.is-3.is-size-4-mobile const titleElements = document.querySelectorAll( '.card .article .title.is-3, .card .article .title.is-4-mobile, ' + '.card article .title.is-3, .card article .title.is-4-mobile, ' + '.card .article p.title, .card article p.title' ); const countElements = document.querySelectorAll('.card .article .firestore-visitors-count, .card article .firestore-visitors-count'); // 移除首页元素检测日志 if (titleElements.length > 0 && countElements.length > 0) { const promises = [...titleElements].map(element => { const title = element.textContent.trim(); const doc = articles.doc(title); // 首页只获取计数，不增加计数 return getCount(doc, false).then(count => { return count; }); }); Promise.all(promises).then(counts => { counts.forEach((val, idx) => { if (countElements[idx]) { countElements[idx].innerText = val; } }); }).catch(e => { // 错误处理：尝试显示一些默认值或替代文本 countElements.forEach(el => { if (el.innerText === '0') { el.innerText = '加载中...'; } }); }); } else { // 尝试使用更通用的选择器 const fallbackTitleElements = document.querySelectorAll('.article-card a[href^=\"/\"]'); const fallbackCountElements = document.querySelectorAll('.article-card .firestore-visitors-count'); if (fallbackTitleElements.length > 0 && fallbackCountElements.length > 0) { // 这里可以添加备选逻辑 } } } else { // 静默处理：当前页面既不是文章页也不是首页 } }; // 监听传统页面加载完成事件 document.addEventListener('DOMContentLoaded', () => { handleViewCount(); }); // 监听PJAX页面加载完成事件（适配Icarus主题的PJAX机制） document.addEventListener('page:loaded', () => { handleViewCount(); }); } } catch (error) { // 移除初始化失败日志 // 如果初始化失败，尝试隐藏计数器元素以避免显示为0 document.querySelectorAll('.firestore-visitors-count').forEach(el => { el.style.display = 'none'; }); } }","link":"/js/firebase_counter.js"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}