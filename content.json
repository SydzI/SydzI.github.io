{"posts":[{"title":"0xGame2025Week1WriteUp","text":"0xGame2025 Week1 Reverse方向全解&amp;详解 EasyXor 附件程序用IDA打开就是main函数的位置了，按F5反编译得到如下： 进行一些小小的变量名优化可以得到： 可以看出，函数获取flag输入，然后对flag每一位进行异或，异或的值来自一个给定的字符串，要求异或后的值要等于str[i]-i。所以解密思路是，把异或关系中的Char和str[i]-i进行对调，即由Char^key[index%length]==str[i]-i得到( str[i]-i )^key[index%length]==Char。解密脚本： 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() { char str[] = { 0x42, 0x1A, 0x39, 0x17, 0x1D, 0x09, 0x51, 0x55, 0x2C, 0x5F, 0x63, 0x0C, 0x0D, 0x16, 0x62, 0x27, 0x55, 0x64, 0x55, 0x26, 0x6D, 0x6A, 0x18, 0x34, 0x88, 0x65, 0x6E, 0x1C, 0x21, 0x6E, 0x3D, 0x23, 0x6A, 0x25, 0x6B, 0x63, 0x68, 0x7E, 0x77, 0x75, 0x9A, 0x7D, 0x39, 0x43, 0x00, 0x00, 0x00, 0x00 }; char key[] = &quot;raputa0xGame2025&quot;; char flag[45]; for (int i = 0; i &lt;= 43; i++) { flag[i] = (str[i] - i) ^ key[i % strlen(key)]; } flag[44] = '\\0'; printf(&quot;%s&quot;, flag); return 0;} BaseUpx 题目提示有Upx壳，用DIE打开附件程序可以看出这是标准upx4.24 在Github上下载Release UPX 4.2.4 · upx/upx，使用指令upx -d脱壳 然后就可以把脱壳后的程序拿到IDA里分析，打开就是main函数了，按F5反编译： 可以看到函数对输入的enc（实际上是flag）进行了base64encode，然后和str进行比较。因此思路是拿到str，直接用CyberChef来进行base64解码： SignIn 附件程序用IDA打开，直接就是main函数了，按F5反编译，提示flag在程序里 shift+F12查看字符串表，就可以找到flag了 SignIn2 运行附件程序可以看到一些提示： 提示ROT47，应该是某种加密 附件程序用IDA打开，按F5反编译main函数： 可以看到程序里本来就有一个flag，程序拿到我们输入的数字后对flag进行了加密，然后检查加密后的flag开头几个字母是不是”0xGame”。既然提到了ROT47，就把flag的数据拿到CyberChef里看看能不能解密，刚好可以找到一个ROT 47 Brust Force（flag就直接复制程序里的就好了）： 当时解完没细看flag内容，复现这题来写博客的时候看到这个flag还有点怀疑对不对😂 ZZZ 附件程序用IDA打开，直接就是main函数了，按F5反编译一下： 可以看出程序拿到输入的flag后先检查了一下格式，然后截取除了4个部分，拿这4个部分建立了等式。结合题目ZZZ可以推测这是在考z3求解。题目为了保证唯一解还给了flag的sha256来验证 用z3复现一下等式，再加上sha256验证： 123456789101112131415161718192021222324from z3 import *import hashlibsha256='4aba519d4666f5421488afaaf89efdcbe48e7a53f814ce5c1d82b46b55032651's=Solver()x1=BitVec('x1',32)x2=BitVec('x2',32)x3=BitVec('x3',32)x4=BitVec('x4',32)s.add(3 * x2 + 5 * x1 + 7 * x4 + 2 * x3 == -1445932505)s.add(2 * (2 * (2 * x2 + x3) + x1) + x4 == -672666814)s.add(7 * x2 + 3 * x1 + 5 * x4 + 4 * x3 == 958464147)s.add(((x1 ^ x2) &lt;&lt; 6) + ((x3 &gt;&gt; 6) ^ 0x4514) == 123074281)while s.check() == sat: model=s.model() x1_val=model[x1].as_long() x2_val=model[x2].as_long() x3_val=model[x3].as_long() x4_val=model[x4].as_long() flag=f&quot;0xGame{{{x1_val:08x}{x2_val:08x}{x3_val:08x}{x4_val:08x}}}&quot; if hashlib.sha256(flag.encode()).hexdigest()==sha256:#验证是否为正确flag print(flag) exception=Or(x1!=x1_val,x2!=x2_val,x3!=x3_val,x4!=x4_val)#排除同一解 s.add(exception) DyDebug 附件程序用IDA打开，直接就是main函数了，按F5看看反编译： 如注释写的，程序对我们的输入没有任何操作，而是拿了flag明文来比较，所以可以直接动态调试拿到flag明文。这里需要知道一些汇编小知识：函数的返回值存放在寄存器rax里。然后开始我们的操作： 在main函数反编译界面选中解密函数decrypt_string()所在行，右键选择jump to disasm跳到汇编界面： 光标停在的地方附近就有一个call _Z14decrypt_stringPKcy指令，后面有注释是解密函数decrypt_string() 其实光标停在的位置的指令就是取函数返回值的操作了。函数的返回值放在rax里，而这条指令把rax mov（移动）到了[rbp-10h+decrypted_str]，看不懂没关系，只需要知道函数返回值可以通过这里的rax看到就行了。这个返回值就是解密后得到的flag明文。在光标停在的位置按F2下断点 把界面正上方的”no debugger”改选成”local windows debugger”，按旁边绿色的三角形开始调试 这时候会弹出命令行窗口，随便输入一点东西，按回车 可以看到IDA里程序停在了我们刚刚下断点的地方 把鼠标移到rax上就可以看到flag了，双击rax到flag的位置，可以把这一串数据复制给AI提取","link":"/2025/10/10/0xGame2025Week1ReverseWriteUp/"},{"title":"0xGame2025Week2WriteUp","text":"0xGame2025 Week2 Reverse方向全解&amp;详解 shuffle 附件用IDA打开，main函数反编译后大概长这样： 这是shuffle函数： 可以看出这是在考随机数，有了种子就可以得到一模一样的随机数序列。回到main函数，双击seed可以得到一个值： 但是经过测试这个seed解不出flag，回头看可以发现上图中seed还有另一个引用：runtime_env，很可疑了。双击跳转： 出现了对seed的赋值，结合名字的”runtime”可以推测这个才是真正的seed 解密脚本： 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void unshuffle_simple(unsigned char *str, int length) { int *rand_vals = (int*)malloc(length * sizeof(int)); unsigned char temp; int i, j; // 先获取所有随机值 for (i = length - 1; i &gt; 0; --i) { rand_vals[i] = rand(); } // 逆向洗牌：从前往后 for (i = 1; i &lt; length; i++) { j = rand_vals[i] % (i + 1); // 执行相同的交换 temp = str[i]; str[i] = str[j]; str[j] = temp; } free(rand_vals);}int main() { unsigned int seed = 0x666; char flag[] = &quot;23-64bed6}-xm5300-{faGa34-0e04c2e7c2a78f39a4&quot;; int length = strlen(flag); srand(seed); unshuffle_simple((unsigned char*)flag, length); printf(&quot;flag: %s\\n&quot;, flag); return 0;} 算数高手 附件程序是个pythonexe，相关知识可以参考Day17:python逆向（王婆卖瓜ing。使用pyinstxtractor解包后可以得到一个文件夹： 根据pyinstxtractor的提示可以找到疑似入口文件，同名的文件可能性大点。然后用uncompyle6把pyc转成py格式： 直接得到flag BabyJar 附件程序是个jar文件，用jd-gui打开： 可以看到这是一个java的flag检验程序，加密逻辑在encrypt方法里。上图选中的那行把字节的高位移到低位，低位移到高位，所以再操作一次就可以还原。还要注意encrypt的返回值进行了base64编码。 解密脚本： 123456789101112131415import base64def decrypt(enc,key): enc=base64.b64decode(enc) flag=&quot;&quot; for i in enc: temp=((i&amp;240)&gt;&gt;4|(i&amp;15)&lt;&lt;4) flag+=chr(temp^key) return flagenc=&quot;QsY1V5cX9jJyF2JSAgdikwfCEneTAgICUpNnd1Iyk8IXUkJ3QhcyZ8J3YpY=&quot;key=20flag=&quot;&quot;flag=decrypt(enc,key)print(flag) 16bit 根据题目名称和提示可以推测考察16位环境逆向。附件程序不能运行，IDA也反编译不了，只能读汇编： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158seg000:0000 ; =============== S U B R O U T I N E =======================================seg000:0000seg000:0000 ; Attributes: noreturnseg000:0000seg000:0000 public startseg000:0000 start proc nearseg000:0000 mov ax, seg dsegseg000:0003 mov ds, ax ; dseg是数据段，有flag加密后的数据seg000:0005 assume ds:dsegseg000:0005 mov cx, 17h ; count寄存器，一般存放循环次数seg000:0008 mov si, 0seg000:000B mov di, 0seg000:000Eseg000:000E loc_1000E: ; CODE XREF: start+1C↓jseg000:000E mov al, [si+0Ah] ; si=0时[0Ah]即dseg：000A，是flag密文的位置，此处是在取出密文seg000:0012 sub al, 9 ; 减9seg000:0014 xor al, 0Eh ; 异或seg000:0016 mov [di+38h], al ; 解密后的数据存放到以[38h]即dseg:0038h为起始的区域seg000:001A inc si ; 往下取seg000:001B inc di ; 往下存seg000:001C loop loc_1000E ; si=0时[0Ah]即dseg：000A，是flag密文的位置，此处是在取出密文seg000:001E mov cx, 17h ; 更新循环次数seg000:0021seg000:0021 loc_10021: ; CODE XREF: start+2F↓jseg000:0021 mov al, [si+0Ah] ; 此处si=17h,所以取的是以dseg:0021h为起始的数据seg000:0025 xor al, 0Eh ; 异或seg000:0027 sub al, 9 ; 减9seg000:0029 mov [di+38h], al ; 解密后的数据存放到seg:004f为起始的区域seg000:002D inc si ; 往下取seg000:002E inc di ; 往下存seg000:002F loop loc_10021 ; 此处si=17h,所以取的是以dseg:0021h为起始的数据seg000:0031 mov byte_100A6, 24h ; '$' ; byte_100A6是&quot;flag=&quot;，此处是在打印flagseg000:0036 mov dx, 67h ; 'g'seg000:0039 mov ah, 9seg000:003B int 21h ; DOS - PRINT STRINGseg000:003B ; DS:DX -&gt; string terminated by &quot;$&quot;seg000:003D mov dx, 38h ; '8'seg000:0040 mov ah, 9seg000:0042 int 21h ; DOS - PRINT STRINGseg000:0042 ; DS:DX -&gt; string terminated by &quot;$&quot;seg000:0044 mov ax, 4C00hseg000:0047 int 21h ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)seg000:0047 start endp ; AL = exit codeseg000:0047seg000:0047 seg000 endsseg000:0047dseg:0009 ; ===========================================================================dseg:0009dseg:0009 ; Segment type: Pure datadseg:0009 dseg segment para public 'DATA' use16dseg:0009 assume cs:dsegdseg:0009 ;org 9dseg:0009 align 2dseg:000A db 47h ; Gdseg:000B db 7Fh ; dseg:000C db 52h ; Rdseg:000D db 78h ; xdseg:000E db 6Ch ; ldseg:000F db 74h ; tdseg:0010 db 7Eh ; ~dseg:0011 db 72h ; rdseg:0012 db 47h ; Gdseg:0013 db 47h ; Gdseg:0014 db 73h ; sdseg:0015 db 5Ah ; Zdseg:0016 db 84hdseg:0017 db 5Ah ; Zdseg:0018 db 43h ; Cdseg:0019 db 85hdseg:001A db 46h ; Fdseg:001B db 5Ah ; Zdseg:001C db 83hdseg:001D db 6Fh ; odseg:001E db 46h ; Fdseg:001F db 5Ah ; Zdseg:0020 db 6Ch ; ldseg:0021 db 33h ; 3dseg:0022 db 30h ; 0dseg:0023 db 73h ; sdseg:0024 db 32h ; 2dseg:0025 db 75h ; udseg:0026 db 66h ; fdseg:0027 db 37h ; 7dseg:0028 db 61h ; adseg:0029 db 66h ; fdseg:002A db 33h ; 3dseg:002B db 30h ; 0dseg:002C db 78h ; xdseg:002D db 66h ; fdseg:002E db 40h ; @dseg:002F db 35h ; 5dseg:0030 db 61h ; adseg:0031 db 4Eh ; Ndseg:0032 db 64h ; ddseg:0033 db 34h ; 4dseg:0034 db 65h ; edseg:0035 db 32h ; 2dseg:0036 db 33h ; 3dseg:0037 db 88hdseg:0038 db 0dseg:0039 db 0dseg:003A db 0dseg:003B db 0dseg:003C db 0dseg:003D db 0dseg:003E db 0dseg:003F db 0dseg:0040 db 0dseg:0041 db 0dseg:0042 db 0dseg:0043 db 0dseg:0044 db 0dseg:0045 db 0dseg:0046 db 0dseg:0047 db 0dseg:0048 db 0dseg:0049 db 0dseg:004A db 0dseg:004B db 0dseg:004C db 0dseg:004D db 0dseg:004E db 0dseg:004F db 0dseg:0050 db 0dseg:0051 db 0dseg:0052 db 0dseg:0053 db 0dseg:0054 db 0dseg:0055 db 0dseg:0056 db 0dseg:0057 db 0dseg:0058 db 0dseg:0059 db 0dseg:005A db 0dseg:005B db 0dseg:005C db 0dseg:005D db 0dseg:005E db 0dseg:005F db 0dseg:0060 db 0dseg:0061 db 0dseg:0062 db 0dseg:0063 db 0dseg:0064 db 0dseg:0065 db 0dseg:0066 byte_100A6 db 0 ; DATA XREF: start+31↑wdseg:0067 db 66h ; fdseg:0068 db 6Ch ; ldseg:0069 db 61h ; adseg:006A db 67h ; gdseg:006B db 20hdseg:006C db 3Dh ; =dseg:006D db 24h ; $dseg:006E db ? ;dseg:006F db ? ;dseg:006F dseg endsdseg:006Fseg002:0000 ; =========================================================================== 可以看出程序分两部分对flag的密文进行了解密，模拟这段代码就可以得到flag。解密脚本： 123456789101112131415161718192021222324252627data = [ 0x47, 0x7F, 0x52, 0x78, 0x6C, 0x74, 0x7E, 0x72, 0x47, 0x47, 0x73, 0x5A, 0x84, 0x5A, 0x43, 0x85, 0x46, 0x5A, 0x83, 0x6F, 0x46, 0x5A, 0x6C, 0x33, 0x30, 0x73, 0x32, 0x75, 0x66, 0x37, 0x61, 0x66, 0x33, 0x30, 0x78, 0x66, 0x40, 0x35, 0x61, 0x4E, 0x64, 0x34, 0x65, 0x32, 0x33, 0x88]output = []# 第一段解密（前 0x17 字节）for i in range(0x17): al = data[i] al = (al - 9) &amp; 0xFF al = al ^ 0x0E output.append(al)# 第二段解密（后 0x17 字节）for i in range(0x17,0x2E): al = data[i] al = al ^ 0x0E al = (al - 9) &amp; 0xFF output.append(al)# 输出为字符串flag = ''.join(chr(i) for i in output)print(flag) TELF 题目提示加壳，DIE检查发现附件程序加了upx壳： 这是个elf文件，考察elf手动脱壳的话难度不小。使用upx工具会发现脱不了壳，推测有upx特征魔改。用010editor打开附件程序，注意到出现了可疑字样”X1c”： 修改”X1c”为”UPX”后程序可正常工具脱壳： 脱壳后的程序用IDA打开，main函数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int __fastcall main(int argc, const char **argv, const char **envp){ __int64 block; // [rsp+8h] [rbp-A8h] BYREF _QWORD fl4g[8]; // [rsp+10h] [rbp-A0h] BYREF char flag[8]; // [rsp+50h] [rbp-60h] BYREF __int64 v7; // [rsp+58h] [rbp-58h] __int64 v8; // [rsp+60h] [rbp-50h] __int64 v9; // [rsp+68h] [rbp-48h] __int64 v10; // [rsp+70h] [rbp-40h] __int64 v11; // [rsp+78h] [rbp-38h] __int64 v12; // [rsp+80h] [rbp-30h] _DWORD key[5]; // [rsp+90h] [rbp-20h] BYREF int k; // [rsp+A4h] [rbp-Ch] int j; // [rsp+A8h] [rbp-8h] int i; // [rsp+ACh] [rbp-4h] srand(0xF6950u); for ( i = 0; i &lt;= 3; ++i ) key[i] = rand(); printf(&quot;Please input your flag: &quot;); if ( __isoc99_scanf(&quot;%56s&quot;, flag) == 1 ) { if ( strlen(flag) == 56 ) { fl4g[0] = *flag; fl4g[1] = v7; fl4g[2] = v8; fl4g[3] = v9; fl4g[4] = v10; fl4g[5] = v11; fl4g[6] = v12; for ( j = 0; j &lt;= 55; j += 8 ) { block = fl4g[j / 8u]; encrypt(&amp;block, key); fl4g[j / 8u] = block; } for ( k = 0; k &lt;= 55; ++k ) { if ( enc[k] != *(fl4g + k) ) { printf(&quot;Try Again!&quot;); return 1; } } puts(&quot;Congratulation!&quot;); return 0; } else { puts(&quot;Length Error!&quot;); return 1; } } else { fwrite(&quot;Input error or EOF\\n&quot;, 1uLL, 0x13uLL, _bss_start); return 1; }} 可以看出程序用先随机数生成了key，然后对输入的flag进行了加密，最后是校验。加密函数如下，是tea加密： 但是用相同种子生成的随机数组成的key会解密失败，动调会发现key和自己使用同一种子生成的key不同（IDAelf动调教程见ida动态调试elf(无坑详细)）： 这样就能解密了。tea加密的主要逻辑是异或，所以只需要还原出加密时的相关变量就可以了 解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t* block, uint32_t* key) { uint32_t p1 = block[0]; uint32_t p2 = block[1]; int sum = 0; for (int i = 0; i &lt; 32; i++) { sum -= 0x61C88647; } for (int i = 0; i &lt; 32; i++) { p2 -= (p1 + sum) ^ (16 * p1 + key[2]) ^ ((p1 &gt;&gt; 5) + key[3]); p1 -= (p2 + sum) ^ (16 * p2 + key[0]) ^ ((p2 &gt;&gt; 5) + key[1]); sum += 0x61C88647; } block[0] = p1; block[1] = p2;}int main() { uint32_t key[4] = { 0x7e4d087b, 0x7a4db733, 0x70fe9df0, 0x595607f7 }; uint32_t enc[14] = { 0xDC01DAAD, 0x088A5BAE, 0x8F4FF54E, 0x9E9D5F6E, 0x08A94E0A, 0xC245AB25, 0x438FC94B, 0x28D6513D, 0xF4CD72F6, 0x3B4AB42B, 0xEF6636FB, 0xB28C8AD6, 0x1B9C1AEB, 0x531F9C0A }; for (int i = 0; i &lt; 14; i += 2) { decrypt(&amp;enc[i], key); } char* flagChar = (char*)enc; for (int i = 0; i &lt; 56; i++) { printf(&quot;%c&quot;, flagChar[i]); } return 0;}","link":"/2025/10/19/0xGame2025Week2ReverseWriteUp/"},{"title":"Day1:x86汇编框架、数据类型、基本运算、位运算","text":"vs2022汇编环境、x86汇编框架、数据类型、基本运算、位运算 在vs2022中编写汇编代码 新建一个空项目 在工具栏的“工具”选项中选择“获取工具和功能”，在“使用C++的桌面开发”中勾选“Windows 10 SDK”以及“MSVC v142 -VS 2015 C++生成工具”，然后安装这些新勾选的选项，更新VS2022 右键新建的空项目，选择最下方的“属性”，在弹出来的页面中选择“常规”，然后将平台版本改成windows10，可能需要改也可能不需要 右键新建的空项目，选择“生成依赖性”，然后是“生成自定义”，在界面中选择masm 然后就可以新建一个.asm源文件了。新建完成后，右键源文件选择“属性”，然后在“常规”里检查项类型是否为“Microsoft Macro Assembler” 以上是针对报错进行的尝试修正总结，可能有多余或者不足之处 x86汇编框架(MASM) xxxxxxxxxx2 1int num[2][2] = { {1,2},{3,4} };2printf(“%d,%d,%d,%d”, num[0][0], num[0][1], num[1][0], num[1][1]);c 123456789101112131415161718192021222324252627;预处理.586.model flat,stdcall;包含的链接库includelib ucrt.libincludelib legacy_stdio_definitions.libincludelib kernel32.libincludelib user32.lib;外部函数声明extern printf:proc;数据段.dataszHello db 'HelloWorld!',0;代码段.code;函数声明main proc lea eax,szHello push eax call printf add esp,4main endpend 重点如下： 链接库声明 1includelib NameOfLib.lib 不同的段 12.NameOfSection;段所包含的数据 函数格式 123functionName proc 参数名1:参数类型，参数名2:参数类型... ;汇编代码functionName endp 在一个asm文件末尾，需要 12end ;用于无入口点，即非可执行文件，不需要主函数时end main ;用于可执行文件，必须指定入口点(如main函数)时 数据类型 类型名称 简写 对应类型 占用字节数 BYTE db char 1 WORD dw short 2 DWORD dd int 4 QWORD dq long long 8 基本运算 数据传送指令 1234mov dest,src ;dest=src;eax=1示例mov eax,1 地址传送指令 1234lea dest,[addr] ;dest=addr;eax=77E75F38示例lea eax,77E75F38 加法 12345add dest,src ;dest=dest+src;1+1=2示例，最后eax里为2mov eax,1add eax,1 自增 1234inc dest ;dest=dest+1;eax++示例inc eax 减法 12345sub dest,src ;dest=dest-src;6-2=4示例，最后eax里为4mov eax,6sub eax,2 自减 1234dec dest ;dest=dest-1;eax--示例dec eax 乘法 1234567891011;分为mul(无符号)和imul(有符号);乘法结果存放在edx和eax中(edx:eax)，低位eax，高位edx。未指定时，eax默认作为一个因数mul src ;edx:eax=eax*srcimul src ;edx:eax=eax*srcimul dest,src ;dest=dest*srcimul dest,src,imm ;dest=src*imm;4*2=8示例，eax*ebxmov eax,4mov ebx,2mul ebx 除法 12345678910;分为div(无符号)和idiv(有符号);被除数放在edx:eax中，除数任意，商存放在eax中，余数存放在edx中div src ;edx:eax%src=eax...edxidiv src ;edx:eax%src=eax...edx;101%2...1示例mov eax,101mov edx,0mov ebx,2div ebx 位运算 与 123456and dest,src ;dest=dest &amp; src;1&amp;2=0示例mov eax,1mov ebx,2and eax,ebx 或 123456or dest,src ;dest=dest | src;1|2=3示例mov eax,1mov ebx,2or eax,ebx 取反 12345not dest ;dest=~dest;not 00000001=11111110示例mov eax,1not eax 异或 123456xor dest,src ;dest=dest^src;1^2=3示例mov eax,1mov ebx,2xor eax,ebx 左移，右移 123456789101112131415;左移shl dest,count ;dest=dest&lt;&lt;count;1&lt;&lt;3=8示例mov eax,1mov cl,3shl eax,cl;右移shr dest,count ;dest=dest&gt;&gt;count;8&gt;&gt;3=1示例mov eax,8mov cl,3shr eax,cl","link":"/2025/07/05/Day1-x86%E6%B1%87%E7%BC%96%E6%A1%86%E6%9E%B6/"},{"title":"0xGame2025Week3WriteUp","text":"0xGame2025 Week3 Reverse方向全解&amp;详解 easyApp 考点：apk逆向、工具应用、base64编码解码、z3求解 附件程序是个apk，在模拟器中运行如图，推测按钮会触发flag检验逻辑： 用JEB打开apk，找到MainActivity并右键解析后，得到JAVA代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.easyapp;import android.content.Context;import android.os.Bundle;import android.util.Base64;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.activity.ComponentActivity;import dalvik.system.DexClassLoader;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.lang.reflect.Method;import kotlin.Metadata;import kotlin.collections.ArraysKt;import kotlin.io.ByteStreamsKt;import kotlin.jvm.functions.Function1;import kotlin.jvm.internal.Intrinsics;import kotlin.text.Charsets;import kotlin.text.StringsKt;@Metadata(d1 = {&quot;\\u0000\\&quot;\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0002\\b\\u0002\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0000\\n\\u0002\\u0010\\u000E\\n\\u0002\\u0010\\u0012\\n\\u0000\\b\\u0007\\u0018\\u00002\\u00020\\u0001B\\u0005¢\\u0006\\u0002\\u0010\\u0002J\\u0012\\u0010\\u0003\\u001A\\u00020\\u00042\\b\\u0010\\u0005\\u001A\\u0004\\u0018\\u00010\\u0006H\\u0014J\\f\\u0010\\u0007\\u001A\\u00020\\b*\\u00020\\tH\\u0002¨\\u0006\\n&quot;}, d2 = {&quot;Lcom/example/easyapp/MainActivity;&quot;, &quot;Landroidx/activity/ComponentActivity;&quot;, &quot;()V&quot;, &quot;onCreate&quot;, &quot;&quot;, &quot;savedInstanceState&quot;, &quot;Landroid/os/Bundle;&quot;, &quot;toHexString&quot;, &quot;&quot;, &quot;&quot;, &quot;app_release&quot;}, k = 1, mv = {1, 9, 0}, xi = 0x30)public final class MainActivity extends ComponentActivity { public static final int $stable; static { } @Override // androidx.activity.ComponentActivity protected void onCreate(Bundle arg3) { super.onCreate(arg3); this.setContentView(layout.activity_main); EditText v3 = (EditText)this.findViewById(id.flagInput); ((Button)this.findViewById(id.button)).setOnClickListener((View arg2) -&gt; MainActivity.onCreate$lambda$0(v3, this, arg2)); // 这里将Click和onCreate$lambda$0绑定起来了 } private static final void onCreate$lambda$0(EditText arg6, MainActivity arg7, View arg8) { boolean v6_4; // v8_1的返回值流向v6_4 Intrinsics.checkNotNullParameter(arg7, &quot;this$0&quot;); String v6 = arg6.getText().toString(); // v6存放了输入的flag File v8 = new File(arg7.getCacheDir(), &quot;dex.zip&quot;); InputStream v0 = arg7.getAssets().open(&quot;dex.zip&quot;); // 打开了asset/dex.zip Intrinsics.checkNotNullExpressionValue(v0, &quot;open(...)&quot;); ByteStreamsKt.copyTo$default(v0, ((OutputStream)new FileOutputStream(v8)), 0, 2, null); if(v6.length() == 42) { Method v8_1 = new DexClassLoader(v8.getAbsolutePath(), arg7.getCacheDir().getAbsolutePath(), null, arg7.getClassLoader()).loadClass(&quot;com.example.easyapp.Secret&quot;).getDeclaredMethod(&quot;check&quot;, String.class); // v8指向了dex中的com.example.easyapp.Secret的check方法 String v1 = v6.substring(0, 26); // flag被截断，截断的部分流向v1 Intrinsics.checkNotNullExpressionValue(v1, &quot;this as java.lang.String…ing(startIndex, endIndex)&quot;); byte[] v1_1 = v1.getBytes(Charsets.UTF_8); // flag截断部分流向v1_1 Intrinsics.checkNotNullExpressionValue(((Object)v1_1), &quot;this as java.lang.String).getBytes(charset)&quot;); String v1_2 = Base64.encodeToString(v1_1, 0); // flag截断部分被进行了base编码，流向v1_2 Intrinsics.checkNotNullExpressionValue(v1_2, &quot;encodeToString(...)&quot;); String v1_3 = StringsKt.trim(((CharSequence)v1_2)).toString(); // 编码后的flag截断部分流向v1_3 String v6_1 = v6.substring(26); // flag的剩余部分流向了v6_1 Intrinsics.checkNotNullExpressionValue(v6_1, &quot;this as java.lang.String).substring(startIndex)&quot;); byte[] v6_2 = v6_1.getBytes(Charsets.UTF_8); // flag的剩余部分从v6_1流向了v6_2 Intrinsics.checkNotNullExpressionValue(((Object)v6_2), &quot;this as java.lang.String).getBytes(charset)&quot;); if(v1_3.equals(&quot;MHhHYW1le0RvX3kwdV9sMHYzX2FuZHIwMWQ=&quot;)) { // 此处为v1_3的检验逻辑 Object v6_3 = v8_1.invoke(null, arg7.toHexString(v6_2)); // v6_2经过toHexString处理后作为v8_1，即dex:com.example.easyapp.Secret.check的参数 Intrinsics.checkNotNull(v6_3, &quot;null cannot be cast to non-null type kotlin.Boolean&quot;); v6_4 = ((Boolean)v6_3).booleanValue(); // v8_1的返回值流向v6_4 } else { v6_4 = false; } if(v6_4) { // v6_4决定了最后的输出：Right/Oh no no Toast.makeText(((Context)arg7), &quot;Right!&quot;, 0).show(); return; } Toast.makeText(((Context)arg7), &quot;Oh no no&quot;, 0).show(); return; } Toast.makeText(((Context)arg7), &quot;Length wrong!&quot;, 0).show(); } private final String toHexString(byte[] arg11) { return ArraysKt.joinToString$default(arg11, &quot;&quot;, null, null, 0, null, ((Function1)MainActivity.toHexString.1.INSTANCE), 30, null); }} 可以看到，flag被拆分成两部分进行检验，前26个字符经过base64编码后与”MHhHYW1le0RvX3kwdV9sMHYzX2FuZHIwMWQ=”比对，剩下部分由dex中的com.example.easyapp.Secret.check方法检验。第一部分可以借助CyberChef解密： 现在来分析flag第二部分的检验。在JEB左上角工程浏览器中找到asset/dex.zip/dex.bin Secret类解析后得到： 其中check的逻辑等价为一个三元一次大数方程组，三个元从flag的第二部分截取： v0 = substring(flagPart2[0:16])v3 = substring(flagPart2[8:24])v4 = substring(flagPart2:[16:32]) v3 + 3 * v0 - 27454419028250566601 = 02 * v4 - 5 * v3 + 20616666104378640363 = 0v0 + 4 * v4 - 0x1dce62be9f0fa2f6c = 0 可以使用z3求解。解密脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from z3 import *&quot;&quot;&quot;v0 v3 v4分别存放[0:16],[8:24],[16:32]下标的字符，BigInteger将这些字符转成十六进制数，每个十六进制数4位，所以每个变量是64位需要关注两两变量之间有32位的重叠所以可以将三个64位变量分成4个32位变量来处理&quot;&quot;&quot;# 定义4个32位变量u=BitVec('u',32) # v0的高32位v=BitVec('v',32) # v0的低32位，也是v3的高32位w=BitVec('w',32) # v3的低32位，也是v4的高32位t=BitVec('t',32) # v4的低32位# 通过拼接32位变量构造64位变量v0=Concat(u,v) #v0=u&lt;&lt;32|vv3=Concat(v,w) #v3=v&lt;&lt;32|wv4=Concat(w,t) #v4=w&lt;&lt;32|t#定义常量A=BitVecVal(27454419028250566601,64)B=BitVecVal(-20616666104378640363,64)C=BitVecVal(0x1dce62be9f0fa2f6c,64)#建立约束s=Solver()s.add(v3+3*v0==A)s.add(2*v4-5*v3==B)s.add(v0+4*v4==C)if s.check()==unsat: print(&quot;无解&quot;)while s.check()==sat: model=s.model() u_val=model[u].as_long() v_val=model[v].as_long() w_val=model[w].as_long() t_val=model[t].as_long() print(f&quot;found solution:&quot;) print(f&quot;u: {u_val:08x}&quot;) print(f&quot;v: {v_val:08x}&quot;) print(f&quot;w: {w_val:08x}&quot;) print(f&quot;t: {t_val:08x}&quot;) # 将32位变量还原成字符 result=(u_val&lt;&lt;96)|(v_val&lt;&lt;64)|(w_val&lt;&lt;32)|t_val hex_str=f&quot;{result:032x}&quot; flag_bytes=bytes.fromhex(hex_str) flag=flag_bytes.decode('utf-8') print(f&quot;flag: {flag}&quot;) #排除已有的解 s.add(Or(u!=u_val,v!=v_val,w!=w_val,t!=t_val)) &quot;&quot;&quot;found solution:u: 5f346e64v: 5f646578w: 5f6c6f61t: 6465727dflag: _4nd_dex_loader}&quot;&quot;&quot; flag：0xGame{Do_y0u_l0v3_andr01d_4nd_dex_loader} Minesweepr 考点：web逆向、js逆向 附件是html文件和js文件，推测是一个web逆向题。html打开是一个扫雷游戏网页。因为js主要用来处理网页交互，所以重点关注js文件的内容 网页按F12打开开发人员工具，可以在工具栏源代码模块看js脚本。搜索”flag”可以找到一个可疑的函数： 这里函数名和变量名都不是有意义的，不好阅读，可以双击高亮来追踪数据流。 分析可以发现，0x55ea57被调用了很多次，追踪这个值可以到达0x183c，这个函数负责从0xca50中加载值返回，这算是一个全局的混淆手段了 根据0x183c的代码可以找到0xca50的字符串表0x1193d5，表中就可以索引出密钥winModal:message2：”WebIsInteresting”了，以及密文”g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P}^}\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e”（0x183c的索引算法有点奇怪，好像索引不到正确的位置上，没搞懂） 而0x172ca4的解密逻辑可以等价如下： 12for i in range(len(enc)): flag+=enc[i]^key[i%len(key)] 因此可以得到解密脚本： 123456enc=&quot;g\\x1d%(\\x1e,\\x15@SA\\x5cFD\\x0fWJn]P}^}\\x0c\\x12\\x07_]AGYC^o\\x04\\x00yA-ZGT\\x16U\\x0e&quot;key=&quot;WebIsInteresting&quot;flag=&quot;&quot;for i in range(len(enc)): flag+=chr(ord(enc[i])^ord(key[i%len(key)]))print(flag) flag：0xGame{463950f9-9824-4bfb-8230-98ab02d431d0} ezVBS 考点：VBS逆向、VBS去混淆 附件程序是个VBS文件，运行显示： 用记事本打开VBS会发现是一堆奇怪的字符，查了一下说是加了混淆 参考VBS代码混淆，可以使用去混淆脚本进行去混淆，使用方法见链接： 12345678910111213141516171819202122232425Option Explicit Function Defuscator(vbs) Dim t t = InStr(1, vbs, &quot;Execute&quot;, 1) t = Mid(vbs, t + Len(&quot;Execute&quot;)) t = Eval(t) Defuscator = tEnd Function Dim fso, iConst ForReading = 1Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)For i = 0 To WScript.Arguments.Count - 1 Dim FileName FileName = WScript.Arguments(i) Dim MyFile Set MyFile = fso.OpenTextFile(FileName, ForReading) Dim vbs vbs = MyFile.ReadAll WScript.Echo Defuscator(vbs) MyFile.CloseNext Set fso = Nothing 然后可以得到如下的代码： 12345678910Microsoft (R) Windows Script Host Version 5.812版权所有(C) Microsoft Corporation。保留所有权利。code = &quot;Function l(str):Dim i,j,k,r:j=Len(str):r=&quot;&quot;&quot;&quot;:For i=1 to j:k=Asc(Mid(str,i,1)):If k&gt;=33 And k&lt;=126 Then:r=r&amp;Chr(33+((k+14)Mod 94)):Else:r=r&amp;Chr(k):End If:Next:l=r:End Function:Execute l(&quot;&quot;DEC l x?AFEq@IWQt?E6C J@FC &gt;6DD286i QX i q2D6ec%23=6 l Q7Ie{&amp;*d2Eh=?H&gt;5b%3BKF#JZp:A(w!s@)+z|uvr'ax^&quot;&quot;&quot;&quot;;$C6tD9`g}y&lt;8_Gfc~4qQ i 7=28 l QH2+2pJ}vsyhrH{7}5K*r?J&amp;DpyE$&gt;{&amp;_HB}z&gt;{*u?J%g:J#|:d&amp;tp|w_52glQ i 6?4 l QQ i u@C : l ` %@ {6?WDECX $E6A b i :7 : Z a kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade Z pD4W|:5WDEC[ : Z a[ `XX i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 4c l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt;X |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U 4c i t=D6 i x7 : Z ` kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U QlQ i t=D6 i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U QlQ U QlQ i t?5 x7 i t?5 x7 i }6IE i xu 6?4 l 7=28 %96? i |D8q@I Q*@FC 7=28 :D 4@CC64EPQ i t=D6 i |D8q@I Q*@FC 7=28 :D :?4@CC64EPQ i t?5 x7&quot;&quot;)&quot;Execute codecode = &quot;Function l(str):Dim i,j,k,r:j=Len(str):r=&quot;&quot;&quot;&quot;:For i=1 to j:k=Asc(Mid(str,i,1)):If k&gt;=33 And k&lt;=126 Then:r=r&amp;Chr(33+((k+14)Mod 94)):Else:r=r&amp;Chr(k):End If:Next:l=r:End Function:Execute l(&quot;&quot;DEC l x?AFEq@IWQt?E6C J@FC 7=28i QX i q2D6ec%23=6 l QeHB)IvGyC%c~&quot;&quot;&quot;&quot;&gt;}twp^h@fg'qZ`=+#s4EdAFa2(_5Du{Jr$86;z79&amp;:x|*!&lt;Kb?3Q i 7=28 l Q^^H5q'Z2CGvJ+(fdZyaE#:vz=(faCy28#^H$=xwE#GKE+_f$CvZB@zHa`'%2qxpJs^6Esgb&amp;+AHF=:&amp;6#'p2+AHD+zHJ`gr2=yaE#GKEq(@Eq'p9qg&gt;{ZgwEq(fFq'f7Z^H8ZAH9`G27~BHu#'&gt;9CGv7Cy28#'CEZ(;dZzH5q'&quot;&quot;&quot;&quot;Eq(f2=AH8#(fz#x%D#yp2=EllQ i 6?4 l QQ i u@C : l ` %@ {6?WDECX $E6A b i :7 : Z a kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade Z pD4W|:5WDEC[ : Z a[ `XX i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 4c l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt;X |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U 4c i t=D6 i x7 : Z ` kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U QlQ i t=D6 i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U QlQ U QlQ i t?5 x7 i t?5 x7 i }6IE i xu 6?4 l 7=28 %96? i |D8q@I DEC i t=D6 i |D8q@I Q*@FC 7=28 :D :?4@CC64EPQ i |D8q@I 6?4 i t?5 x7&quot;&quot;)&quot;Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)strScriptPath = WScript.ScriptFullNamestrTextToWrite = codeobjFSO.OpenTextFile(strScriptPath, 2, True).WriteLine(strTextToWrite) 可以看到code中有一些可读明文，后面又是一大串奇怪的字符。推测还有一层混淆，可读明文即为解密函数。让AI给出解密脚本： 1234567891011121314151617181920212223242526def l(encrypted_str): &quot;&quot;&quot;VBScript l 函数的 Python 实现&quot;&quot;&quot; result = &quot;&quot; for i in range(len(encrypted_str)): k = ord(encrypted_str[i]) if 33 &lt;= k &lt;= 126: # 与 VBScript 相同的算法 result += chr(33 + ((k + 14) % 94)) else: result += chr(k) return result# 你的加密字符串encrypted_strings = [ &quot;DEC l x?AFEq@IWQt?E6C J@FC &gt;6DD286i QX i q2D6ec%23=6 l Q7Ie{&amp;*d2Eh=?H&gt;5b%3BKF#JZp:A(w!s@)+z|uvr'ax^\\&quot;\\&quot;\\&quot;\\&quot;;$C6tD9`g}y&lt;8_Gfc~4qQ i 7=28 l QH2+2pJ}vsyhrH{7}5K*r?J&amp;DpyE$&gt;{&amp;_HB}z&gt;{*u?J%g:J#|:d&amp;tp|w_52glQ i 6?4 l QQ i u@C : l ` %@ {6?WDECX $E6A b i :7 : Z a kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade Z pD4W|:5WDEC[ : Z a[ `XX i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 4c l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt;X |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U 4c i t=D6 i x7 : Z ` kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U QlQ i t=D6 i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U QlQ U QlQ i t?5 x7 i t?5 x7 i }6IE i xu 6?4 l 7=28 %96? i |D8q@I Q*@FC 7=28 :D 4@CC64EPQ i t=D6 i |D8q@I Q*@FC 7=28 :D :?4@CC64EPQ i t?5 x7&quot;, &quot;DEC l x?AFEq@IWQt?E6C J@FC 7=28i QX i q2D6ec%23=6 l QeHB)IvGyC%c~\\&quot;\\&quot;\\&quot;\\&quot;&gt;}twp^h@fg'qZ`=+#s4EdAFa2(_5Du{Jr$86;z79&amp;:x|*!&lt;Kb?3Q i 7=28 l Q^^H5q'Z2CGvJ+(fdZyaE#:vz=(faCy28#^H$=xwE#GKE+_f$CvZB@zHa`'%2qxpJs^6Esgb&amp;+AHF=:&amp;6#'p2+AHD+zHJ`gr2=yaE#GKEq(@Eq'p9qg&gt;{ZgwEq(fFq'f7Z^H8ZAH9`G27~BHu#'&gt;9CGv7Cy28#'CEZ(;dZzH5q'\\&quot;\\&quot;\\&quot;\\&quot;Eq(f2=AH8#(fz#x%D#yp2=EllQ i 6?4 l QQ i u@C : l ` %@ {6?WDECX $E6A b i :7 : Z a kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade Z pD4W|:5WDEC[ : Z a[ `XX i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 4c l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt;X |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U 4c i t=D6 i x7 : Z ` kl {6?WDECX %96? i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade Z pD4W|:5WDEC[ : Z `[ `XX Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 4b l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - ecX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U 4b U QlQ i t=D6 i 3:Eq=@4&lt; l pD4W|:5WDEC[ :[ `XX Y ade Y ade i 4` l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ec Y ecXX |@5 ec Z `[ `X i 4a l |:5Wq2D6ec%23=6[ x?EW3:Eq=@4&lt; - Wec Y ecXX |@5 ec Z `[ `X i 6?4 l 6?4 U 4` U 4a U QlQ U QlQ i t?5 x7 i t?5 x7 i }6IE i xu 6?4 l 7=28 %96? i |D8q@I DEC i t=D6 i |D8q@I Q*@FC 7=28 :D :?4@CC64EPQ i |D8q@I 6?4 i t?5 x7&quot;]# 解密并显示结果for i, encrypted in enumerate(encrypted_strings, 1): print(f&quot;解密第 {i} 个字符串:&quot;) decrypted = l(encrypted) print(decrypted) print(&quot;\\n&quot; + &quot;=&quot; * 80 + &quot;\\n&quot;) 输出： 123456789解密第 1 个字符串:str = InputBox(&quot;Enter your message: &quot;) : Base64Table = &quot;fx6LUY5at9lnwmd3TbqzuRy+AipWHPDoXZKMFGCV2I/QQQQjSreEsh18NJkg0v74OcB&quot; : flag = &quot;waZaAyNGDJ9CwLfNdzYCnyUsAJtSmLU0wqNKmLYFnyT8iyRMi5UEAMH0da8=&quot; : enc = &quot;&quot; : For i = 1 To Len(str) Step 3 : if i + 2 &lt;= Len(str) Then : bitBlock = Asc(Mid(str, i, 1)) * 256 * 256 + Asc(Mid(str, i + 1, 1)) * 256 + Asc(Mid(str, i + 2, 1)) : c1 = Mid(Base64Table, Int(bitBlock \\ (64 * 64 * 64)) Mod 64 + 1, 1) : c2 = Mid(Base64Table, Int(bitBlock \\ (64 * 64)) Mod 64 + 1, 1) : c3 = Mid(Base64Table, Int(bitBlock \\ 64) Mod 64 + 1, 1) : c4 = Mid(Base64Table, Int(bitBlock) Mod 64 + 1, 1) : enc = enc &amp; c1 &amp; c2 &amp; c3 &amp; c4 : Else : If i + 1 &lt;= Len(str) Then : bitBlock = Asc(Mid(str, i, 1)) * 256 * 256 + Asc(Mid(str, i + 1, 1)) * 256 : c1 = Mid(Base64Table, Int(bitBlock \\ (64 * 64 * 64)) Mod 64 + 1, 1) : c2 = Mid(Base64Table, Int(bitBlock \\ (64 * 64)) Mod 64 + 1, 1) : c3 = Mid(Base64Table, Int(bitBlock \\ 64) Mod 64 + 1, 1) : enc = enc &amp; c1 &amp; c2 &amp; c3 &amp; &quot;=&quot; : Else : bitBlock = Asc(Mid(str, i, 1)) * 256 * 256 : c1 = Mid(Base64Table, Int(bitBlock \\ (64 * 64 * 64)) Mod 64 + 1, 1) : c2 = Mid(Base64Table, Int(bitBlock \\ (64 * 64)) Mod 64 + 1, 1) : enc = enc &amp; c1 &amp; c2 &amp; &quot;=&quot; &amp; &quot;=&quot; : End If : End If : Next : IF enc = flag Then : MsgBox &quot;Your flag is correct!&quot; : Else : MsgBox &quot;Your flag is incorrect!&quot; : End If================================================================================解密第 2 个字符串:str = InputBox(&quot;Enter your flag: &quot;) : Base64Table = &quot;6wqXxGvJrT4OQQQQmNEHA/9o78VB+1lZRDct5pu2aW0dsFLyCSgejKfhUiIMYPkz3nb&quot; : flag = &quot;//wdBV+arvGyZW75+J2tRiGKlW72rJagR/wSlIHtRvztZ07SrG+qoKw21VTaBIAyD/etD83UZpwuliUeRVAaZpwsZKwy18CalJ2tRvztBWotBVAhB8mL+8HtBW7uBV7f+/wg+pwh1vafOqwFRVmhrvGfrJagRVrt+Wj5+KwdBVQQQQtBW7alpwgRW7KRITsRJAalt==&quot; : enc = &quot;&quot; : For i = 1 To Len(str) Step 3 : if i + 2 &lt;= Len(str) Then : bitBlock = Asc(Mid(str, i, 1)) * 256 * 256 + Asc(Mid(str, i + 1, 1)) * 256 + Asc(Mid(str, i + 2, 1)) : c1 = Mid(Base64Table, Int(bitBlock \\ (64 * 64 * 64)) Mod 64 + 1, 1) : c2 = Mid(Base64Table, Int(bitBlock \\ (64 * 64)) Mod 64 + 1, 1) : c3 = Mid(Base64Table, Int(bitBlock \\ 64) Mod 64 + 1, 1) : c4 = Mid(Base64Table, Int(bitBlock) Mod 64 + 1, 1) : enc = enc &amp; c1 &amp; c2 &amp; c3 &amp; c4 : Else : If i + 1 &lt;= Len(str) Then : bitBlock = Asc(Mid(str, i, 1)) * 256 * 256 + Asc(Mid(str, i + 1, 1)) * 256 : c1 = Mid(Base64Table, Int(bitBlock \\ (64 * 64 * 64)) Mod 64 + 1, 1) : c2 = Mid(Base64Table, Int(bitBlock \\ (64 * 64)) Mod 64 + 1, 1) : c3 = Mid(Base64Table, Int(bitBlock \\ 64) Mod 64 + 1, 1) : enc = enc &amp; c1 &amp; c2 &amp; c3 &amp; &quot;=&quot; : Else : bitBlock = Asc(Mid(str, i, 1)) * 256 * 256 : c1 = Mid(Base64Table, Int(bitBlock \\ (64 * 64 * 64)) Mod 64 + 1, 1) : c2 = Mid(Base64Table, Int(bitBlock \\ (64 * 64)) Mod 64 + 1, 1) : enc = enc &amp; c1 &amp; c2 &amp; &quot;=&quot; &amp; &quot;=&quot; : End If : End If : Next : IF enc = flag Then : MsgBox str : Else : MsgBox &quot;Your flag is incorrect!&quot; : MsgBox enc : End If================================================================================ 解密出来是两段代码。但是代码给的base表不是很对，第2段代码中删除base表中间连续QQQQ的几个可以解密出一些类似提示的东西 第1段代码的编码表进行同样的修改就得到了flag： flag：0xGame{bf00591f-a1cb-4191-b41d-d4eecda0b798} World’s_end_BlackBox 考点：动态调试、魔改RC4算法 附件程序运行如图： 用IDA打开，main函数由于类的影响不好分析，先进行简单的变量名优化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194int __fastcall main(int argc, const char **argv, const char **envp){ __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax __int64 v6; // rax __int64 v7; // rax __int64 v8; // rax __int64 v9; // rax __int64 v10; // rax __int64 v11; // rax std::string::iterator __for_end; // [rsp+20h] [rbp-60h] BYREF std::string::iterator __for_begin; // [rsp+28h] [rbp-58h] BYREF std::vector&lt;int&gt; EndFlag; // [rsp+30h] [rbp-50h] BYREF std::string encrypted_message; // [rsp+50h] [rbp-30h] BYREF std::string key; // [rsp+70h] [rbp-10h] BYREF std::string flag; // [rsp+90h] [rbp+10h] BYREF std::string v19; // [rsp+B0h] [rbp+30h] BYREF std::vector&lt;int&gt;::value_type __x; // [rsp+D0h] [rbp+50h] BYREF char c; // [rsp+D7h] [rbp+57h] std::string *__for_range; // [rsp+D8h] [rbp+58h] _main(argc, argv, envp); SetConsoleOutputCP(0xFDE9u); basicString((__int64)&amp;flag); basicString((__int64)&amp;key); v3 = operateOut(pOut, &amp;unk_408078); stdOut(v3, out); v4 = operateOut(pOut, &amp;unk_408160); stdOut(v4, out); getLine(pIn, &amp;key); // 获取密码 if ( getLength(&amp;key) != 12 ) // 长度判断 { v5 = operateOut(pOut, &quot;Length Error!&quot;); stdOut(v5, out); system(&quot;pause&quot;); exit(0); } KeyGenerate(&amp;v19, &amp;KeyEnc[abi:cxx11], &amp;DeKey[abi:cxx11]);// key的生成算法 std::string::operator=(&amp;TrueKey[abi:cxx11], &amp;v19); std::string::~string(&amp;v19); if ( std::operator!=&lt;char&gt;(&amp;key, &amp;TrueKey[abi:cxx11]) )// 出现了检验逻辑，可以从这里直接获取到真正的key { v6 = operateOut(pOut, &amp;unk_4081A2); // key错误时的输出 stdOut(v6, out); system(&quot;pause&quot;); exit(0); } v7 = operateOut(pOut, &amp;Congratulation); // key正确时的输出 stdOut(v7, out); v8 = operateOut(pOut, &amp;unk_408212); stdOut(v8, out); getLine(pIn, &amp;flag); // 获取flag的输入 if ( getLength(&amp;flag) != 51 ) { v9 = operateOut(pOut, &quot;Length Error!&quot;); stdOut(v9, out); system(&quot;pause&quot;); exit(0); } encrypt(&amp;encrypted_message, &amp;flag, &amp;key); // 加密算法，密钥即为前文的key std::vector&lt;int&gt;::vector(&amp;EndFlag); __for_range = &amp;encrypted_message; __for_begin._M_current = (char *)std::string::begin(&amp;encrypted_message); __for_end._M_current = (char *)std::string::end(__for_range); while ( __gnu_cxx::operator!=&lt;char *,std::string&gt;(&amp;__for_begin, &amp;__for_end) ) { c = *__gnu_cxx::__normal_iterator&lt;char *,std::string&gt;::operator*(&amp;__for_begin); __x = (unsigned __int8)c; std::vector&lt;int&gt;::push_back(&amp;EndFlag, &amp;__x); __gnu_cxx::__normal_iterator&lt;char *,std::string&gt;::operator++(&amp;__for_begin); } if ( std::operator==&lt;int,std::allocator&lt;int&gt;&gt;(&amp;KALEIDXSCOPE, &amp;EndFlag) )// 检验加密结果 { v10 = operateOut(pOut, &quot;All Perfect!&quot;); stdOut(v10, out); system(&quot;pause&quot;); exit(0); } v11 = operateOut(pOut, &quot;Try again!&quot;); stdOut(v11, out); std::vector&lt;int&gt;::~vector(&amp;EndFlag); std::string::~string(&amp;encrypted_message); std::string::~string(&amp;key); std::string::~string(&amp;flag); return 0;}//加密函数std::string *__cdecl modifiedRC4(std::string *__return_ptr retstr, const std::string *plaintext, const std::string *key){ size_t v3; // rax size_t length; // rax char v5; // bl std::vector&lt;int&gt;::reference List; // rax __int64 v8; // [rsp+0h] [rbp-80h] BYREF std::vector&lt;int&gt; k; // [rsp+20h] [rbp-60h] BYREF std::vector&lt;int&gt; s; // [rsp+40h] [rbp-40h] BYREF std::allocator&lt;int&gt; __a; // [rsp+66h] [rbp-1Ah] BYREF char v12; // [rsp+67h] [rbp-19h] BYREF size_t i; // [rsp+68h] [rbp-18h] std::allocator&lt;int&gt;::allocator((std::allocator&lt;int&gt; *const)&amp;v8 + 102); std::vector&lt;int&gt;::vector(&amp;s, 0x100uLL, &amp;__a); std::allocator&lt;int&gt;::~allocator(&amp;__a); rc4_ksa(&amp;s, key); // RC4密钥调度算法 v3 = std::string::size(plaintext); rc4_prga(&amp;k, &amp;s, v3); // RC4伪随机数生成算法 std::allocator&lt;char&gt;::allocator(&amp;v12); std::string::basic_string(retstr, &amp;unk_408037, &amp;v12); std::allocator&lt;char&gt;::~allocator(&amp;v12); for ( i = 0LL; ; ++i ) { length = std::string::size(plaintext); if ( i &gt;= length ) break; v5 = *(_BYTE *)StrMakeList(plaintext, i); List = IntMakeList(&amp;k, i); std::string::operator+=(retstr, (unsigned int)(char)(v5 ^ *(_BYTE *)List ^ 7));// 魔改的地方在这 } std::vector&lt;int&gt;::~vector(&amp;k); std::vector&lt;int&gt;::~vector(&amp;s); return retstr;}//密钥调度算法void __cdecl rc4_ksa(std::vector&lt;int&gt; *s, const std::string *key){ int *M_current; // rbx std::vector&lt;int&gt;::iterator v3; // rax int v4; // ebx unsigned __int64 v5; // rdx _BYTE *List; // rax char v7; // dl int *s_j; // rbx int *s_i; // rax size_t i; // [rsp+20h] [rbp-60h] int j; // [rsp+2Ch] [rbp-54h] M_current = std::vector&lt;int&gt;::end(s)._M_current; v3._M_current = std::vector&lt;int&gt;::begin(s)._M_current; std::iota&lt;__gnu_cxx::__normal_iterator&lt;int *,std::vector&lt;int&gt;&gt;,int&gt;( v3, (__gnu_cxx::__normal_iterator&lt;int*,std::vector&lt;int&gt; &gt;)M_current, 0); j = 0; for ( i = 0LL; i &lt;= 255; ++i ) { v4 = *IntMakeList(s, i) + j; v5 = i % getLength(key); List = (_BYTE *)StrMakeList(key, v5); v7 = v4 + *List; LODWORD(List) = (unsigned int)((v4 + (char)*List) &gt;&gt; 31) &gt;&gt; 24; j = (unsigned __int8)((_BYTE)List + v7) - (_DWORD)List; s_j = IntMakeList(s, j); s_i = IntMakeList(s, i); std::swap&lt;int&gt;(s_i, s_j); }}//伪随机数生成算法std::vector&lt;int&gt; *__cdecl rc4_prga(std::vector&lt;int&gt; *__return_ptr retstr, std::vector&lt;int&gt; *s, size_t length){ std::vector&lt;int&gt;::reference v3; // rax int *v4; // rbx int *v5; // rax std::vector&lt;int&gt;::reference v6; // rax const std::vector&lt;int&gt;::value_type *v7; // rax size_t r; // [rsp+30h] [rbp-50h] int j; // [rsp+38h] [rbp-48h] int i; // [rsp+3Ch] [rbp-44h] std::vector&lt;int&gt;::vector(retstr); i = 0; j = 0; for ( r = 0LL; r &lt; length; ++r ) { i = (i + 1) % 256; v3 = IntMakeList(s, i); j = (unsigned __int8)(((unsigned int)((j + *v3) &gt;&gt; 31) &gt;&gt; 24) + j + *(_BYTE *)v3) - ((unsigned int)((j + *v3) &gt;&gt; 31) &gt;&gt; 24); v4 = IntMakeList(s, j); v5 = IntMakeList(s, i); std::swap&lt;int&gt;(v5, v4); LODWORD(v4) = *IntMakeList(s, i); v6 = IntMakeList(s, j); v7 = IntMakeList( s, (int)((unsigned __int8)(((unsigned int)(((int)v4 + *v6) &gt;&gt; 31) &gt;&gt; 24) + (_BYTE)v4 + *(_BYTE *)v6) - ((unsigned int)(((int)v4 + *v6) &gt;&gt; 31) &gt;&gt; 24))); std::vector&lt;int&gt;::push_back(retstr, v7); } return retstr;} 可以看到函数对输入的数据进行了魔改的RC4加密，但实际上没有改变RC4加解密同一个函数的性质，所以解密只需要复现这个代码即可 下面先获取密钥和加密后的flag数据。在main函数第一个getline处下断点，开始动态调试 随便输入一个字符后会到长度检测，要求输入的密码长度要等于12，可以输入12个字符也可以后续到这个cmp的时候改jz绕过 过了长度检测后就可以一直运行到key检验处，双击生成的密钥的变量名(TrueKey)就可以得到真正的key了（从 hex窗口可以看到key即为”XaleidscopiX”） 然后还需要获得真正flag的加密数据。往下绕过key检验，运行到jz的时候再改一下ZF标志位（此处应当跳转） 绕过后终端还有提示 接下来运行到第二个getline，随便输几个数据（有长度检验，最好是输入51个字符，省的绕过长度检验）。然后继续运行到加密结果的检验处 其中KALEIDXSCOPE的第一个offset就是正确的flag加密后的数据 解密脚本： 12345678910111213141516171819202122232425262728293031323334def rc4_decrypt(data, key): S = list(range(256)) j = 0 out = [] # Key-scheduling algorithm (KSA) for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] # Pseudo-random generation algorithm (PRGA) i = 0 j = 0 for char in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) % 256] out.append(K) return outenc=[0x000000FC, 0x000000EA, 0x00000015, 0x0000002C, 0x00000086, 0x00000038, 0x0000003F, 0x000000F3, 0x00000092, 0x000000CE, 0x000000DA, 0x0000008E, 0x00000048, 0x000000D3, 0x00000007, 0x0000009F, 0x000000D9, 0x00000057, 0x000000B1, 0x000000EE, 0x00000041, 0x0000009A, 0x0000004D, 0x000000C5, 0x00000065, 0x0000006A, 0x000000FF, 0x000000C9, 0x0000005D, 0x00000034, 0x000000AD, 0x000000EA, 0x000000B1, 0x00000020, 0x0000004B, 0x000000DC, 0x000000BD, 0x000000D2, 0x00000035, 0x00000002, 0x00000084, 0x00000035, 0x00000071, 0x000000EC, 0x000000E0, 0x00000048, 0x0000008E, 0x000000EA, 0x0000007B, 0x000000AA, 0x000000CF]_key=&quot;XaleidscopiX&quot;key=[]flag=[]for i in _key: key.append(ord(i))#print(key)keystream=rc4_decrypt(enc, key)for i in range(len(enc)): flag.append(enc[i]^keystream[i]^7)print(''.join([chr(i) for i in flag])) flag：0xGame{RC4_15_4_b4s1c&amp;fl3x1bl3_3ncrYp710n4lg0r17hm} Q(≧▽≦)T 考点：QT程序逆向、crackme、动态调试、RC4、哈希校验 附件程序运行如图，是个序列号生成器： 用IDA打开，出现的是start函数， 看不出什么东西来 shift+F12看看字符串表，可以发现两串可疑的字符串 跟踪过去可以找到这样一个函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150void __fastcall sub_140001890(__int64 a1, __int64 a2, __int64 a3, __int64 a4){ volatile signed __int32 *v5; // rax volatile signed __int32 *v6; // [rsp+80h] [rbp-1F8h] BYREF volatile signed __int32 *v7; // [rsp+88h] [rbp-1F0h] volatile signed __int32 *v8; // [rsp+90h] [rbp-1E8h] BYREF volatile signed __int32 *v9; // [rsp+98h] [rbp-1E0h] __int64 Block; // [rsp+A0h] [rbp-1D8h] BYREF const char *v11; // [rsp+A8h] [rbp-1D0h] volatile signed __int32 *v12[4]; // [rsp+B0h] [rbp-1C8h] BYREF volatile signed __int32 *v13[4]; // [rsp+D0h] [rbp-1A8h] BYREF volatile signed __int32 *v14[4]; // [rsp+F0h] [rbp-188h] BYREF volatile signed __int32 *v15; // [rsp+110h] [rbp-168h] BYREF volatile signed __int32 *v16[4]; // [rsp+130h] [rbp-148h] BYREF volatile signed __int32 *v17[2]; // [rsp+150h] [rbp-128h] BYREF volatile signed __int32 *v18; // [rsp+160h] [rbp-118h] __m128i v19[2]; // [rsp+170h] [rbp-108h] BYREF __m128i v20; // [rsp+190h] [rbp-E8h] BYREF volatile signed __int32 *v21[4]; // [rsp+1B0h] [rbp-C8h] BYREF volatile signed __int32 *v22[2]; // [rsp+1D0h] [rbp-A8h] BYREF volatile signed __int32 *v23; // [rsp+1E0h] [rbp-98h] volatile signed __int32 *v24[4]; // [rsp+1F0h] [rbp-88h] BYREF volatile signed __int32 *v25[13]; // [rsp+210h] [rbp-68h] BYREF ((void (__fastcall *)(void *, volatile signed __int32 **, _QWORD, volatile signed __int32 **))QLineEdit::text)( QLineEdit::text, v25, *(_QWORD *)(*(_QWORD *)(a4 + 40) + 16LL), v25); QString::trimmed_helper(QLineEdit::text, v25, v25, v12); if ( v25[0] &amp;&amp; !_InterlockedSub(v25[0], 1u) ) free(QLineEdit::text); ((void (__fastcall *)(void *, volatile signed __int32 **, _QWORD, volatile signed __int32 **))QLineEdit::text)( QLineEdit::text, v25, *(_QWORD *)(*(_QWORD *)(a4 + 40) + 24LL), v13); if ( v12[2] == (volatile signed __int32 *)4 ) { QString::toUtf8_helper(QLineEdit::text, v25, v12, v14); Block = (__int64)v14[2]; v11 = (const char *)v14[1]; QCryptographicHash::hash(&amp;Block, v25, &amp;Block, &amp;v15, 4LL); sub_140001620((__int64)&amp;Block, (__int64)v25, a4, (__int64)v16); Block = 64LL; v11 = &quot;c94201919ec7463313c747d0a27fabcabf1400fa1e9a64d36a6b1a7e7b12ae68&quot;; QString::fromUtf8(&amp;Block, v25, &amp;Block, v17); if ( v18 == v16[2] &amp;&amp; (v8 = v18, v6 = v18, v9 = v16[1], v7 = v17[1], (unsigned __int8)QtPrivate::equalStrings(&amp;Block, v25, &amp;v6, &amp;v8)) ) { QString::toUtf8_helper(&amp;Block, v25, v13, v19); sub_1400016F0((__int64)&amp;Block, (__int64)v25, a4, &amp;v20, v19, (__int64)v14); sub_140001620((__int64)&amp;Block, (__int64)v25, a4, (__int64)v21); Block = 72LL; v11 = &quot;af33da5e152c15863b3a03c87601899a37d51b8b8168f65aca65352d3669e91959300ccb&quot;; QString::fromUtf8(&amp;Block, v25, &amp;Block, v22); if ( v23 == v21[2] &amp;&amp; (v8 = v23, v9 = v21[1], v6 = v23, v7 = v22[1], (unsigned __int8)QtPrivate::equalStrings(&amp;Block, v25, &amp;v6, &amp;v8)) ) { Block = 21LL; v11 = (const char *)&amp;unk_1400061D8; QString::fromUtf8(&amp;Block, v25, &amp;Block, v25); Block = 12LL; v11 = (const char *)&amp;unk_1400061EE; QString::fromUtf8(&amp;Block, v25, &amp;Block, v24); QMessageBox::information(&amp;Block, v25, v24, a4, v25, 1024LL); } else { Block = 22LL; v11 = (const char *)&amp;unk_1400061C1; QString::fromUtf8(&amp;Block, v25, &amp;Block, v25); Block = 12LL; v11 = (const char *)&amp;unk_140006104; QString::fromUtf8(&amp;Block, v25, &amp;Block, v24); QMessageBox::warning(&amp;Block, v25, v24, a4, v25, 1024LL); } if ( v24[0] &amp;&amp; !_InterlockedSub(v24[0], 1u) ) free(&amp;Block); if ( v25[0] &amp;&amp; !_InterlockedSub(v25[0], 1u) ) free(&amp;Block); if ( v22[0] &amp;&amp; !_InterlockedSub(v22[0], 1u) ) free(&amp;Block); if ( v21[0] &amp;&amp; !_InterlockedSub(v21[0], 1u) ) free(&amp;Block); if ( v20.m128i_i64[0] &amp;&amp; !_InterlockedSub((volatile signed __int32 *)v20.m128i_i64[0], 1u) ) free(&amp;Block); if ( !v19[0].m128i_i64[0] || _InterlockedSub((volatile signed __int32 *)v19[0].m128i_i64[0], 1u) ) goto LABEL_45; } else { Block = 25LL; v11 = (const char *)&amp;unk_140006159; QString::fromUtf8(&amp;Block, v25, &amp;Block, v25); Block = 12LL; v11 = (const char *)&amp;unk_140006104; QString::fromUtf8(&amp;Block, v25, &amp;Block, v24); QMessageBox::warning(&amp;Block, v25, v24, a4, v25, 1024LL); if ( v24[0] &amp;&amp; !_InterlockedSub(v24[0], 1u) ) free(&amp;Block); if ( !v25[0] || _InterlockedSub(v25[0], 1u) ) goto LABEL_45; } free(&amp;Block);LABEL_45: if ( v17[0] &amp;&amp; !_InterlockedSub(v17[0], 1u) ) free(&amp;Block); if ( v16[0] &amp;&amp; !_InterlockedSub(v16[0], 1u) ) free(&amp;Block); if ( v15 &amp;&amp; !_InterlockedSub(v15, 1u) ) free(&amp;Block); if ( v14[0] &amp;&amp; !_InterlockedSub(v14[0], 1u) ) free(&amp;Block); goto LABEL_10; } Block = 35LL; v11 = (const char *)&amp;unk_1400060E0; QString::fromUtf8(&amp;Block, v25, &amp;Block, v25); Block = 12LL; v11 = (const char *)&amp;unk_140006104; QString::fromUtf8(&amp;Block, v25, &amp;Block, v24); QMessageBox::warning(&amp;Block, v25, v24, a4, v25, 1024LL); if ( v24[0] &amp;&amp; !_InterlockedSub(v24[0], 1u) ) { free(&amp;Block); v5 = v25[0]; if ( !v25[0] ) goto LABEL_10; } else { v5 = v25[0]; if ( !v25[0] ) goto LABEL_10; } if ( !_InterlockedSub(v5, 1u) ) free(&amp;Block);LABEL_10: if ( v13[0] &amp;&amp; !_InterlockedSub(v13[0], 1u) ) free(&amp;Block); if ( v12[0] ) { if ( !_InterlockedSub(v12[0], 1u) ) free(&amp;Block); }} 程序的图形化界面是QT实现的，引入了QT的很多类，所以阅读难度还是有点大的。借助AI优化一下以及一点点动态调试辅助分析可以得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143void __fastcall check(__int64 a1, __int64 a2, __int64 a3, __int64 mainWindows){ volatile signed __int32 *v5; // rax volatile signed __int32 *v6; // [rsp+80h] [rbp-1F8h] BYREF volatile signed __int32 *v7; // [rsp+88h] [rbp-1F0h] volatile signed __int32 *v8; // [rsp+90h] [rbp-1E8h] BYREF volatile signed __int32 *v9; // [rsp+98h] [rbp-1E0h] __int64 Block; // [rsp+A0h] [rbp-1D8h] BYREF const char *stringData; // [rsp+A8h] [rbp-1D0h] volatile signed __int32 *usernameUtf8[4]; // [rsp+B0h] [rbp-1C8h] BYREF volatile signed __int32 *passwordUtf8[4]; // [rsp+D0h] [rbp-1A8h] BYREF volatile signed __int32 *usernameBytes[4]; // [rsp+F0h] [rbp-188h] BYREF volatile signed __int32 *usernameHash; // [rsp+110h] [rbp-168h] BYREF volatile signed __int32 *usernameHashHex[4]; // [rsp+130h] [rbp-148h] BYREF volatile signed __int32 *v17[2]; // [rsp+150h] [rbp-128h] BYREF volatile signed __int32 *expectedUserHashSize; // [rsp+160h] [rbp-118h] __m128i passwordBytes[2]; // [rsp+170h] [rbp-108h] BYREF __m128i v20; // [rsp+190h] [rbp-E8h] BYREF volatile signed __int32 *v21[4]; // [rsp+1B0h] [rbp-C8h] BYREF volatile signed __int32 *v22[2]; // [rsp+1D0h] [rbp-A8h] BYREF volatile signed __int32 *v23; // [rsp+1E0h] [rbp-98h] volatile signed __int32 *v24[4]; // [rsp+1F0h] [rbp-88h] BYREF volatile signed __int32 *tempBuffer[13]; // [rsp+210h] [rbp-68h] BYREF (QLineEdit::text)(QLineEdit::text, tempBuffer, *(*(mainWindows + 40) + 16LL), tempBuffer); QString::trimmed_helper(QLineEdit::text, tempBuffer, tempBuffer, usernameUtf8); if ( tempBuffer[0] &amp;&amp; !_InterlockedSub(tempBuffer[0], 1u) ) free(QLineEdit::text); (QLineEdit::text)(QLineEdit::text, tempBuffer, *(*(mainWindows + 40) + 24LL), passwordUtf8); if ( usernameUtf8[2] == 4 ) // 长度检验 { QString::toUtf8_helper(QLineEdit::text, tempBuffer, usernameUtf8, usernameBytes); Block = usernameBytes[2]; stringData = usernameBytes[1]; QCryptographicHash::hash(&amp;Block, tempBuffer, &amp;Block, &amp;usernameHash, 4LL);// 求输入的用户名hash toHex(&amp;Block, tempBuffer, mainWindows, usernameHashHex); Block = 64LL; stringData = &quot;c94201919ec7463313c747d0a27fabcabf1400fa1e9a64d36a6b1a7e7b12ae68&quot;;// 预设哈希值 QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, v17); if ( expectedUserHashSize == usernameHashHex[2] &amp;&amp; (v8 = expectedUserHashSize, v6 = expectedUserHashSize, v9 = usernameHashHex[1], v7 = v17[1], QtPrivate::equalStrings(&amp;Block, tempBuffer, &amp;v6, &amp;v8)) )// 用户名检验 { QString::toUtf8_helper(&amp;Block, tempBuffer, passwordUtf8, passwordBytes); RC4(&amp;Block, tempBuffer, mainWindows, &amp;v20, passwordBytes, usernameBytes); toHex(&amp;Block, tempBuffer, mainWindows, v21); Block = 72LL; stringData = &quot;af33da5e152c15863b3a03c87601899a37d51b8b8168f65aca65352d3669e91959300ccb&quot;; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, v22); if ( v23 == v21[2] &amp;&amp; (v8 = v23, v9 = v21[1], v6 = v23, v7 = v22[1], QtPrivate::equalStrings(&amp;Block, tempBuffer, &amp;v6, &amp;v8)) )// 验证通过 { Block = 21LL; stringData = &amp;unk_7FF7F2EB61D8; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, tempBuffer); Block = 12LL; stringData = &amp;unk_7FF7F2EB61EE; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, v24); QMessageBox::information(&amp;Block, tempBuffer, v24, mainWindows, tempBuffer, 1024LL); } else // 密码验证不通过 { Block = 22LL; stringData = &amp;unk_7FF7F2EB61C1; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, tempBuffer); Block = 12LL; stringData = &amp;unk_7FF7F2EB6104; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, v24); QMessageBox::warning(&amp;Block, tempBuffer, v24, mainWindows, tempBuffer, 1024LL); } if ( v24[0] &amp;&amp; !_InterlockedSub(v24[0], 1u) ) free(&amp;Block); if ( tempBuffer[0] &amp;&amp; !_InterlockedSub(tempBuffer[0], 1u) ) free(&amp;Block); if ( v22[0] &amp;&amp; !_InterlockedSub(v22[0], 1u) ) free(&amp;Block); if ( v21[0] &amp;&amp; !_InterlockedSub(v21[0], 1u) ) free(&amp;Block); if ( v20.m128i_i64[0] &amp;&amp; !_InterlockedSub(v20.m128i_i64[0], 1u) ) free(&amp;Block); if ( !passwordBytes[0].m128i_i64[0] || _InterlockedSub(passwordBytes[0].m128i_i64[0], 1u) ) goto LABEL_45; } else // 用户名验证不通过 { Block = 25LL; stringData = &amp;unk_7FF7F2EB6159; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, tempBuffer); Block = 12LL; stringData = &amp;unk_7FF7F2EB6104; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, v24); QMessageBox::warning(&amp;Block, tempBuffer, v24, mainWindows, tempBuffer, 1024LL); if ( v24[0] &amp;&amp; !_InterlockedSub(v24[0], 1u) ) free(&amp;Block); if ( !tempBuffer[0] || _InterlockedSub(tempBuffer[0], 1u) ) goto LABEL_45; } free(&amp;Block);LABEL_45: if ( v17[0] &amp;&amp; !_InterlockedSub(v17[0], 1u) ) free(&amp;Block); if ( usernameHashHex[0] &amp;&amp; !_InterlockedSub(usernameHashHex[0], 1u) ) free(&amp;Block); if ( usernameHash &amp;&amp; !_InterlockedSub(usernameHash, 1u) ) free(&amp;Block); if ( usernameBytes[0] &amp;&amp; !_InterlockedSub(usernameBytes[0], 1u) ) free(&amp;Block); goto LABEL_10; } Block = 35LL; stringData = &amp;unk_7FF7F2EB60E0; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, tempBuffer); Block = 12LL; stringData = &amp;unk_7FF7F2EB6104; QString::fromUtf8(&amp;Block, tempBuffer, &amp;Block, v24); QMessageBox::warning(&amp;Block, tempBuffer, v24, mainWindows, tempBuffer, 1024LL); if ( v24[0] &amp;&amp; !_InterlockedSub(v24[0], 1u) ) { free(&amp;Block); v5 = tempBuffer[0]; if ( !tempBuffer[0] ) goto LABEL_10; } else { v5 = tempBuffer[0]; if ( !tempBuffer[0] ) goto LABEL_10; } if ( !_InterlockedSub(v5, 1u) ) free(&amp;Block);LABEL_10: if ( passwordUtf8[0] &amp;&amp; !_InterlockedSub(passwordUtf8[0], 1u) ) free(&amp;Block); if ( usernameUtf8[0] ) { if ( !_InterlockedSub(usernameUtf8[0], 1u) ) free(&amp;Block); }} 可以看到用户名采用的是哈希检验，密码采用的是RC4检验，密钥为用户名。 密码检验套在用户名检验里，所以第一步先解出用户名。借助在线解密网站MD5 在線免費解密可以得到用户名”Kath”： 接下来求解密码。RC4函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889__m128i *__fastcall RC4( __int64 a1, __int64 a2, __int64 a3, __m128i *a4, const __m128i *passwordBytes, __int64 usernameBytes){ volatile signed __int32 *v6; // rax __int64 v7; // rdx bool v8; // zf int keyLength; // r11d int *sBoxPtr; // r8 __m128i initVal; // xmm0 __m128i *sBoxInitPtr; // rax __m128i v15; // xmm2 __m128i currentVal; // xmm1 __int64 keyBytes; // rdi int i_ksa; // ecx int j_ksa; // r9d int v20; // eax int sBoxVal; // r10d __int64 sum; // kr00_8 __int64 passwordIndex; // r12 int j; // ebp __int64 i; // rdi int temp; // eax __int64 v27; // kr08_8 char v28; // r14 _DWORD S[256]; // [rsp+20h] [rbp-438h] BYREF char v31; // [rsp+420h] [rbp-38h] BYREF v6 = passwordBytes-&gt;m128i_i64[0]; v7 = passwordBytes[1].m128i_i64[0]; v8 = passwordBytes-&gt;m128i_i64[0] == 0; *a4 = _mm_loadu_si128(passwordBytes); a4[1].m128i_i64[0] = v7; if ( !v8 ) _InterlockedAdd(v6, 1u); keyLength = *(usernameBytes + 16); sBoxPtr = S; initVal = _mm_load_si128(&amp;xmmword_7FF7F2EB6200); sBoxInitPtr = S; v15 = _mm_load_si128(&amp;xmmword_7FF7F2EB6210); do { currentVal = initVal; ++sBoxInitPtr; initVal = _mm_add_epi32(initVal, v15); sBoxInitPtr[-1] = currentVal; } while ( sBoxInitPtr != &amp;v31 ); keyBytes = *(usernameBytes + 8); i_ksa = 0; j_ksa = 0; do // RC4_KSA { v20 = i_ksa; sBoxVal = *sBoxPtr; ++i_ksa; ++sBoxPtr; sum = sBoxVal + j_ksa + *(keyBytes + v20 % keyLength); j_ksa = (HIBYTE(sum) + sum) - HIBYTE(HIDWORD(sum));// j = j % 256 *(sBoxPtr - 1) = S[j_ksa]; S[j_ksa] = sBoxVal; } while ( i_ksa != 256 ); if ( passwordBytes[1].m128i_i64[0] &gt; 0 ) // RC4_PRGA和RC4decrypt { passwordIndex = 0LL; j = 0; LODWORD(i) = 0; do { i = ((i + 1) % 256); temp = S[i]; j = (temp + j) % 256; S[i] = S[j]; S[j] = temp; v27 = S[i] + temp; v28 = *(passwordBytes-&gt;m128i_i64[1] + passwordIndex) ^ S[(HIBYTE(v27) + v27) - HIBYTE(HIDWORD(v27))];// v28 = passwordBytes[passwordIndex] ^ S[(S[i]+S[j])%256] if ( !a4-&gt;m128i_i64[0] || *a4-&gt;m128i_i64[0] &gt; 1 ) QByteArray::reallocData(i, passwordBytes, a4[1].m128i_i64[0], a4, 1LL, *initVal.m128i_i64); *(a4-&gt;m128i_i64[1] + passwordIndex++) = v28; } while ( passwordBytes[1].m128i_i64[0] &gt; passwordIndex ); } return a4;} 可以看出是标准的RC4，直接复现加密函数即可。解密脚本： 12345678910111213141516171819202122232425262728293031323334353637def rc4_ksa(key): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] return Sdef rc4_prga(S, n): i = j = 0 keystream = [] S = S[:] # copy for _ in range(n): i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = S[(S[i] + S[j]) % 256] keystream.append(k) return bytes(keystream)def rc4_decrypt(key, ciphertext): S = rc4_ksa(key) ks = rc4_prga(S, len(ciphertext)) return bytes(c ^ k for c, k in zip(ciphertext, ks))key = b&quot;Kath&quot;cipher = &quot;af33da5e152c15863b3a03c87601899a37d51b8b8168f65aca65352d3669e91959300ccb&quot;# 转成bytesciphertext = bytes.fromhex(cipher)# 解密plaintext = rc4_decrypt(key, ciphertext)# 输出print(&quot;Plaintext:&quot;, plaintext) flag：0xGame{ce5e5621-3d6b-4429-b72a-957abf353390} Calamity_Fortune 这题，哈哈，数据提取错了题目截止提交48分钟后我才发现这个问题解出flag😄🫠我永远都不会原谅我自己了😄哈哈哈哈 考点：函数重写、复杂加密算法逆向、动态调试绕过程序机制 附件程序双击运行会提示如图 然而，随便输一个数字的话会闪退 程序用IDA打开，main函数反编译如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int __fastcall main(int argc, const char **argv, const char **envp){ unsigned int v3; // eax int v4; // ebx int v5; // eax int v6; // ecx __int64 v7; // rbx char v8; // cl int v10; // [rsp+20h] [rbp-58h] BYREF char v11[9]; // [rsp+27h] [rbp-51h] BYREF _QWORD v12[5]; // [rsp+30h] [rbp-48h] int v13; // [rsp+58h] [rbp-20h] __int16 v14; // [rsp+5Ch] [rbp-1Ch] sub_401600(argc, argv, envp); SetConsoleOutputCP(0xFDE9u); SetConsoleCP(0xFDE9u); v3 = time64(0LL); srand(v3); v10 = 0; v4 = rand(); puts(&amp;Buffer); v5 = scanf(&quot;%d&quot;, &amp;v10); v6 = 1; if ( v5 == 1 ) { if ( v10 == v4 % 100 + 1 ) { MessageBoxA(0LL, &quot;You guessed right! Is it really right?&quot;, &quot;Result&quot;, 0); return 0; } else { v7 = 0LL; puts(&quot;You guessed it wrong!&quot;); puts(&amp;byte_405098); v12[0] = 0xD0F0C00002B1973LL; v12[1] = 0x182B1A043E1F082BLL; v12[2] = 0x151236080A0D071CLL; v12[3] = 0xA150C0111330622LL; v12[4] = 0xD2B190804073E26LL; v13 = 251992113; v14 = 5130; strcpy(v11, &quot;Calamity&quot;); do { v8 = *((_BYTE *)v12 + v7) ^ v11[v7 &amp; 7]; ++v7; putchar(v8); } while ( v7 != 46 ); return 0; } } return v6;} v12看着像密文，的确是密文，但不是flag的密文，因为它在输入错误的提示里。暂时没有发现flag检验函数，尝试先绕过数字检验 在汇编窗口找到数字判断语句（可以在反编译界面选中判断语句所在行，右键Jump to Disasm到达） 可以看到这是一个jz，只需要在执行到这句但是还没步过时，修改ZF标志位即可绕过。在此处F2下断点，开始动调程序。随便输个数字，按回车 此时程序停在jz处，即我们下断点的地方 在右上侧寄存器窗口找到ZF 双击ZF把它的值改成0x1 可以看到jz语句处有一条箭头出来了 F8执行jz跳转，跟踪程序执行流。可以看到程序运行到一个类似输出函数的地方 这时候，在这里多试几次会发现MessageBoxA可以步入。当然要是步过这个call MessageBoxA会发现程序没有弹出窗口，倒是终端输出了新的句子，十分可疑 所以在程序执行到call cs:MessageBoxA这句的时候按F7步入，就会发现这个MessageBoxA别有洞天 这显然不像是MessageBoxA应该有的操作。可以看到一个可疑的地址被放到了rax里，跟踪这个jmp看看（jmp rax处F7步入） 可以看到程序运行到了一个新函数，F5反编译，反编译代码如下（函数有多个模块的加密处理，还是很复杂的，以下是经过变量名优化的代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261__int64 realMain(){ char v0; // dl char *v1; // rax char v2; // dl char *i; // rax int v4; // eax unsigned __int8 *pFlag1; // r9 _BYTE *pFlag; // rdx unsigned int v7; // esi char v8; // dl char *j; // rax unsigned int *p_block0; // r10 unsigned __int8 *current_1; // rdx int shift; // ecx unsigned int temp_2; // r8d int temp_1; // eax unsigned int cureent_block; // eax unsigned int delta; // r11d int key_value; // ebp unsigned int prev_block; // r9d unsigned int *block; // r8 int rounds; // ecx unsigned int next; // edx unsigned int oriDelta; // ecx unsigned __int8 *encrypted_bytes_1; // r10 unsigned int *v24; // rdi _DWORD *v25; // r8 _DWORD *v26; // rax int shift_1; // ecx unsigned int v28; // edx _BYTE *v29; // r9 unsigned int v30; // r8d unsigned __int64 k; // rax char v32; // dl _BYTE *current1; // rbx int randNum; // eax char tmp; // r8 _BYTE *target; // rdx unsigned __int8 *v37; // rdx unsigned __int8 *end; // rbx unsigned __int8 *current; // rax char *v40; // rcx int m; // eax char *v42; // rax char n; // dl char v44; // dl char *ii; // rax _QWORD key[2]; // [rsp+20h] [rbp-218h] BYREF char notice2[22]; // [rsp+30h] [rbp-208h] BYREF __int16 v49; // [rsp+46h] [rbp-1F2h] BYREF unsigned int block0; // [rsp+50h] [rbp-1E8h] BYREF int v51; // [rsp+54h] [rbp-1E4h] BYREF unsigned int block10; // [rsp+78h] [rbp-1C0h] _BYTE encrypted_bytes[44]; // [rsp+80h] [rbp-1B8h] BYREF int v54; // [rsp+ACh] [rbp-18Ch] BYREF _BYTE flag[44]; // [rsp+B0h] [rbp-188h] BYREF char v56; // [rsp+DCh] [rbp-15Ch] BYREF _QWORD enc[7]; // [rsp+E0h] [rbp-158h] BYREF int v58; // [rsp+118h] [rbp-120h] _BYTE base64_output[59]; // [rsp+120h] [rbp-118h] BYREF _BYTE end_1[5]; // [rsp+15Bh] [rbp-DDh] BYREF char temp[64]; // [rsp+160h] [rbp-D8h] BYREF char notice1[85]; // [rsp+1A0h] [rbp-98h] BYREF _BYTE v63[3]; // [rsp+1F5h] [rbp-43h] BYREF v0 = 79; enc[0] = 0x280D30732B077874LL; enc[1] = 0x242D00103573060BLL; enc[2] = 0x141C3406727D2F73LL; enc[3] = 0xA71137676362833LL; enc[4] = 0xE232B242F04742ALL; enc[5] = 0x2F373F03033D7310LL; enc[6] = 0x77067C3612772D7DLL; qmemcpy(key, &quot;Calamity_Fortune&quot;, sizeof(key)); qmemcpy( notice1, &quot;Ofqni`'jfcb'ns'sont'afu+'sob'tretbvrbis'bidu~wsnhi'tohrkc'eb'f'wnbdb'ha'dflb'ahu'~hry&quot;, sizeof(notice1)); v1 = notice1; v58 = 0x37233104; while ( 1 ) { *v1++ = v0 ^ 7; if ( v63 == v1 ) break; v0 = *v1; } puts(notice1); // Having made it this far,...... v2 = 87; qmemcpy(notice2, &quot;Wkbftb'Niwrs'~hru'akf`&quot;, sizeof(notice2)); for ( i = notice2; ; v2 = *i ) { *i++ = v2 ^ 7; if ( i == &amp;v49 ) break; } puts(notice2); // Please input your flag scanf(&quot;%44s&quot;, flag); v4 = flag[0]; v56 = 0; if ( !flag[0] ) goto LABEL_11; pFlag1 = flag; pFlag = flag; do v7 = 1 - flag + pFlag++; while ( *pFlag ); if ( v7 != 44 ) {LABEL_11: // 错误时的输出 v8 = 75; qmemcpy(temp, &quot;Kbi`so'Buuhu&amp;&quot;, 13); for ( j = temp; ; v8 = *j ) { *j++ = v8 ^ 7; if ( &amp;temp[13] == j ) break; } puts(temp); // 错误时的输出 exit(0); } p_block0 = &amp;block0; while ( 1 ) // bytesToBlock，转成uint32_t { current_1 = pFlag1; shift = 0; temp_2 = 0; while ( 1 ) { temp_1 = v4 &lt;&lt; shift; shift += 8; ++current_1; temp_2 |= temp_1; if ( shift == 32 ) break; v4 = *current_1; } pFlag1 += 4; *p_block0++ = temp_2; if ( &amp;v56 == pFlag1 ) break; v4 = *pFlag1; } cureent_block = block10; delta = 0x9E3779B9; key_value = 0x616C6143; prev_block = block0; while ( 1 ) // xxtea { block = &amp;block0; for ( rounds = 0; ; ++rounds ) { next = block[1]; ++block; cureent_block = prev_block + (((cureent_block ^ *(key + (((delta &gt;&gt; 2) ^ rounds) &amp; 3))) + (next ^ delta)) ^ (((4 * next) ^ (cureent_block &gt;&gt; 5)) + ((16 * cureent_block) ^ (next &gt;&gt; 3)))); *(block - 1) = cureent_block; if ( rounds == 9 ) break; prev_block = *block; } prev_block = block0; oriDelta = delta; delta -= 0x61C88647; cureent_block = block10 + ((((cureent_block &gt;&gt; 5) ^ (4 * block0)) + ((16 * cureent_block) ^ (block0 &gt;&gt; 3))) ^ ((block0 ^ oriDelta) + (key_value ^ cureent_block))); block10 = cureent_block; if ( delta == 0xCC623AF3 ) break; key_value = *(key + (((delta &gt;&gt; 2) ^ 0xA) &amp; 3)); } encrypted_bytes_1 = encrypted_bytes; v24 = &amp;v51; // blockToBytes，uint32_t转成bytes v25 = encrypted_bytes; while ( 1 ) { v26 = v25; for ( shift_1 = 0; shift_1 != 32; shift_1 += 8 ) { v26 = (v26 + 1); v28 = prev_block &gt;&gt; shift_1; *(v26 - 1) = v28; } if ( &amp;v54 == ++v25 ) break; prev_block = *v24++; } qmemcpy(temp, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;, sizeof(temp)); v29 = base64_output; do // base64encode { v30 = *encrypted_bytes_1 &lt;&lt; 16; if ( v7 != 1 ) { v30 |= encrypted_bytes_1[1] &lt;&lt; 8; if ( v7 &gt; 2 ) v30 |= encrypted_bytes_1[2]; } for ( k = 0LL; k != 4; ++k ) { v32 = 61; if ( k &lt;= v7 ) v32 = temp[(v30 &gt;&gt; (-6 * k + 18)) &amp; 0x3F]; v29[k] = v32; } encrypted_bytes_1 += 3; v29 += 4; v7 -= 3; } while ( (&amp;v54 + 1) != encrypted_bytes_1 ); current1 = end_1; end_1[1] = 0; srand(0x65u); // shuffle while ( 1 ) { randNum = rand(); tmp = *current1; target = &amp;base64_output[randNum % (60 - end_1 + current1)]; *current1 = *target; *target = tmp; v37 = current1 - 1; if ( base64_output == current1 - 1 ) break; --current1; } end = current1 + 59; current = v37; do // xor *current++ ^= 0x45u; while ( end != current ); v40 = enc + 1; for ( m = 116; ; m = *v40++ ) { if ( *v37 != m ) // 错误处理的输出 { qmemcpy(temp, &quot;Dfkfjns~&amp;'wkbftb'su~'f`fni&quot;, 26); v42 = temp; for ( n = 68; ; n = *v42 ) { *v42++ = n ^ 7; if ( &amp;temp[26] == v42 ) break; } puts(temp); exit(0); } // 错误处理的输出 if ( end == ++v37 ) break; } v44 = 65; qmemcpy(temp, &quot;Ahusrib&amp;@hhc'Krdl&amp;&quot;, 18); for ( ii = temp; ; v44 = *ii ) { *ii++ = v44 ^ 7; if ( &amp;temp[18] == ii ) break; } puts(temp); return 1LL;} 函数出现在程序输入flag的提示之后，应该就是flag检验函数了。函数使用了很多加密手段，甚至连提示词都是实时解密的。可以看到对输入的flag依次进行了格式转换、魔改XXTEA加密、格式转换、base64编码、shuffle洗牌算法打乱、异或处理，最后才和预设的密文进行比较检验。 这里给出一个AI复现的、经过测试等价的脚本，方便理解这个复杂的算法（被函数改写整怕了，所以随机数生成算法也复现了）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;// MSVC-compatible randstatic uint32_t rand_seed;void custom_srand(uint32_t seed) { rand_seed = seed; }uint32_t custom_rand() { rand_seed = rand_seed * 214013 + 2531011; return (rand_seed &gt;&gt; 16) &amp; 0x7FFF;}// XXTEA encryption (as in realMain)void encrypt_xxtea_variant(uint32_t block[11], const uint32_t key[4]) { uint32_t cureent_block = block[10]; uint32_t delta = 0x9E3779B9U; uint32_t key_value = 0x616C6143U; // 初始值，但第一轮内循环不用它 uint32_t prev_block = block[0]; while (1) { uint32_t* bptr = &amp;block[0]; for (int rounds = 0; ; ++rounds) { uint32_t next = bptr[1]; ++bptr; uint32_t k = key[((delta &gt;&gt; 2) ^ rounds) &amp; 3]; uint32_t term1 = (cureent_block ^ k) + (next ^ delta); uint32_t term2 = (4 * next ^ (cureent_block &gt;&gt; 5)) + (16 * cureent_block ^ (next &gt;&gt; 3)); cureent_block = prev_block + (term1 ^ term2); *(bptr - 1) = cureent_block; if (rounds == 9) break; prev_block = *bptr; // 此时 *bptr 尚未被修改（是原始值） } prev_block = block[0]; uint32_t oriDelta = delta; delta -= 0x61C88647U; key_value = key[((oriDelta &gt;&gt; 2) ^ 0xA) &amp; 3]; uint32_t term1 = ((cureent_block &gt;&gt; 5) ^ (4 * block[0])) + ((16 * cureent_block) ^ (block[0] &gt;&gt; 3)); uint32_t term2 = (block[0] ^ oriDelta) + (key_value ^ cureent_block); cureent_block = block[10] + (term1 ^ term2); block[10] = cureent_block; if (delta == 0xCC623AF3U) break; }}// Base64 encode 44 bytes -&gt; 60 charsvoid base64_encode(const uint8_t* input, char* output) { const char* table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;; for (int i = 0; i &lt; 44; i += 3) { uint32_t val = (input[i] &lt;&lt; 16) | ((i + 1 &lt; 44 ? input[i + 1] : 0) &lt;&lt; 8) | ((i + 2 &lt; 44 ? input[i + 2] : 0)); output[0] = table[(val &gt;&gt; 18) &amp; 0x3F]; output[1] = table[(val &gt;&gt; 12) &amp; 0x3F]; output[2] = (i + 1 &lt; 44) ? table[(val &gt;&gt; 6) &amp; 0x3F] : '='; output[3] = (i + 2 &lt; 44) ? table[val &amp; 0x3F] : '='; output += 4; }}int main() { // Step 1: Input flag char flag[45] = &quot;0xGame{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}&quot;;//测试样例 printf(&quot;Input flag: %s\\n&quot;, flag); // Step 2: Convert to 11 uint32_t (little-endian) uint32_t blocks[11]; for (int i = 0; i &lt; 11; i++) { blocks[i] = (uint8_t)flag[i * 4] | ((uint8_t)flag[i * 4 + 1] &lt;&lt; 8) | ((uint8_t)flag[i * 4 + 2] &lt;&lt; 16) | ((uint8_t)flag[i * 4 + 3] &lt;&lt; 24); } // Step 3: XXTEA encrypt uint32_t key[4] = { 0x616C6143, // 'C','a','l','a' 0x7974696D, // 'm','i','t','y' 0x726F465F, // '_','F','o','r' 0x656E7574 // 't','u','n','e' }; encrypt_xxtea_variant(blocks, key); printf(&quot;TEA encrypted blocks (hex, little-endian order):\\n&quot;); for (int i = 0; i &lt; 11; i++) { printf(&quot;%08x\\n&quot;, blocks[i]); } printf(&quot;\\n&quot;); // Step 4: Convert back to bytes (little-endian) uint8_t encrypted_bytes[44]; for (int i = 0; i &lt; 11; i++) { encrypted_bytes[i * 4] = blocks[i] &amp; 0xFF; encrypted_bytes[i * 4 + 1] = (blocks[i] &gt;&gt; 8) &amp; 0xFF; encrypted_bytes[i * 4 + 2] = (blocks[i] &gt;&gt; 16) &amp; 0xFF; encrypted_bytes[i * 4 + 3] = (blocks[i] &gt;&gt; 24) &amp; 0xFF; } // Step 5: Base64 encode char base64_str[61] = { 0 }; base64_encode(encrypted_bytes, base64_str); printf(&quot;Base64: %s\\n&quot;, base64_str); // Step 6: Shuffle (Fisher-Yates, i=59 downto 1) custom_srand(0x65); for (int i = 59; i &gt;= 1; i--) { int j = custom_rand() % (i + 1); // Swap base64_str[i] and base64_str[j] char tmp = base64_str[i]; base64_str[i] = base64_str[j]; base64_str[j] = tmp; } // Output shuffled result (before XOR) printf(&quot;After shuffle (before XOR): %s\\n&quot;, base64_str); printf(&quot;Hex dump:\\n&quot;); for (int i = 0; i &lt; 60; i++) { printf(&quot;%02x &quot;, (uint8_t)base64_str[i]); if ((i + 1) % 16 == 0) printf(&quot;\\n&quot;); } if (60 % 16 != 0) printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 60; i++) { printf(&quot;%02x &quot;, (uint8_t)base64_str[i] ^ 0x45); } printf(&quot;\\n&quot;); return 0;} 解密思路：异或模块直接一模一样地重复一遍即可；shuffle模块可以先从加密算法获得随机数序列，这样方便从后往前索引还原；剩下的看脚本吧🫠（对了，要注意enc数据要从栈上提取，笔者让AI从反编译的代码里提取，肉眼检验没发现bytes截取错了，浪费了好多时间） 解密脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;// ========== 你提供的解密函数 ==========void decrypt_xxtea_variant(uint32_t block[11], const uint32_t key[4]) { const int TOTAL_ROUNDS = 10; uint32_t delta = 0xCC623AF3U; for (int round = 0; round &lt; TOTAL_ROUNDS; round++) { uint32_t oriDelta = delta + 0x61C88647U; uint32_t key_value = key[((oriDelta &gt;&gt; 2) ^ 0xA) &amp; 3]; uint32_t C9 = block[9]; uint32_t C0 = block[0]; uint32_t term1 = ((C9 &gt;&gt; 5) ^ (4 * C0)) + ((16 * C9) ^ (C0 &gt;&gt; 3)); uint32_t term2 = (C0 ^ oriDelta) + (key_value ^ C9); uint32_t G = term1 ^ term2; uint32_t original_block10 = block[10] - G; uint32_t saved_block10 = original_block10; for (int i = 9; i &gt;= 0; i--) { uint32_t next = (i == 9) ? saved_block10 : block[i + 1]; uint32_t prev_C = (i == 0) ? saved_block10 : block[i - 1]; uint32_t k = key[((oriDelta &gt;&gt; 2) ^ i) &amp; 3]; uint32_t part1 = (prev_C ^ k) + (next ^ oriDelta); uint32_t part2 = (4 * next ^ (prev_C &gt;&gt; 5)) + (16 * prev_C ^ (next &gt;&gt; 3)); uint32_t H = part1 ^ part2; block[i] = block[i] - H; } block[10] = original_block10; delta += 0x61C88647U; }}const char* table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;int base64_decode(const char* input, uint8_t* output) { int out_len = 0; for (int i = 0; i &lt; 60; i += 4) { uint32_t val = 0; for (int j = 0; j &lt; 4; j++) { const char* p = strchr(table, input[i + j]); if (p) val = (val &lt;&lt; 6) | (p - table); else val &lt;&lt;= 6; } output[out_len++] = (val &gt;&gt; 16) &amp; 0xFF; if (input[i + 2] != '=') output[out_len++] = (val &gt;&gt; 8) &amp; 0xFF; if (input[i + 3] != '=') output[out_len++] = val &amp; 0xFF; } return out_len;}void deshuffle(char* cipher, uint32_t* rand_seq) { // 逆序遍历：t 从 58 到 0 for (int t = 58; t &gt;= 0; t--) { int i = 59 - t; // 加密时的 i int j = rand_seq[t]; // 加密时的 j // 再次交换 cipher[i] 和 cipher[j] char temp = cipher[i]; cipher[i] = cipher[j]; cipher[j] = temp; }}// ========== 主程序 ==========int main() { // Step 1: 使用你提供的 60 字节目标密文 uint8_t encrypted_target_bytes[60] = { 0x74, 0x78, 0x07, 0x2B, 0x73, 0x30, 0x0D, 0x28, 0x0B, 0x06, 0x73, 0x35, 0x10, 0x00, 0x2D, 0x24, 0x73, 0x2F, 0x7D, 0x72, 0x06, 0x34, 0x1C, 0x14, 0x33, 0x28, 0x36, 0x76, 0x76, 0x13, 0x71, 0x0A, 0x2A, 0x74, 0x4, 0x2f, 0x24, 0x2b, 0x23, 0xe, 0x10, 0x73, 0x3D, 0x03, 0x03, 0x3F, 0x37, 0x2F, 0x7D, 0x2D, 0x77, 0x12, 0x36, 0x7C, 0x06, 0x77, 0x04, 0x31, 0x23, 0x37 }; // Step 2: XOR 0x45 得到 shuffled base64 字符串 char shuffled_b64[60] = { 0 }; //printf(&quot;step1: xor\\n&quot;); for (int i = 0; i &lt; 60; i++) { shuffled_b64[i] = encrypted_target_bytes[i] ^ 0x45; //printf(&quot;%c&quot;, shuffled_b64[i]); } //printf(&quot;\\nstep2: deshuffle\\n&quot;); // Step 3: 使用你提供的 rand() 序列（原始值，未取模） uint32_t rand_seq[59] = { 8, 46, 21, 19, 35, 1, 1, 7, 37, 17, 33, 13, 17, 10, 34, 34, 6, 20, 35, 10, 22, 21, 7, 16, 6, 18, 30, 32, 6, 2, 9, 0, 7, 4, 23, 18, 18, 16, 15, 15, 6, 15, 16, 3, 13, 13, 9, 2, 11, 10, 3, 2, 0, 1, 3, 0, 3, 0, 0 }; deshuffle(shuffled_b64, rand_seq); //for (int i = 0; i &lt; 60; i++) { //printf(&quot;%c&quot;, shuffled_b64[i]); //} char original_b64[61] = { 0 }; for (int i = 0; i &lt; 60; i++) { original_b64[i] = shuffled_b64[i]; } original_b64[60] = '\\0'; //printf(&quot;\\n&quot;); // Step 4: Base64 解码 uint8_t encrypted_bytes[44]; int decoded_len = base64_decode(original_b64, encrypted_bytes); if (decoded_len != 44) { return 1; } // Step 5: 重组为 11 个 uint32_t（小端序） uint32_t block[11]; for (int i = 0; i &lt; 11; i++) { block[i] = ((uint32_t)encrypted_bytes[i * 4 + 0] &lt;&lt; 0) | ((uint32_t)encrypted_bytes[i * 4 + 1] &lt;&lt; 8) | ((uint32_t)encrypted_bytes[i * 4 + 2] &lt;&lt; 16) | ((uint32_t)encrypted_bytes[i * 4 + 3] &lt;&lt; 24); } // Step 6: 设置密钥 &quot;Calamity_Fortune&quot;（16 字节） uint32_t key[4] = { 0x616C6143U, 0x7974696DU, 0x726F465FU, 0x656E7574U }; // Step 7: 调用你提供的解密函数 decrypt_xxtea_variant(block, key); // Step 8: 转回 flag 字符串（小端） char flag[45] = { 0 }; for (int i = 0; i &lt; 11; i++) { flag[i * 4 + 0] = (block[i] &gt;&gt; 0) &amp; 0xFF; flag[i * 4 + 1] = (block[i] &gt;&gt; 8) &amp; 0xFF; flag[i * 4 + 2] = (block[i] &gt;&gt; 16) &amp; 0xFF; flag[i * 4 + 3] = (block[i] &gt;&gt; 24) &amp; 0xFF; } printf(&quot;Flag: %s\\n&quot;, flag); return 0;} flag：0xGame{f279c1e7-8b0d-4a3b-9c6f-5e4d2a1b0c89}","link":"/2025/10/28/0xGame2025Week3ReverseWriteUp/"},{"title":"Day1:数据结构与复杂度","text":"数据结构简述、复杂度初探 数据结构简述 “数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法”，这是Hello 算法中给出的定义。数据结构是人为创造的、服务于数据存储与处理的一种规范，我们可以根据一种数据结构的概念，用不同的语言、不同的特性来实现它。 数据主要有两种存储结构：顺序存储和链式存储。这两种存储结构是后续各种数据结构实现的基础。 顺序存储，就是数据存储在连续的内存空间上。 链式存储，就是数据存储在不连续的内存空间上，但是每个内存单位之间又有联系，像链条一样串联在一起。 数据结构按照逻辑特征可以分为四种：线性结构、图结构、树形结构、集合结构。 抽象数据类型(ADT)：用于描述数据结构的一种模型，包括了结构特性的描述、相关的运算函数描述。ADT和类很像，但是ADT更像是用代码实现具体数据结构前列的的提纲。 算法是对数据进行处理的策略，即运算方法。算法会依赖数据结构来实现。算法追求效率，即更短的运算时间和更少的资源占用。 复杂度 算法追求时间和空间上的效率，所以描述一个算法的复杂度分为两种：时间复杂度和空间复杂度。 时间复杂度评估的是一段代码的运行时间，由于计算机执行操作的时间都很短，所以时间复杂度的评估往往等同于操作次数的评估。我们通常说的时间复杂度实际上是渐进时间复杂度。标准的时间复杂度考虑代码中所有的操作，比如赋值会记1次操作，两个变量相加会记1次操作等。渐进时间复杂度则只考虑操作数的量级，所以关注的往往是代码中的关键操作。 所谓关键操作，一般是指操作边界含n，即操作的边界含有变量、不同情况下边界不同的的操作。如 1234567int sum(int n){ int sum=0; for(int i=1;i&lt;=n;i++){ sum+=n; } return sum;} 其中，for循环中的操作执行次数依赖于边界n，这就是我们需要关注的地方。 以这段代码为例，给sum赋值的语句记1次操作，for循环中，给i赋值记1次操作，i的边界判断记n+1次操作（因为i自增到n+1还会到i&lt;=n这里来进行边界判断），for循环中sum累加记n次操作，返回sum记1次操作。这样子，这段代码总共进行了2n+4次操作，只考虑量级的话就是n。 对于渐进时间复杂度，采用大O表示法：O(算法量级)。如上面这段代码，量级为n，渐进时间复杂度记为O(n)。 空间复杂度评估的是一段代码占用的内存空间。空间复杂度和时间复杂度类似，通常只考虑量级，但此处是占用内存空间的量级。内存空间的占用比较直观，关注的重点依旧是边界包含变量的操作，记录的是操作带来的内存空间占用情况。如赋值操作，记1个单位的空间占用；创建长度为n的数组，记n个单位的空间占用等。还用上面的代码为例子，sum赋值记1个单位，i赋值记1个单位，所以这段代码总共就占用2个单位的内存空间，量级为1，空间复杂度记为O(1)。 常见操作的时间复杂度和空间复杂度： 语句/操作 时间复杂度 空间复杂度 说明 赋值操作 (a = b) O(1) O(1) 基本数据类型赋值 算术运算 (+, -, *, /, %) O(1) O(1) 固定大小数值运算 比较操作 (==, !=, &lt;, &gt;) O(1) O(1) 基本数据类型比较 数组索引 (arr[i]) O(1) O(1) 随机访问 函数调用 O(1) O(1) 调用开销本身 if-else O(1) O(1) 条件判断本身 switch-case O(1) O(1) 跳转表实现 goto O(1) O(1) 跳转指令 单层for循环 O(n) O(1) 循环n次，体为O(1) 嵌套for循环 O(n²) O(1) 两层各n次循环 while循环 O(n) O(1) 循环n次，体为O(1) do-while循环 O(n) O(1) 循环n次，体为O(1) 递归调用 O(n) O(n) 线性递归，n为深度 尾递归优化 O(n) O(1) 编译器优化后 函数返回 O(1) O(1) 栈帧销毁 malloc/new O(1) O(n) 分配n字节内存 free/delete O(1) O(1) 释放内存 内存拷贝 O(n) O(1) 拷贝n字节 内存设置 O(n) O(1) 设置n字节 try-catch O(1) O(1) 无异常时开销 throw抛出 O(n) O(1) n为调用栈深度 异常捕获 O(1) O(1) 匹配异常类型","link":"/2025/09/18/Day1-%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"title":"Day1:进程与线程（一）","text":"进程与线程、内核对象相关基础知识 什么是进程/线程 进程是操作系统分配资源的单位。运行一个程序，操作系统就会给这个程序分配一个进程。 线程是执行任务的基本单位。一个进程可以有多个线程，但是至少有一个线程。比如说运行QQ，操作系统会给QQ分配一个进程，而QQ里的某些操作，比如和好友聊天，就是一个线程。 操作系统会给每个进程分配4GB虚拟内存空间。32位程序下，这4GB内存分为两部分，低2GB给用户层，高2GB给内核层。每个进程有独立的4GB虚拟内存空间。但是每个进程并不拥有独立的4GB物理内存空间，它们的内核空间是映射到同一块物理内存空间上的，而用户空间在物理内存上确实是独立的。 运行一个程序，操作系统会为它分配一个进程以及4GB的虚拟内存空间，程序涉及的exe、dll文件在需要的时候会被加载到程序的虚拟内存空间上，这些被加载的可执行文件（不仅包括exe，还包括dll）称为模块 内核对象 Windows系统是一个面向对象的操作系统，但是它是基于C语言的，C语言没有类的概念，所以Windows系统的对象本质上是结构体变量。 通常把Windows系统分为两个层级：R0和R3，R0是内核层，里面是操作系统最底层的东西，包含了操作系统的所有结构体变量，一般不会对外开放，但是会提供一些API接口给R3层来访问其中的内容；R3是用户层，作为内核和外界的过渡，封装了一些内核的操作。即，用户在需要访问内核信息的时候，首先要调用R3的API，然后R3再调用R0的API来访问内核。 Windows的对象可以分成三类： USER对象，对应操作系统的界面，相关dll是user32.dll GDI对象，对应绘图相关的内容，相关dll是GDI32.dll 内核对象，对应文件、进程、线程等，相关dll是Kernel32.dll 为了保证系统安全，Windows系统的结构体变量是不允许直接访问的，只能通过句柄和相应的API来访问。在了解句柄之前，得先了解句柄表。每个进程都有自己的句柄表（类似一维数组），用来记录内核对象的相关信息，但是操作系统不会向我们开放这些信息，只会让我们知道某个内核对象的信息块在句柄表中的索引值，而这个索引值就是句柄。 内核空间在物理上是共享的，因此内核对象是跨进程的，不同的进程可以访问相同的内核对象，只不过不同进程中同一个进程对象的句柄不同。 内核对象有一些特性，如安全描述符（用来说明内核对象接受哪些用户和组的访问和使用）、引用计数（用来记录内核对象被引用的次数，当内核对象不被任何进程引用的时候，它就会被销毁）等","link":"/2025/10/03/Day1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"},{"title":"Day11:花指令","text":"花指令 花指令 又叫垃圾指令，不影响程序原始逻辑，但会干扰IDA反编译或者反汇编。 原理： 因为反编译器多是静态分析的，不会通过执行来分析逻辑，只会根据反汇编出来的指令分析，因此有空可乘：例如可以通过内联汇编不完整指令但是跳过不完整指令来模糊指令边界、内联汇编永跳永不跳分支来误导运行逻辑分析、内联汇编无意义指令误导主要逻辑 显著特征是出现红色行，而应对方法是选中花指令所在的区域改为“nop”（空指令） 恒跳型 实测IDA9.0.241217不会报红，也就是混淆失效，所以就看看源码吧 12345678910111213#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main() { _asm{ xor eax, eax; jz s; add esp, 0x11; s: }; printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0;} call-ret相消型 来看效果 可以看到，在函数中间出现了sp-analysis failed，而上面一条就是retn，明显不对。 往前看，rep stosd初始化后，call了$+5，即当前位置+5=0046308C，也就是下一条的add 然后给esp的值+7（call的时候push eip即push 0046308c了） 此时esp存放值为0046308c+7=00463093，所以retn时会pop 00463093，程序跳到00463093 往下看，00463093正是没识别出来的三个数的最后一个，下面还有一个offset没有指令。 第三个数68h和offset结合刚好是push offset，对应上了下面的call（函数传参） 选中没识别的三个数，按“U”（undefine)，可以看到三个数分开了 选中db 68h和dd offset aHello，按C转化为汇编指令，可以看到push offset恢复了 选中call $+5到db 34h，右键选择”Fill with NOPs“（实测db 34h会nop不干净，要选中到db 34h下一行） 可以看到函数变成这样，这是因为插入了retn导致函数范围分析错误，需要纠正 点击函数名，然后右键edit fuction，把end address改成末尾那个真正的retn的地址就OK了 jz-操作数不全型 这种情况下会出现和上一种一样的指令识别错误的问题，且看图： 这是按照MSVS C++初始化规则跳转后，在本来main函数的地方的截图。但是跳转过程中会发现，跳转到main函数的代码是jmp loc_xxxxxx而不是jmp sub_xxxxxx。但是目前还不影响，先分析报错的地方。 可以看到 xor ebp,[eax+50h] 处报红了，并且下面是一段没分析出来的数和字符串”pause”，下面进行分析 首先，rep stosd初始化后，进行了一个恒跳，跳转的地方是0046308E，在 xor ebp,[eax+50h] 这条指令里，所以这里红了 把 xor ebp,[eax+50h] 这条指令undefine一下 根据逻辑，程序是肯定会跳到0046308E的，所以前面的代码冗余，直接nop掉。选中 xor eax,eax 到0046308E（根据上一种类型的经验，要多覆盖一位才能刚好nop掉目标代码） nop完成后（如果有db 90h就按”C“转成code）就会发现下面没分析的数立刻分析出指令了 但是还没完，此时按F5是无法反编译的，因为报错的地方是loc_xxxxxx范围里的，不是一个函数，也就是前面说的jmp loc_xxxxxx而不是jmp sub_xxxxxx的问题了。这里可以看出，IDA这类混淆会导致IDA把函数识别成一个引用而不是函数。 到最开始push ebp开辟栈帧的引用loc_463070处，把它undefine一下，再按“P”重新分析一下，就可以得到main函数了 这类有一个特征就是jz loc_xxxxxx+1，据此可以快速找到加了混淆的地方 总结 上述三种（实际上有混淆效果的只有两种）是比较基础的花指令。识别花指令的要点主要是看红色错误，也可以结合一些特征来识别。解决方法就是nop掉混淆代码。 在实际设计题目时，笔者意外发现了一些更强力的混淆，单单是在上述三种类型的基础上加一点其他指令，就会导致一个函数完全无法被识别（被放在rdata段而不是text段的那种），但是程序还能正常执行，而报错的地方在无法识别的函数的上级函数里（跳转到这个函数的那个函数），可能要结合AI才能实现快捷的分析。因此，花指令还是一个具有挑战性的混淆方式（当然也可能是笔者太菜了没石粒）","link":"/2025/07/31/Day11-%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"title":"Day10:壳与脱壳（二）","text":"二次断点法、一次断点法、特征查找法（均基于Xdbg）、Dll手动脱壳 寻找OEP的方法（二）二次断点法 又叫内存镜像法，原理是壳程序解析时会从.rsrc段获取资源，解析后回到代码段，因此可以通过现在.rsrc段设置内存读取断点，然后在代码段(.text/.code)设置内存写入断点来监控壳程序执行。 通常这个方法是基于OllyDbg的，但是从原理出发Xdbg也不是不能用。除了有一步是在OllyDbg中设置忽略所有异常，Xdbg好像没有这个设置选项，但是经过实测是可以用这个方法在Xdbg脱upx壳的。 Upx脱壳示例： Xdbg载入程序，先在“断点”模块把预设的断点删除，避免程序在非关注的异常处（断点处）停下 然后到“内存映射”模块找到程序的.rsrc（注意所属方为用户），下一次性内存读取断点 shift+F9运行，然后在上方的upx0处下一次性内存写入断点 shift+F9运行，回到“CPU”模块，会发现下方不远处就有一个大跳（隔得有点远截不到eip和大跳的同框图），在大跳前下断点，F9运行到断点处，然后步进就可以到达OEP了 但是有一点奇怪的地方：结合upx的解析原理，upx好像是从upx1段加载数据解析到upx0段的（AI说的，不确定对不对），所以按道理，在upx1处下内存读取断点不是也有类似的监控效果吗？但是实测这样子会跑飞🤔有过一个想法就是，因为在upx1段下了读取断点，壳程序解析前中断了，然后又在upx0段下写入断点，然后按道理应该停在解析然后写入这一步，就是解析了还没写入，或者说刚刚写入一次，那这样也不至于直接调试终止吧🤔 一次断点法（二次断点法plus) 这个方法是基于二次断点法和upx实测出来的，因为根据壳程序解析的原理，最终都会发生向内存写入解析完的数据的操作，所以直接在写入的地方下内存写入断点，这样调试器中断的地方就离OEP不远了（接近壳程序解析的尾声，但还是远到截不到eip和大跳的同框图） 示例 首先，同样要先去掉预设断点 然后在“内存映射”模块给upx0下一次性内存写入断点/给upx1下一次性内存读取断点 shift+F9运行，中断的地方就差不多是壳程序解析写入/开始解析的地方了，在下方大跳前F2断点+F9运行一步到位，然后就可以跳转到OEP了 特征查找法 借助特征指令popad，在程序区域搜索指令，然后下断点运行至此，再接着运行到OEP处 示例： F9运行到程序区域，此时断在pushad 右键在当前区域搜索命令popad 双击搜索结果跳转，下方不远处就是到OEP的大跳了。直接在jmp前一条指令下断点，F9到此，然后步进 Dll手动脱壳 若出现Dll程序加壳的情况，可以先把Dll程序转化成exe程序，然后使用和exe手动脱壳一样的步骤即可 示例： 用DIE打开Dll程序，可以看到显示加了upx壳 点击“区块”下方的“&gt;”，打开文件结构界面 取消勾选右上角”只读“，然后点击IMAGE_FILE_HEADER，取消勾选”标志“中的”Dll“（图中未取消） 此时可以发现，Characteristics的值变了 然后把dll后缀改成exe就可以按照exe手动脱壳的步骤进行脱壳了","link":"/2025/07/30/Day10-%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Day12:反调试（一）","text":"反调试基本原理、WINAPI检测、数据检测、进程检测 反调试基本原理 反调试技术通常借助操作系统相关的内容来实现，常见办法有调用WindowsAPI获得相关数据、有意触发异常监测异常处理（调试器会捕获异常）、时间差检测（实际运行过程十分迅速）、硬件断点检测、进程检测等 WINAPI检测 由于是直接使用WINAPI，所以一般在IDA或者动态调试器里会有明显的函数名字样，识别会比较容易 此类一般是利用函数的返回值或者函数传递回来的参数作为判断标准，应对方法主要有使用反反调试插件、修改相关值、hook等 IsDebuggerPresent 原理： IsDebuggerPresent() 实际上是通过访问PEB（ProcessEnvironmentBlock，进程环境块，一个描述进程相关数据的结构体）中的BeingDebugged标志来判断是否被调试的，被调试的话，函数返回1。有关BeingDebugged的内容，见下文。 IDA和XDbg的效果图： 可以看到明显的IsDebuggerPresent字样。 应对方法： 在XDbg中开启scyllahide插件或者在TEST EAX,EAX后改变一下ZF就可以了 CheckRemoteDebuggerPresent 原理： 函数原型： 1234BOOL WINAPI CheckRemoteDebuggerPresent( In HANDLE hProcess,//参数1，一个进程句柄，传入当前进程句柄就是checklocal了 Inout PBOOL pbDebuggerPresent//参数2，一个用来传递的布尔值，用来表示是否被调试); 这个函数实际上是借用了NtQueryInfomationProcess函数来实现调试检测的，简单讲就是通过NtQueryInformationProcess查询一个数据然后和非调试状态下这个数据预期的值进行比较，比较结果再传给自己的参数2。更详细的原理见下一个API 效果图： 应对方法： scyllahide依旧管用，也可以在call CheckRemoteDebuggerPresent下面的cmp后改变zf来实现反反调试 NtQueryInformationProcess 原理： 函数原型： 1234567__kernel_entry NTSTATUS NtQueryInformationProcess( IN HANDLE ProcessHandle,//要查询的进程句柄 IN PROCESSINFOCLASS ProcessInformationClass,//要查询的信息类型 OUT PVOID ProcessInformation,//接收查询结果的缓冲区（变量） IN ULONG ProcessInformationLength,//缓冲区大小 OUT PULONG ReturnLength OPTIONAL//实际返回的数据大小，可选); 通过设置第二个参数为0x7（表示查询一个叫ProcessDebugPort的变量），函数会通过第三个参数传递调试信息，被调试则传递非0 或者设置第二个参数为0x1E（表示查询一个叫ProcessDebugObjectHandle的变量），被调试则传递非NULL 或者设置第二个参数为0x1F（表示查询一个叫ProcessDebugFlags的变量），被调试则传递0 原型是这样，但是这个函数是Windows内部API，即系统不想用户使用这个函数（可能是出于安全考虑），所以直接调用是不行的，要动态加载。下面是DS给的实现源码参考： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// 1. 定义函数指针类型（必须手动声明）typedef LONG NTSTATUS;typedef NTSTATUS (NTAPI* PNtQueryInformationProcess)( HANDLE ProcessHandle, int ProcessInformationClass, // 直接使用 int 代替 PROCESSINFOCLASS PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);int main() { // 2. 动态加载 ntdll.dll HMODULE hNtdll = GetModuleHandleW(L&quot;ntdll.dll&quot;); if (!hNtdll) { printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0; } // 3. 获取 NtQueryInformationProcess 函数地址 PNtQueryInformationProcess NtQueryInformationProcess = (PNtQueryInformationProcess)GetProcAddress(hNtdll, &quot;NtQueryInformationProcess&quot;); if (!NtQueryInformationProcess) { printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0; } // 4. 调用函数查询调试端口（0x7 = ProcessDebugPort） DWORD debugPort = 0; NTSTATUS status = NtQueryInformationProcess( GetCurrentProcess(), 0x7, // ProcessDebugPort &amp;debugPort, sizeof(debugPort), NULL ); // 5. 严格按照你的逻辑输出 if (debugPort) printf(&quot;bye\\n&quot;); else printf(&quot;hello\\n&quot;); system(&quot;pause&quot;); return 0;} 下面是IDA的反汇编结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105.text:000000014007E130 sub_14007E130 proc near ; CODE XREF: sub_14007920B↑j.text:000000014007E130 ; DATA XREF: .pdata:00000001401AB818↓o.text:000000014007E130.text:000000014007E130 var_180 = byte ptr -180h.text:000000014007E130 var_160 = qword ptr -160h.text:000000014007E130 var_150 = byte ptr -150h.text:000000014007E130 hModule = qword ptr -148h.text:000000014007E130 var_128 = qword ptr -128h.text:000000014007E130 var_10C = dword ptr -10Ch.text:000000014007E130 var_EC = dword ptr -0ECh.text:000000014007E130 var_18 = qword ptr -18h.text:000000014007E130.text:000000014007E130 ; __unwind { // j___GSHandlerCheck.text:000000014007E130 push rbp.text:000000014007E132 push rdi.text:000000014007E133 sub rsp, 178h.text:000000014007E13A lea rbp, [rsp+30h].text:000000014007E13F lea rdi, [rsp+180h+var_150].text:000000014007E144 mov ecx, 22h ; '&quot;'.text:000000014007E149 mov eax, 0CCCCCCCCh.text:000000014007E14E rep stosd.text:000000014007E150 mov rax, cs:__security_cookie.text:000000014007E157 xor rax, rbp.text:000000014007E15A mov [rbp+150h+var_18], rax.text:000000014007E161 lea rcx, unk_1401B80A2.text:000000014007E168 call sub_14007A313.text:000000014007E16D nop.text:000000014007E16E lea rcx, ModuleName ; &quot;ntdll.dll&quot;.text:000000014007E175 call cs:GetModuleHandleW ;此处加载ntdll库.text:000000014007E17B mov [rbp+150h+hModule], rax.text:000000014007E17F cmp [rbp+150h+hModule], 0.text:000000014007E184 jnz short loc_14007E1A7.text:000000014007E186 lea rcx, aHello ; &quot;hello\\n&quot;.text:000000014007E18D call sub_14007886F.text:000000014007E192 nop.text:000000014007E193 lea rcx, aPause ; &quot;pause&quot;.text:000000014007E19A call sub_140078810.text:000000014007E19F nop.text:000000014007E1A0 xor eax, eax.text:000000014007E1A2 jmp loc_14007E240.text:000000014007E1A7 ; ---------------------------------------------------------------------------.text:000000014007E1A7.text:000000014007E1A7 loc_14007E1A7: ; CODE XREF: sub_14007E130+54↑j.text:000000014007E1A7 lea rdx, ProcName ; &quot;NtQueryInformationProcess&quot;.text:000000014007E1AE mov rcx, [rbp+150h+hModule] ; hModule.text:000000014007E1B2 call cs:GetProcAddress ;此处获取NtQueryInformationProcess函数地址.text:000000014007E1B8 mov [rbp+150h+var_128], rax ;此处把函数地址传给局部变量.text:000000014007E1BC cmp [rbp+150h+var_128], 0.text:000000014007E1C1 jnz short loc_14007E1E1.text:000000014007E1C3 lea rcx, aHello ; &quot;hello\\n&quot;.text:000000014007E1CA call sub_14007886F.text:000000014007E1CF nop.text:000000014007E1D0 lea rcx, aPause ; &quot;pause&quot;.text:000000014007E1D7 call sub_140078810.text:000000014007E1DC nop.text:000000014007E1DD xor eax, eax.text:000000014007E1DF jmp short loc_14007E240.text:000000014007E1E1 ; ---------------------------------------------------------------------------.text:000000014007E1E1.text:000000014007E1E1 loc_14007E1E1: ; CODE XREF: sub_14007E130+91↑j.text:000000014007E1E1 mov [rbp+150h+var_10C], 0.text:000000014007E1E8 call cs:GetCurrentProcess .text:000000014007E1EE mov [rsp+180h+var_160], 0.text:000000014007E1F7 mov r9d, 4 ;缓冲区大小.text:000000014007E1FD lea r8, [rbp+150h+var_10C] ;接收结果的缓冲区.text:000000014007E201 mov edx, 7 ;指定查询的信息类型.text:000000014007E206 mov rcx, rax ;查询的进程句柄.text:000000014007E209 call [rbp+150h+var_128] ;调用NtQueryInformationProcess.text:000000014007E20C mov [rbp+150h+var_EC], eax.text:000000014007E20F cmp [rbp+150h+var_10C], 0.text:000000014007E213 jz short loc_14007E224.text:000000014007E215 lea rcx, aBye ; &quot;bye\\n&quot;.text:000000014007E21C call sub_14007886F.text:000000014007E221 nop.text:000000014007E222 jmp short loc_14007E231.text:000000014007E224 ; ---------------------------------------------------------------------------.text:000000014007E224.text:000000014007E224 loc_14007E224: ; CODE XREF: sub_14007E130+E3↑j.text:000000014007E224 lea rcx, aHello ; &quot;hello\\n&quot;.text:000000014007E22B call sub_14007886F.text:000000014007E230 nop.text:000000014007E231.text:000000014007E231 loc_14007E231: ; CODE XREF: sub_14007E130+F2↑j.text:000000014007E231 lea rcx, aPause ; &quot;pause&quot;.text:000000014007E238 call sub_140078810.text:000000014007E23D nop.text:000000014007E23E xor eax, eax.text:000000014007E240.text:000000014007E240 loc_14007E240: ; CODE XREF: sub_14007E130+72↑j.text:000000014007E240 ; sub_14007E130+AF↑j.text:000000014007E240 mov rdi, rax.text:000000014007E243 lea rcx, [rbp+150h+var_180].text:000000014007E247 lea rdx, unk_140171FF0.text:000000014007E24E call sub_140079A35.text:000000014007E253 mov rax, rdi.text:000000014007E256 mov rcx, [rbp+150h+var_18].text:000000014007E25D xor rcx, rbp ; StackCookie.text:000000014007E260 call j___security_check_cookie.text:000000014007E265 lea rsp, [rbp+148h].text:000000014007E26C pop rdi.text:000000014007E26D pop rbp.text:000000014007E26E retn.text:000000014007E26E ; } // starts at 14007E130.text:000000014007E26E sub_14007E130 endp.text:000000014007E26E 特征应该是 call cs:GetModuleHandleW、call cs:GetProcAddress、 call cs:GetCurrentProcess 应对方法： scyllahide也是支持反NtQueryInformationProcess反调试的，手动绕过一般是更改缓冲区的值与标准值的比较结果，当然在DS给的源码中因为加入了一些错误处理（如ntdll载入失败就跳过反调试），可以通过人为改动错误判断的结果来实现直接跳过反调试 GetLastError 这个函数用于获取最近一次异常的返回值。使用的方法一般是故意构造异常，如果处于被调试状态，调试器会捕获异常导致返回的错误码和预期的不符。 效果： 应对方法： 可以看到，GetLastError之后，会把返回值和预设的值进行比较，所以修改cmp后的zf就可以了。由于GetLastError的自由度比较高（触发异常的方法多样），所以scyllahide应该是不支持的（笔者没有认出什么相关的设置） 数据检测BeingDebugged BeingDebugged是PEB的成员变量之一，用于描述进程是否处于被调试状态，为1时表示处于被调试状态。 PEB结构体具体如下： 123456789101112131415161718192021typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged;//偏移为2 BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId;} PEB, *PPEB; 反调试手段通常是访问进程的该参数（如WINAPI的IsDebuggerPresent()）来判断是否处于被调试状态。32位下，PEB用FS:[0x30]表示；64位下，PEB用FS:[0x60]表示。加上偏移2就是对BeingDebugged的访问了（这就是这种方法的特征了） 效果图： 应对方法： scyllahide可绕过，手动绕过只需要在访问指令下方的cmp后修改ZF即可 NTGlobalFlag NTGlobalFlag也是PEB结构体的成员，但是是非公开的（因此上文的PEB结构体定义中看不到）。32位下，它位于PEB偏移0x68处，64位下，它位于PEB偏移0xBC处（特征）。它本是描述进程堆管理的，但是由于调试器中的进程创建堆的方式和正常情况有所不同，被调试时该值会被设为0x70（又一个特征），因此也被用来判断是否被调试 效果： 应对方法： syllahide可以绕过，也可以在下面的比较逻辑（因为是内联汇编，所以比较逻辑的实现会有不同）后修改ZF绕过 进程检测FindWindow 实际上是窗口检测，这个函数获取的是进程窗口的类名或者标签，通过与预期的名字进行比较来判断是否处于被调试状态。由于使用的是系统函数，所以实际上也属于WINAPI检测，但是不重要。特征和WINAPI检测一样，会有明显的标记 效果： 本例的程序创建了一个判断函数，在主函数中是将返回值test后来判断是否被调试的，所以只需要修改主函数中的test eax,eax后的ZF就可以实现绕过了。scyllahide应该是不支持的 父进程检测 原理是正常程序双击运行父进程为explorer.exe，而拖进调试器打开父进程为调试器，通过比较获得的父进程名和预设的父进程名可以判断是否处于被调试状态。一般会通过遍历进程或者通过NtQueryInfomationProcess查询来实现。特征是出现大量和进程相关的api，如遍历进程时会调用CreateToolhelp32Snapshot、th32ParentProcessID、Process32Next等，NtQueryInfomationProcess查询会出现QueryFullProcessImageNameA或者其他相关函数与调试器名称字符串同时出现的情况 效果： 实测scyllahide绕过不了第一种方法但可以绕过第二种方法。手动绕过也可以，主要基于后续对进程名的判断，修改判断结果即可绕过 特征码检测 有的调试器在内存中会有特征码，通过遍历进程和搜索特征码可以判断是否被调试。这种情况会比较复杂，难点应该在识别上。一方面可以通过分析是否出现特征码（可能会是很明显的一连串数字初始化），另一方面遍历进程会出现父进程检测中提及的api，但是这些一般不会出现在主函数中，需要跟进函数查看。 特征码示例： scyllahide一般绕过不了，可以在主函数涉及判断结果的逻辑中进行改动绕过。","link":"/2025/08/02/Day12-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"Day13:反调试（二）","text":"时间差检测、断点检测 时间差检测 CPU的运行十分迅速，一段代码可能在几毫秒内就可以执行完毕，但是调试的时候，代码运行时间会显著地变慢，这就是时间差检测的原理。时间差检测主要通过计算时间差然后与预设的值比较实现。 RDTSC指令计算 rdtsc是一个汇编指令，用于将时间读入edx:eax寄存器（高32位：低32位）。通过取两次时间把结果相减可以得到一个时间差。显著特征就是rdtsc指令 效果： 应对方法： 根据程序的逻辑，可以在计算出时间差并比较之后改变比较结果。 GetTickCount计算 原理和RDTSC类似，只不过时间差采用GetTickCount计算。GetTickCount也是WINAPI，会有明显标记。 效果： 应对方法： 修改比较结果即可 QueryPerformanceCounter计算 原理类似，只是采用QueryPerformanceCounter计算，也是WINAPI，比较好识别 效果： 应对方法： 修改比较结果即可 断点检测 断点是调试的一个显著特点。断点可以分为软件断点、硬件断点和内存断点。软件断点通过将目标代码修改为中断指令（X86\\X64下一般为INT3\\0xCC）实现；硬件断点通过将指令地址写入调试寄存器的DR0-DR3监控地址访问来实现；内存断点通过修改内存页（一片片内存区域）的访问权限实现。三者的实现方法都会触发异常让调试器捕获进而中断。反调试的断点检测主要利用软件断点和硬件断点，内存断点由于针对内存区域而非具体指令，精度太低，一般不考虑。 软件断点检测 常见手段是在内存区域搜索0xCC（使用汇编指令repnz scasb） 效果： 因为进行了比较，所以修改比较结果即可绕过 硬件断点检测 常见手段是获取DR寄存器的值并和0比较。特征是GetThreadContext函数（或者其他ThreadContext相关的函数）和与0的比较 效果： 应对方法： 还是进行了比较，修改比较结果绕过","link":"/2025/08/03/Day13-%E5%8F%8D%E8%B0%83%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Day14:IDApython与SMC","text":"IDApythonAPI、SMC自修改代码 IDApython 先贴上官方文档： https://python.docs.hex-rays.com/index.html 基础API idc.here() / idc.get_screen_ea()：返回光标所在处的地址 idc.get_inf_attr(INF_MIN_EA) / idc.get_inf_attr(INF_MAX_EA)：返回最小/最大地址（没有随机化地址情况下） idc.generate_disasm_line(ea,0)：返回ea所在处的汇编指令 idc.prev_head(ea)/next_head(ea)：返回ea处上一条/下一条指令地址 idc.print_insn_mnem(ea)：打印ea处的助记符（即mov,add什么的） idc.print_operand(ea,n)：打印ea处第n个操作数（n=0或者1） 段相关API idautils.Segments()：返回段起始地址列表 idc.get_segm_name(ea)：返回ea所在段的名字 idc.get_segm_start(ea)/get_segm_end(ea)：返回ea所在段的起始地址/结束地址 idc.get_next_seg(ea)：返回ea所在段的下一个段的起始地址 函数相关API idautils.Functions(start_addr,end_addr)：返回地址间的函数对象（不写参数就是所有函数对象） idautils.FuncItems(ea)：返回ea所在函数所有指令的地址（相当于地址列表） idaapi.get_func(ea)：获得ea所在函数的对象（含有如start_ea、end_ea、size等属性） idc.get_func_name(ea)：返回ea所在函数的名字 idc.get_func_attr(ea,FUNCATTR_START) / idc.get_func_attr(ea,FUNCATTR_END)：返回ea所在函数的起始地址/结束地址 idc.get_next_func(ea) / idc.get_prev_func(ea)：返回ea所在函数的上一个/下一个函数的起始地址 指令相关API ida_ua.insn_t()，返回一个空的指令对象（或者说创建一个空的指令对象），包含函数的一些属性 idaapi.decode_insn(out,ea)，解析ea所在处的指令，把解析的结果给out（out必须是一个指令对象） out.ea：指令的起始地址 out.size：指令占用的字节数 out.get_cannon_mnemonic()：指令的助记符 out.itype：助记符的十进制码 操作数相关API idc.get_operand_value(ea,n)：返回ea处第n个操作数的值 idc.get_operand_type(ea,n)：返回ea处第n个操作数的类型 数据读写相关API idc.get_bytes(ea,size)：返回ea处size大小的bytes idc.patch_byte(ea,content)：修改ea处的1字节为content idc.patch_word(ea,content)：修改ea处的2字节为content idc.patch_dword(ea,content)：修改ea处的4字节为content idc.patch_qword(ea,content)：修改ea处的8字节为content 调试相关API ida_dbg.load_debugger(“local”,0)：启动调试器 ida_dbg.add_bpt(ea)：在ea处下断点 ida_dbg.del_bpt(ea)：删除ea处断点 ida_dbg.start_process(path,args,sdir)：启动调试进程，参数对应路径、命令行参数、工作目录 ida_dbg.step_into()：单步步入 ida_dbg.step_over()：单步步过 ida_dbg.step_until_ret()：运行到返回 idc.get_reg_value(regname)：获取regname寄存器的值 idc.set_reg_value(value,regname)：设置regname寄存器的值 其他操作相关API idautils.XrefsFrom(ea)：返回ea处引用的对象（有属性frm、to、type） idautils.XrefsTo(ea)：返回所有引用ea处的对象（有属性frm、to、type）（Ctrl+X） 示例： 1234567import idautils,idaapifor xref in idautils.XrefsTo(here()): print(xref.to)#here() print(xref.frm)#调用here()的函数地址for xref in idautils.XrefsFrom(here()): print(xref.frm)#here() print(xref.to)#here()引用的函数地址 idautils.Strings()：返回包含所有字符串的对象（有属性ea、length、strtype）（shift+F12） idc.get_strlit_contents(ea)：返回ea处的字符串 示例： 12345import idc,idautilsfor s in idautils.Strings(): string=idc.get_strlit_contents(s.ea) print(string)#打印所有字符串 自修改代码（SMC） 自修改代码（Self-Modifying-Code）指某部分代码以加密后的形式存在于程序中，程序执行到这部分代码的时候才会进行动态解密，和加壳有点异曲同工。常用来加密关键逻辑，使其不可直接静态分析 特征： 程序中存在对程序自身某部分的运算，一般还需要VirtualProtect() / mprotect()来改变内存的属性以便将解密后的代码数据写入内存，或者使用VirtualAlloc把解密后的代码数据写入堆中执行（为了避免API暴露，还可能会新增一个有RWX属性的段来存放加密后的代码）。 应对方法有两种：一种是动态调试得到解密后的关键逻辑，另一种是使用脚本解密关键逻辑后再覆盖回去 示例：2021-羊城杯-babysmc PS：本来想要自己写一个简单程序试试手的，研究了半个下午没研究出来，程序修正到解密函数可以解密出正确代码了，但是调用关键逻辑check的时候莫名其妙跑飞了，在那个安全检查的位置，跳转后像是个畸形函数，不知道是不是改内存属性的时候影响到了，所以只能去找网上的题目了 这是优化后的主函数： 优化的来源就是，enc的位置是一团数字，而loc_7FF6BF081D00处开始是正常代码，加上对下面的decrypt函数的分析，可以确定enc就是被加密后的first_part 这是decrypt函数： 非常明显地调用了VirtualProtect函数，解密逻辑很简单，就是ror后异或0x5a（ror查出来是循环右移，3就是右移的位数了，这点看汇编可能更清晰点） 下面就是今天的成果展示了（ror由DS协助实现），SMC解密脚本： 12345678910111213import idautils,idc,idaapienc=idc.get_bytes(0x00007FF6BF081085,0x00007FF6BF081D00-0x00007FF6BF081085)loc=0x00007FF6BF081085def ror(value, shift, bits=8): shift %= bits # 确保位移量在有效范围内 return (value &gt;&gt; shift) | ((value &lt;&lt; (bits - shift)) &amp; ((1 &lt;&lt; bits) - 1))for i in enc: idc.patch_byte(loc,(ror(i,3)^0x5a)&amp;0xff) loc+=1print(&quot;done&quot;) 本来是要写完的，但是first_part的函数解析完好几百行了，是我看不懂的加密🫠去找WP，发现是非常混淆的base64，还加了异或，但是我没看出逻辑，索性点到为止，改天把编码和密码的部分补上再说。 本来也尝试了动调解密，但是调着调着给我下起东西来了，虽然链接看着是微软的，但是还是有点怕，就舍弃这个方法了（下的是kernel.pdb好像，DS说是缺失符号文件🫠🫠）","link":"/2025/08/05/Day14-IDApython%E4%B8%8ESMC/"},{"title":"Day15:指令虚拟化","text":"指令虚拟化、实现一个小型虚拟机程序、VM逆向实践 什么是指令虚拟化 CPU厂商在开发CPU前会制定一个规范，建立起数据和操作的对应关系（如x86-64规定0x30对应异或操作），而这个数据又可以根据操作命名出汇编指令（如0x30命名为xor），因此有了数据与操作的对应关系和汇编指令与操作的对应关系，称之为指令集。CPU可以视作一个解释器，负责读取数据或者汇编指令然后带动机器产生操作。 通俗的讲，指令虚拟化实际上就是自定义指令集并为自己的指令集构建解释器，用自定义的指令实现程序的过程。这个过程利用高级语言代码实现，也就是用软件来模拟硬件，类似于虚拟机，因此称之为指令虚拟化。 实现指令虚拟化，需要定义寄存器变量（至少需要一个EIP来指向运行的指令）、内存空间数组、解释器和指令数组。 实现自定义指令集的解释器，可以采用C语言的switch（其中code是自定义指令，通过循环输入）： 1234567891011//解释器：1输出11111，2输出22222，3输出33333switch(code):case 1: printf(&quot;11111&quot;); break;case 2: print(&quot;22222&quot;); break:case 3: print(&quot;33333&quot;); break; 实现一个小型虚拟机程序 尝试编写一个输入两个数，输出和的程序 声明虚拟硬件结构体1234567typedef struct{ unsigned int r1;//寄存器r1 unsigned int r2;//寄存器r2 unsigned int eip;//寄存器eip unsigned char mem[256];//虚拟内存数组 unsigned char code[1024];//指令数组} VM; 定义指令集 使用op1、op2表示指令后面跟的操作数，寄存器作为隐式参数不会出现在code中 指令 使用格式 对应汇编指令/伪代码 操作解读 0x10 0x10,op1 mov r1,mem[op1] r1=mem[op1] 0x11 0x11,op1 mov r2,mem[op1] r2=mem[op1] 0x20 0x20 add r1,r2 r1+=r2 0x30 0x30,op1,op2 scanf-&gt;mem[op1],mem[op2] 输入给mem[op1]，mem[op2] 0x40 0x40 printf r1 输出r1的值 0x50 0x50 ret return 1 编写解释器123456789101112131415161718192021222324252627282930313233343536373839404142int vm_run(VM* vm) { char opcode;//用来存放指令 char op1, op2;//用来存放操作数 while (1) { opcode = vm-&gt;code[vm-&gt;eip];//读取eip指向的指令 switch (opcode) { case 0x10: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r1 = vm-&gt;mem[op1];//r1=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x11: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r2 = vm-&gt;mem[op1];//r2=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x20: vm-&gt;r1 += vm-&gt;r2;//r1+=r2 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x30: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数1 op2 = vm-&gt;code[vm-&gt;eip + 2];//获取操作数2 scanf(&quot;%d %d&quot;, &amp;vm-&gt;mem[op1], &amp;vm-&gt;mem[op2]);//输入给mem[op1]，mem[op2] vm-&gt;eip += 3;//跳转到下一条指令（指令+操作数占3个索引位） break; case 0x40: printf(&quot;%d&quot;, vm-&gt;r1);//输出r1的值 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x50: return 1;//循环终止，函数返回，虚拟机关机 } }} 指令数组12345678unsigned char code[]={ 0x30,0x0,0x1,//输入给mem[0]，mem[1] 0x10,0x0,//r1=mem[0] 0x11,0x1,//r2=mem[1] 0x20,//r1+=r2 0x40,//输出r1的值 0x50//虚拟机关机} 完整程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef struct{ unsigned int r1;//寄存器r1 unsigned int r2;//寄存器r2 unsigned int eip;//寄存器eip unsigned char mem[256];//虚拟内存数组 unsigned char code[1024];//指令数组} VM;unsigned char code[]={ 0x30,0x0,0x1,//输入给mem[0]，mem[1] 0x10,0x0,//r1=mem[0] 0x11,0x1,//r2=mem[1] 0x20,//r1+=r2 0x40,//输出r1的值 0x50//虚拟机关机};VM* vm_new() { VM* vm = (VM*)malloc(sizeof(VM));//为虚拟硬件结构体申请空间 memset(vm, 0, sizeof(VM));//初始化结构体 memcpy(vm-&gt;code, code, sizeof(code));//初始化code return vm;}int vm_run(VM* vm) { char opcode;//用来存放指令 char op1, op2;//用来存放操作数 while (1) { opcode = vm-&gt;code[vm-&gt;eip];//读取eip指向的指令 switch (opcode) { case 0x10: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r1 = vm-&gt;mem[op1];//r1=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x11: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数 vm-&gt;r2 = vm-&gt;mem[op1];//r2=mem[op1] vm-&gt;eip += 2;//跳转到下一条指令（指令+操作数占2个索引位） break; case 0x20: vm-&gt;r1 += vm-&gt;r2;//r1+=r2 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x30: op1 = vm-&gt;code[vm-&gt;eip + 1];//获取操作数1 op2 = vm-&gt;code[vm-&gt;eip + 2];//获取操作数2 scanf(&quot;%d %d&quot;, &amp;vm-&gt;mem[op1], &amp;vm-&gt;mem[op2]);//输入给mem[op1]，mem[op2] vm-&gt;eip += 3;//跳转到下一条指令（指令+操作数占3个索引位） break; case 0x40: printf(&quot;%d&quot;, vm-&gt;r1);//输出r1的值 vm-&gt;eip += 1;//跳转到下一条指令（只有指令，占1个索引位） break; case 0x50: return 1;//循环终止，函数返回，虚拟机关机 } }}int main() { VM* vm = vm_new();//生成一个虚拟机 if (vm_run(vm))//运行虚拟机 system(&quot;pause&quot;); return 0;} 简单示例的逆向 VM题最显著的特征应该就是虚拟硬件结构体的初始化和解释器了。解决这类问题，需要先复刻出一个解释器，通过在解释器中增加打印分析出的代码的操作，来得到去虚拟化的原程序，进而可以正常逆向分析 先来看main函数： 下面三个带字符串的函数可以看出是printf和system 看看v1=后面的函数 目前没什么明显的VM特征 再看看if括号里的函数 看到出现switch了，开始推测是VM的解释器 回到上一个函数，发现确实和VM的初始化函数很像，最后面一个函数的第二个参数对应出来的是一堆数字，和初始化code对应上了 OK，那就对伪代码进行一点点优化，然后开始分析解释器 1234567891011121314151617181920212223242526272829303132333435363738//推测虚拟硬件结构体__int64 __fastcall vm_run(unsigned int *vm){ sub_140001940(&amp;unk_1401150A2); while ( 1 ) { switch ( *((_BYTE *)vm + vm[2] + 268) )//vm+268是code所在，结合下文分析，加上vm[2]就构成了code[eip] { case 0x10: *vm = *((char *)vm + vm[2] + 269);//*vm=code[eip+1]，vm应该是一个寄存器，这句是mov r1,op1 vm[2] += 2;//每个case都有，推测是eip。+=2，说明有一个操作数 break; case 0x11: vm[1] = *((char *)vm + vm[2] + 269);//vm[1]=code[eip+1]，vm[1]应该也是一个寄存器,这句是mov r2,op1 vm[2] += 2;//有一个操作数 break; case 0x20: *((_BYTE *)vm + *((char *)vm + vm[2] + 269) + 12) = *((_BYTE *)vm + vm[2] + 270); //*((char *)vm + vm[2] + 269)是code[eip+1]，即op1，所以左边是vm+12+op1，推测vm+12是虚拟内存，刚好跨过三个连续的int型寄存器 //右边即vm+vm[2]+268+2即code[eip+2]，即op2 vm[2] += 3;//有两个操作数 break; case 0x30: *((_BYTE *)vm + *vm + 12) ^= *((_BYTE *)vm + 4);//mem[r1]^=r2 ++vm[2];//无操作数 break; case 0x40: sub_140001610(&amp;unk_1400D74B0, vm + 3);//unk这个是%5s，所以这是scanf。这里的vm是int，加三跳过了单个寄存器，是mem[0] ++vm[2];//无操作数 break; case 0x50: return sub_1400D4430(vm + 3, (char *)vm + *((char *)vm + vm[2] + 269) + 12, *((char *)vm + vm[2] + 270)); //三个参数分别为mem[0],mem[op1],op2，推测是memcmp（怎么没暗示操作数个数 default: continue; } }} 推测虚拟硬件结构体如下： 1234567typedef struct{ unsigned int r1; unsigned int r2; unsigned int eip; unsigned char mem[268-3*4=256]; unsigned char code[36];} VM; 带输出分析出来的代码的解释器如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int vm_run(VM* vm) { char opcode; char op1, op2; while (1) { opcode = vm-&gt;code[vm-&gt;eip]; switch (opcode) { case 0x10: vm-&gt;r1 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r1,&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; endl; break; case 0x11: vm-&gt;r2 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r2,&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x20: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; vm-&gt;mem[op1] = op2; vm-&gt;eip += 3; cout &lt;&lt; &quot;mov mem[&quot; &lt;&lt; (int)op1 &lt;&lt; &quot;],&quot; &lt;&lt; op2 &lt;&lt; endl; break; case 0x30: vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2; ++vm-&gt;eip; cout &lt;&lt; &quot;xor mem[&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; &quot;],&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x40: scanf(&quot;%5s&quot;, &amp;vm-&gt;mem[0]); ++vm-&gt;eip; printf(&quot;scanf mem\\n&quot;); break; case 0x50: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; return memcmp(&amp;vm-&gt;mem[0], &amp;vm-&gt;mem[op1], op2); } }} 完整的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;typedef struct { unsigned int r1; unsigned int r2; unsigned int eip; unsigned char mem[256]; unsigned char code[36];} VM ;unsigned char code[] = { 0x20, 0x10, 0x48, 0x20, 0x11, 0x65, 0x20, 0x12, 0x6C, 0x20, 0x13, 0x6C, 0x20, 0x14, 0x6F, 0x40, 0x11, 0x21, 0x10, 0x00, 0x30, 0x10, 0x01, 0x30, 0x10, 0x02, 0x30, 0x10, 0x03, 0x30, 0x10, 0x04, 0x30, 0x50, 0x10, 0x05};VM* vm_new() { VM* vm = (VM*)malloc(sizeof(VM)); memset(vm, 0, sizeof(VM)); memcpy(vm-&gt;code, code, sizeof(code)); return vm;}int vm_run(VM* vm) { char opcode; char op1, op2; while (1) { opcode = vm-&gt;code[vm-&gt;eip]; switch (opcode) { case 0x10: vm-&gt;r1 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r1,&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; endl; break; case 0x11: vm-&gt;r2 = code[vm-&gt;eip + 1]; vm-&gt;eip += 2; cout &lt;&lt; &quot;mov r2,&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x20: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; vm-&gt;mem[op1] = op2; vm-&gt;eip += 3; cout &lt;&lt; &quot;mov mem[&quot; &lt;&lt; (int)op1 &lt;&lt; &quot;],&quot; &lt;&lt; op2 &lt;&lt; endl; break; case 0x30: vm-&gt;mem[vm-&gt;r1] ^= vm-&gt;r2; ++vm-&gt;eip; cout &lt;&lt; &quot;xor mem[&quot; &lt;&lt; vm-&gt;r1 &lt;&lt; &quot;],&quot; &lt;&lt; vm-&gt;r2 &lt;&lt; endl; break; case 0x40: scanf(&quot;%5s&quot;, &amp;vm-&gt;mem[0]); ++vm-&gt;eip; printf(&quot;scanf mem\\n&quot;); break; case 0x50: op1 = code[vm-&gt;eip + 1]; op2 = code[vm-&gt;eip + 2]; return memcmp(&amp;vm-&gt;mem[0], &amp;vm-&gt;mem[op1], op2); } }}int main() { VM* vm = vm_new(); if (vm_run(vm)) printf(&quot;failed\\n&quot;); else printf(&quot;good\\n&quot;); system(&quot;pause&quot;); return 0;} 这样我们得到了原程序的汇编代码（参杂着奇怪的代码） 12345678910111213141516171819mov mem[16],Hmov mem[17],emov mem[18],lmov mem[19],lmov mem[20],o12345scanf memmov r2,33mov r1,0xor mem[0],33mov r1,1xor mem[1],33mov r1,2xor mem[2],33mov r1,3xor mem[3],33mov r1,4xor mem[4],33failed 可以看到，程序先把”Hello”传给了mem的一片区域，然后获取输入，把输入的数与33异或，最后执行返回处的判断。返回处是对比mem[0]和mem[op1]，对比op2位，结合code最后几位，知道是对比mem[0]和mem[16]，对比5位。所以要求的输入是”Hello”逐位异或的结果（不可见字符，尝试输入失败）","link":"/2025/08/06/Day15-%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"title":"Day2:寻址方式、标志寄存器、JCC指令","text":"寻址方式、标志寄存器、JCC指令 寻址方式 寻址方式 示例 典型用途 立即数寻址 mov eax,42 加载常数 寄存器寻址 add eax,ebx 寄存器运算 直接寻址 mov eax,[0x8040000] 访问全局变量 寄存器间接寻址 mov eax,[esi] 指针解引用 基址寻址 mov [ebp-4],ecx 栈帧局部变量 变址寻址 mov eax,[esi*4] 数组遍历 基址变址寻址 mov eax,[ebx+esi*2+8] 结构体，多维数组 相对寻址 jmp label 跳转，函数调用 标志寄存器 标志位 名称 作用 CF Carry Flag 进位标志位 最高位发生进位/借位时置1 PF Parity Flag 奇偶标志位 1的个数为偶数时置1 AF Auxiliary Carry Flag 辅助进位标志位 bit3和bit4之间发生进位/借位时置1 ZF Zoro Flag 零标志位 为0时置1 SF Sign Flag 符号标志位 最高位为1(负数)时置1 OF Overflow Flag 溢出标志位 有符号数溢出时置1 DF Direction Flag 方向标志位 为1时从高位到低位处理字符串，std打开，cld关闭 IF Interrupt Flag 中断标志位 为1时可以响应中断请求，sti打开，cli关闭 TF Trap Flag 陷阱标志位 为1时会触发异常，被调试器捕获，用于单步调试 JCC指令 TEST指令：TEST op1,op2 将两个操作数进行&amp;操作（op1 &amp; op2）并更新标志位： CF=0，OF=0 &amp;结果为0：ZF=1 结果最高位为1：SF=1 CMP指令：CMP op1,op2 进行减法操作（op1 - op2）并更新标志位： 若op1 &lt; op2（发生借位），CF=1 若发生有符号溢出，OF=1 op1 == op2（结果为0），ZF=1 op1 &lt; op2（结果为负数），SF=1 JCC指令：JCC Label 指令 条件 描述 JMP 无条件 无条件跳转 JE / JZ ZF=1 Jump if Equal / Jump if ZF JNE / JNZ ZF=0 Jump if Not Equal / Jump if Not ZF JS SF=1 Jump if SF JNS SF=0 Jump if Not SF JP / JPE PF=1 Jump if PF / Jump if Parity Even JNP / JPO PF=0 Jump if Not PF / Jump if Parity Odd JO OF=1 Jump if OF JNO OF=0 Jump if Not OF JB / JNAE / JC CF=1 Jump if Below / Jump if Not Above or Equal / Jump if CF JNB / JAE / JNC CF=0 Jump if Not Below / Jump if Above or Equal / Jump if Not CF JBE / JNA CF=1 或 ZF=1 Jump if Below or Equal / Jump if Not Above JA / JNBE CF=0 且 ZF=0 Jump if Above / Jump if Not Below or Equal JL / JNGE SF ≠ OF Jump if Less / Jump if Not Greater or Equal JGE / JNL SF = OF Jump if Greater or Equal / Jump if Not Less JLE / JNG ZF=1 或 SF ≠ OF Jump if Less or Equal / Jump if Not Greater JG / JNLE ZF=0 且 SF = OF Jump if Greater / Jump if Not Less or Equal","link":"/2025/07/07/Day2-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"},{"title":"Day16:Z3求解器","text":"z3求解器 基本数据类型 Int：整数 BitVec：二进制数据（如BitVec(‘a’,8)：8个比特位的一个变量a） Real：有理数 Bool：布尔值 Array：数组 基本流程设变量 使用基本数据类型来声明变量，如：x=Int(‘x’) 创建求解器 使用函数Solve()创建一个求解器：s=Solver() 添加约束条件 使用函数add()添加约束条件：s.add(一个方程/不等式) 判断是否有解 使用函数check()检查是否有解，有解返回’sat’，无解返回’unsat’ 取解的交集 使用函数model()取满足每个条件的解的交集，返回的是字典，用model[变量名]可以得到变量的解 示例解方程{x,y|30x+15y=675,12x+5y=265} 1234567891011from z3 import *x=Int('x')y=Int('y')s=Solver()s.add(30*x+15*y==675)s.add(12*x+5*y==265)if s.check()==sat: print(s.model())#得到解[x = 20, y = 5]","link":"/2025/08/21/Day16-Z3/"},{"title":"Day17:python逆向","text":"pyc逆向，python可执行文件逆向 pyc文件 pyc文件是py文件编译过程中产生的中间文件，是一种二进制文件。pyc文件可以由python虚拟机直接执行。不同版本的python编译出来的pyc文件是不同的 pyc文件结构 一个pyc文件由以下几个部分组成： 其中CodeObject是经过序列化处理的python源码的二进制码 pyc字节码 pyc文件是二进制文件，因此也可以进行反汇编。pyc文件有专门的汇编代码，就像java有smali汇编一样。 下面是一个pyc文件的反汇编代码 1234567891011121314151617181920212223242526272829303132原代码行号|指令的偏移|指令符号|指令参数（索引值）|参数实际值 0 0 RESUME 0 1 2 LOAD_CONST 0 (&lt;code object add at 0x00000186246D3770, file &quot;test.py&quot;, line 1&gt;) 4 MAKE_FUNCTION 0 6 STORE_NAME 0 (add)//把add函数存入函数表，给索引值0 3 8 PUSH_NULL 10 LOAD_NAME 1 (print)//加载函数表索引为1的函数print 12 LOAD_CONST 1 ('hello python')//加载常量表索引为1的&quot;hello python&quot; 14 CALL 1//call索引为1的函数print 22 POP_TOP 4 24 PUSH_NULL 26 LOAD_NAME 1 (print) 28 PUSH_NULL 30 LOAD_NAME 0 (add) 32 LOAD_CONST 2 (1) 34 LOAD_CONST 3 (2) 36 CALL 2 44 CALL 1 52 POP_TOP 54 RETURN_CONST 4 (None)Disassembly of &lt;code object add at 0x00000186246D3770, file &quot;test.py&quot;, line 1&gt;: 1 0 RESUME 0 2 2 LOAD_FAST 0 (a) 4 LOAD_FAST 1 (b) 6 BINARY_OP 0 (+) 10 RETURN_VALUE 对上面的一些指令进行解释： LOAD_CONST用于加载常量，后面跟着的数字是常量在常量表中的索引 LOAD_NAME用于加载函数，后面跟着的数字是函数在函数表中的索引 LOAD_FAST用于加载局部变量（如函数定义时候的参数或者内部变量） 可以注意到LOAD_NAME总是先于LOAD_CONST的，即函数比参数先一步加载 python虚拟机是基于栈的，所以可以看到POP等字眼，LOAD系列操作实际上是入栈操作 pyc文件逆向 未经过混淆的pyc文件，可以直接通过在线工具（如：在线Python pyc文件编译与反编译）或者uncompyle6、decompyle3（均可通过pip install安装）转成python代码 pyc文件的混淆，就类似花指令，通过在汇编层面插入垃圾指令干扰静态分析。解决办法就是修改二进制文件，把垃圾指令的二进制码给删除。可以看看这篇： Python代码保护 | pyc 混淆从入门到工具实现 - 知乎 python可执行文件 python文件可以被打包成可执行文件，默认图标长这样： 对于此类问题，先使用pyinstxtractor解包程序（这里拿一个不知道哪里来的pythonexe文件举例）： pyinstxtractor会把可执行文件解包到带后缀extracted的一个文件夹里，除此之外可以看到，程序会给出可能的入口文件，以及可执行文件的python版本，然后就可以分析这些pyc文件了 python文件被打包的时候还可以指定加密参数，解密的时候根据打包的pyinstaller版本可以分为两种，大于4.0的和小于4.0的，可以使用下面的脚本解密： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//大于4.0版本import tinyaesimport zlibCRYPT_BLOCK_SIZE=16key = butes('here_be_your_key','utf-8')inf=open('here_be_your_file_name','rb')outf=open('here_be_your_output_file','wb')iv=inf.read(CRYPT_BLOCK_SIZE)cipher=tinyaes.AES(key,iv)plaintext=zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))outf.write(b'\\x55\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0')#here be your magic number from pyfile in the same dir,16bytesoutf.write(plaintext)inf.close()outf.close()//小于4.0版本from Crypto.Cipher import AESimport zlibCRYPT_BLOCK_SIZE=16key=b'here_be_your_key'inf=open('here_be_your_cryptedfile_name','rb')outf=open('here_be_your_output_file_name','wb')iv=inf.read(CRYPT_BLOCK_SIZE)cipher-AES.new(key,AES.MODE_CFB,iv)plaintext=zlib.decompress(cipher,hecrypt(inf.read())) outf.write('here_be_your_magicnumber')#8bytesoutf.write(plaintext)inf.close()outf.close() 代码里面的key可以找可疑的pyc文件转成python代码查看，而版本可以通过查看pyimod01_archive.pyc导入的加密库来识别（上面两个版本的脚本导入的加密库分别是tinyaes和AES，是不一样的）","link":"/2025/10/05/Day17-python%E9%80%86%E5%90%91/"},{"title":"Day4:Linux汇编框架、操作系统与汇编器、主函数跳转流程","text":"Linux汇编框架、操作系统与汇编器、主函数跳转流程 Linux(NASM)汇编框架 Linux和Windows的不同主要有： 系统调用方式不同： Windows提供API，可以直接利用系统函数 Linux需要用系统调用号触发系统调用。系统调用号存入特定寄存器后使用触发指令，触发系统调用 触发指令： ​ 32位(x86)：int 0x80 ​ 64位(x64)：syscall 参数传递： ​ 32位：eax（系统调用号），ebx、ecx、edx、esi、edi、ebp（参数）。 ​ 64位：rax（系统调用号），rdi、rsi、rdx、r10、r8、r9（参数）。 32位下exit示例： 12mov eax,1 ;32位下，exit的系统调用号为1int 0x80 ;系统调用号存入寄存器后，触发系统调用 可执行文件格式不同： Windows使用PE文件格式 Linux使用ELF文件格式 其他细节： Linux在段名前必须添加section，只有.text段没有.code段（实际上由汇编器决定，详见下一部分） Linux使用0xA作为字符串结束符 32位汇编框架 12345678910111213141516section .data msg db &quot;HelloWorld&quot;,0xA len equ $ - msg ;用变量len记录msg的长度（$表示当前变量的地址，减去msg的地址就是msg的长度） section .text global _start_start: mov eax,4 ;eax存放系统调用号4：sys_write mov ebx,1 ;参数1：文件描述符，1表示标准输出stdout mov ecx,msg ;参数2：要打印的数据地址 mov edx,len ;参数3：打印的字节数 int 0x80 mov eax,1 ;eax存放系统调用号1：sys_exit mov ebx,0 ;参数1：退出状态码（0表示成功） int 0x80 64位汇编框架 12345678910111213141516section .data msg db &quot;HelloWorld&quot;,0xA len equ $ - msg section .text global _start_start: mov rax,1 ;rax存放系统调用号1：sys_write mov rdi,1 ;参数1：文件描述符，1表示标准输出stdout mov rsi,msg ;参数2：要打印的数据地址 mov rdx,len ;参数3：打印的字节数 syscall mov rax,60 ;rax存放系统调用号60：sys_exit xor rdi,rdi ;参数1：退出状态码（0表示成功） syscall 操作系统与汇编器 Windows：主要有MASM和NASM两种汇编器 MASM（Microsoft Macro Assembler），主要集成在visual studio中 段名前不要求加section，可以直接用 .段名 声明 指令存放在.code段 .code段，函数以 func_name proc 开始，以 func_name endp 结束 使用Intel风格，即 指令 目标操作数，源操作数 NASM（Netwide Assembler），跨平台汇编器，支持Windows、Linux、macOS 段名前要求加section，用 sectino .段名 声明 指令存放在.text段 .text段，函数用 global func_name 声明后再定义 使用Intel风格 Linux：主要有NASM和GAS两种汇编器 NASM同上 GAS（GNU Assembler），Linux默认汇编器 段名前要求加.section，用 .section .段名 声明 指令存放在.text段 .text段，函数用 .global func_name 声明后再定义 使用AT&amp;T风格，即 指令 源操作数，目标操作数 主函数跳转流程 环境：vs2022，Debug x86/x64，Release x86/x64 123456789101112131415161718192021222324252627;x86 debug 跳转特征;step1jmp ;直接jmp;step2call ;第一个call;step3callcall &lt;-- ;连续两个call，进第二个;step42*jz--&gt;callmovcall ;两个jz指向的同一个call且此call后紧跟mov和call;step5movpushmovpushmovpushcall ;连续push3个参数入栈后的call;step6jmp 12345678910;x86 Release 跳转特征;step1calljmp ;call后的jmp;step2pushpushpushcall ;连续push3个参数入栈后的call 1234567891011121314151617181920212223242526;x64 Debug 跳转特征 ;step1jmp ;直接jmp;step2call ;第一个call;step3callcall &lt;-- ;连续两个call进第二个;step42*jz--&gt;callmovcall ;两个jz指向的同一个call且此call后紧跟mov和call;step5movmovmovmovmovcall ;连续5个mov后的call（传参）;step6jmp ;直接jmp 123456789101112;x64 Release 跳转特征 ;step1calljmp ;call后的jmp;step2movmovmovcallmovcall ;三个mov后的call（传参）且此call后紧跟mov和call","link":"/2025/07/11/Day4-Linux%E6%B1%87%E7%BC%96%E6%A1%86%E6%9E%B6/"},{"title":"Day3:函数与栈帧、数组与串指令、宏与结构体、x64汇编框架、内联汇编与混合编程","text":"函数与栈帧、数组与串指令、宏与结构体、x64汇编框架、内联汇编与混合编程 函数与栈帧 “栈“是内存中的一部分，可以理解为连续的一块内存，它为程序运行提供了一个暂时的存放数据的地方，地址、数据等可以通过push指令从寄存器中被复制到栈中，进而寄存器可以进行其他操作，等到这些数据再次被需要时再从栈中被pop出来。栈遵循先进后出的规则，先push的在高地址，后push的在低地址 在程序运行时，每个函数都会拥有独立的栈帧，即独立的栈上的一部分空间。有两个寄存器，esp，ebp（x86即32位环境下）负责维护函数的栈空间。ebp存放的是函数栈空间的栈基址，esp存放的是函数栈空间的栈顶。可以理解为ebp是指向函数栈空间最高位的一个指针（因为栈空间从高地址开始分配，因此指向的是最高位，但是是栈空间的起始地址），而esp是指向函数栈空间最低位的一个指针（指向的是最低位，但是会随着后续栈空间的扩充而变化）。 CALL指令： 123;call一个函数的时候，会发生以下内容push 返回地址（call所在指令的下一条）jmp 目标函数地址 RET指令： 12;函数结束时，RET指令会发生以下内容pop eip ;从栈上弹出返回地址到eip（保存下一步指令地址的寄存器） 栈帧： 1234567;跳转到每一个函数，会发生以下内容以开辟栈帧push ebp ;把上一个函数的ebp值放到栈上mov ebp,esp ;把esp值给ebp，开辟新函数的栈帧;函数执行完毕后，会发生以下内容清理栈帧mov esp,ebp ;把ebp值给esp，清理函数栈帧pop ebp ;恢复ebp原来的值，即上一个函数的ebpret 数组与串指令 声明数组： 123.data ;在数据段声明 szHello db 'HelloWorld',0 ;声明一个字符串 nNumber dd 20 dup(0) ;声明一个DWORD数组，20位，使用dup()初始化数组内容为0 使用数组基址的几种方式： 12lea eax,szHellomov ebx,offset Nnumber 访问数组成员： 1234567891011;[数组起始地址+索引寄存器*比例因子+偏移量]（索引寄存器用来存放索引值，比例因子对应类型的字节大小，偏移量可用于结构体数组等场景）;如：mov ebx,offset Array ;把数组基址给ebxmov esi,0 ;esi用来当索引寄存器mov ecx,10 ;ecx用来放索引上限（ecx常用作计数器）loop_start: ;创建一个循环 mov eax,[ebx+esi*4] ;取出数组内容放到eax中 add esi,1 ;索引递增 cmp esi,ecx ;与索引上限比较，判断是否遍历完数组 jl loop_start ;还没遍历完数组就循环操作，jump到loop_start再走一遍 串指令： 1234;stos系列:stosb,stosw,stosd,stosq（分别对应byte,word,dword,qword,功能是把al/ax/eax/rax中的内容存到edi/rdi）;lods系列:lodsb,lodsw,lodsd,lodsq（同样分别对应四个类型，功能是把esi/rsi的内容加载到al/ax/eax/rax中）;movs系列:movsb,movsw,movsd,movsq（同样分别对应四个类型，功能是把esi的内容复制到edi中）;cmps系列:cmpsb,cmpsw,cmpsd,cmpsq（同样分别对应四个类型，功能是比较esi和edi的内容并设置标志位） 宏与结构体 宏： 12345678;无参宏使用关键字EQU，如PI EQU 3 ;定义PI=3;含参宏使用关键字MACRO，用endm结尾，如Myadd MACRO Number add eax,Numberendm ;定义Myadd函数实现eax加上参数;含参宏的调用：Myadd&lt;参数&gt; 结构体： 1234567891011;使用关键字struct和ends，如Point struct x word ? y word ?Point ends;实例化结构体MyPoint Point&lt;?&gt; ;实例化出MyPoint;访问结构体成员mov MyPoint.x,123 x64汇编框架(MASM)1234567891011121314151617181920212223242526272829303132333435363738;x64环境下的代码，传参的时候先使用寄存器(Windows:rcx,rdx,r8,r9 Linux:rdi,rsi,rdx,rcx,r8,r9)再使用栈.code;Add函数声明Add proc push rbp mov rbp,rsp lea rax,[rdi + rsi] ;从寄存器中取参数 pop rbp retAdd endpmain proc mov rdi,2 ;把参数传入寄存器中 mov rsi,3 call Add retmain endpend;x86环境下的代码，传参使用栈.code;Add函数声明Add proc push ebp mov ebp,esp mov eax,[esp+8] ;从栈上取参数 add eax,[esp+12] pop ebp retAdd endpmain proc push 3 ;把参数压入栈中 push 2 call Add add esp,8main endp 内联汇编与混合编程 x86下，在Microsoft Visual C++ (MSVC)程序中使用汇编，可以通过_asm{}直接写在C++代码中: 123456789#include&lt;iostream&gt;int main(){ _asm{ xor eax,eax mov eax,1 add eax,1 } return 0;} x64下，在Microsoft Visual C++ (MSVC)程序中使用汇编，需要独立的asm文件，通过extern声明使用： 1234567891011121314151617181920#include&lt;iostream&gt;extern &quot;C&quot; long long Add(long long number1,long long number2);int main(){ long long res=Add(1,2); std::cout&lt;&lt;res&lt;&lt;std::endl; return 0;}//asm文件.codeAdd proc push rbp mov rbp,rsp xor rax,rax add rax,rcx add rax,rdx pop rbp retAdd endpend","link":"/2025/07/08/Day3-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A0%86%E6%A0%88/"},{"title":"Day6:if-else语句识别、switch语句识别、循环语句识别","text":"if-else语句识别、switch语句识别、循环语句识别 if-else语句识别 第一种，数值比较作为条件（x86debug为例，其余类似，仅是比较方法（如使用sub而不是cmp）和模式特征上的差异） 1234567891011121314151617.text:004702D0 lea eax, [ebp+var_C].text:004702D3 push eax.text:004702D4 push offset unk_545E50 ; %d.text:004702D9 call sub_4681E0 ; scanf.text:004702DE add esp, 8.text:004702E1 cmp [ebp+var_C], 1.text:004702E5 jnz short loc_4702F6 ; if [ebp+var_C]!=1, jump to loc_4702f6.text:004702E7 push offset aNEquales1 ; &quot;n equales 1&quot;.text:004702EC call sub_468D1B ; printf.text:004702F1 add esp, 4.text:004702F4 jmp short loc_470303.text:004702F6 ; ---------------------------------------------------------------------------.text:004702F6.text:004702F6 loc_4702F6: ; CODE XREF: main+45↑j.text:004702F6 push offset aNDoesNotEqual1 ; &quot;n does not equal 1&quot;.text:004702FB call sub_468D1B ; printf.text:00470300 add esp, 4 源码： 123456int n;scanf(&quot;%d&quot;, &amp;n);if (n == 1) printf(&quot;n equales 1&quot;);else printf(&quot;n does not equal 1&quot;); 第二种，变量直接作为条件 12345678910.text:00470303 lea eax, [ebp+var_18].text:00470306 push eax.text:00470307 push offset unk_545E50 ; %d.text:0047030C call sub_4681E0 ; scanf.text:00470311 add esp, 8.text:00470314 cmp [ebp+var_18], 0 ; 和'0'比较.text:00470318 jz short loc_470327 ; if [ebp+var_18]==0, jump to loc_470327, 跳过printf.text:0047031A push offset aJudgeIsNotZero ; &quot;judge is not zero&quot;.text:0047031F call sub_468D1B ; printf.text:00470324 add esp, 4 源码： 1234int judge;scanf(&quot;%d&quot;, &amp;judge);if (judge) printf(&quot;judge is not zero&quot;); 第三种，返回值（函数式）作为条件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.text:00470387 lea eax, [ebp+var_24].text:0047038A push eax.text:0047038B push offset unk_545E50 ; %d.text:00470390 call sub_4681E0 ; scanf.text:00470395 add esp, 8.text:00470398 mov eax, [ebp+var_24].text:0047039B push eax ; 输入的值入栈，即函数传参.text:0047039C call sub_46B214 ; 自定义函数.text:004703A1 add esp, 4.text:004703A4 test eax, eax ; 1 &amp; 1 = 0； 0 &amp; 0 = 1.text:004703A6 jz short loc_4703B5.text:004703A8 push offset aItS0 ; &quot;it's 0\\n&quot;.text:004703AD call sub_468D1B.text:004703B2 add esp, 4;sub_46b214.text:00470110 arg_0 = dword ptr 8.text:00470110.text:00470110 push ebp.text:00470111 mov ebp, esp.text:00470113 sub esp, 0C0h.text:00470119 push ebx.text:0047011A push esi.text:0047011B push edi.text:0047011C mov edi, ebp.text:0047011E xor ecx, ecx.text:00470120 mov eax, 0CCCCCCCCh.text:00470125 rep stosd.text:00470127 mov ecx, offset unk_57500E.text:0047012C call sub_46B660.text:00470131 nop.text:00470132 cmp [ebp+arg_0], 0 ; [ebp+8], eax在栈上的位置.text:00470136 jnz short loc_470141 ; eax=0.text:00470138 mov eax, 1 ; if [ebp+arg_0]==0, eax=1, return 1(eax).text:0047013D jmp short loc_470143.text:0047013F ; ---------------------------------------------------------------------------.text:0047013F jmp short loc_470143.text:00470141 ; ---------------------------------------------------------------------------.text:00470141.text:00470141 loc_470141: ; CODE XREF: sub_470110+26↑j.text:00470141 xor eax, eax ; eax=0.text:00470143.text:00470143 loc_470143: ; CODE XREF: sub_470110+2D↑j.text:00470143 ; sub_470110+2F↑j.text:00470143 pop edi.text:00470144 pop esi.text:00470145 pop ebx.text:00470146 add esp, 0C0h.text:0047014C cmp ebp, esp.text:0047014E call sub_46A62A.text:00470153 mov esp, ebp.text:00470155 pop ebp.text:00470156 retn 源码 1234567891011121314int IfZero(int a) { if (a == 0) return 1; else return 0;}int main(){ int a; scanf(&quot;%d&quot;, &amp;a); if(IfZero(a)) printf(&quot;it's 0\\n&quot;); return 0;} switch语句识别 比较简单的情况下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.text:00470327 lea eax, [ebp+var_24].text:0047032A push eax.text:0047032B push offset unk_545E50 ; %d.text:00470330 call sub_4681E0 ; scanf.text:00470335 add esp, 8.text:00470338 mov eax, [ebp+var_24].text:0047033B mov [ebp+var_EC], eax ; [ebp+var_EC]==[ebp+var_24], 用临时变量[ebp+var_EC]来检验case.text:00470341 cmp [ebp+var_EC], 1.text:00470348 jz short loc_47035E ; case1输出.text:0047034A cmp [ebp+var_EC], 5.text:00470351 jz short loc_470371 ; case5输出.text:00470353 cmp [ebp+var_EC], 0Ah.text:0047035A jz short loc_470384 ; case10输出.text:0047035C jmp short loc_470395 ; break然后system(&quot;pause&quot;).text:0047035E ; ---------------------------------------------------------------------------.text:0047035E.text:0047035E loc_47035E: ; CODE XREF: main+A8↑j.text:0047035E mov eax, [ebp+var_24].text:00470361 push eax.text:00470362 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470367 call sub_468D1B ; printf.text:0047036C add esp, 8.text:0047036F jmp short loc_470395.text:00470371 ; ---------------------------------------------------------------------------.text:00470371.text:00470371 loc_470371: ; CODE XREF: main+B1↑j.text:00470371 mov eax, [ebp+var_24].text:00470374 push eax.text:00470375 push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047037A call sub_468D1B ; printf.text:0047037F add esp, 8.text:00470382 jmp short loc_470395.text:00470384 ; ---------------------------------------------------------------------------.text:00470384.text:00470384 loc_470384: ; CODE XREF: main+BA↑j.text:00470384 mov eax, [ebp+var_24].text:00470387 push eax.text:00470388 push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047038D call sub_468D1B ; printf.text:00470392 add esp, 8.text:00470395.text:00470395 loc_470395: ; CODE XREF: main+BC↑j.text:00470395 ; main+CF↑j ....text:00470395 push offset aPause ; &quot;pause&quot;.text:0047039A call sub_46AFAD ; system(&quot;pause&quot;).text:0047039F add esp, 4 源码： 1234567891011121314int number;scanf(&quot;%d&quot;, &amp;number);switch (number) {case 1: printf(&quot;n equals %d&quot;, number); break;case 5: printf(&quot;n equals %d&quot;, number); break;case 10: printf(&quot;n equals %d&quot;, number); break;}system(&quot;pause&quot;); 再复杂点，会优化出跳转表，即每个case跳转的地址会被集合成一个数组，像表一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889.text:004702D3 push eax.text:004702D4 push offset unk_545E50 ; %d.text:004702D9 call sub_4681E0 ; scanf.text:004702DE add esp, 8.text:004702E1 mov eax, [ebp+var_C].text:004702E4 mov [ebp+var_D4], eax.text:004702EA mov ecx, [ebp+var_D4] ; 把输入值传到ecx，下一步减去1，减1的原因见后面的解释.text:004702F0 sub ecx, 1 ; switch 67 cases.text:004702F3 mov [ebp+var_D4], ecx.text:004702F9 cmp [ebp+var_D4], 42h ; 把输入值和42h(66)比较，下一步是大于66就跳出case的判断.text:00470300 ja def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470306 mov edx, [ebp+var_D4].text:0047030C movzx eax, ds:byte_470418[edx] ; 跳转表索引值表，即预判了输入值的范围并且为每个可能的值建立了索引值表（比如说现在确定了范围是0-66，就枚举了0-66这些数值对应的索引，然后再根据索引找到应改跳转的地址.text:00470313 jmp ds:jpt_470313[eax*4] ; switch jump.text:0047031A ; ---------------------------------------------------------------------------.text:0047031A.text:0047031A loc_47031A: ; CODE XREF: sub_4702A0+73↑j.text:0047031A ; DATA XREF: .text:jpt_470313↓o.text:0047031A mov eax, [ebp+var_C] ; jumptable 00470313 case 1.text:0047031D push eax.text:0047031E push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470323 call sub_468D1B ; printf.text:00470328 add esp, 8.text:0047032B jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:0047032D ; ---------------------------------------------------------------------------.text:0047032D.text:0047032D loc_47032D: ; CODE XREF: sub_4702A0+73↑j.text:0047032D ; DATA XREF: .text:jpt_470313↓o.text:0047032D mov eax, [ebp+var_C] ; jumptable 00470313 case 5.text:00470330 push eax.text:00470331 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470336 call sub_468D1B ; printf.text:0047033B add esp, 8.text:0047033E jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470340 ; ---------------------------------------------------------------------------.text:00470340.text:00470340 loc_470340: ; CODE XREF: sub_4702A0+73↑j.text:00470340 ; DATA XREF: .text:jpt_470313↓o.text:00470340 mov eax, [ebp+var_C] ; jumptable 00470313 case 10.text:00470343 push eax.text:00470344 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470349 call sub_468D1B ; printf.text:0047034E add esp, 8.text:00470351 jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470353 ; ---------------------------------------------------------------------------.text:00470353.text:00470353 loc_470353: ; CODE XREF: sub_4702A0+73↑j.text:00470353 ; DATA XREF: .text:jpt_470313↓o.text:00470353 mov eax, [ebp+var_C] ; jumptable 00470313 case 17.text:00470356 push eax.text:00470357 push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047035C call sub_468D1B ; printf.text:00470361 add esp, 8.text:00470364 jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470366 ; ---------------------------------------------------------------------------.text:00470366.text:00470366 loc_470366: ; CODE XREF: sub_4702A0+73↑j.text:00470366 ; DATA XREF: .text:jpt_470313↓o.text:00470366 mov eax, [ebp+var_C] ; jumptable 00470313 case 11.text:00470369 push eax.text:0047036A push offset aNEqualsD ; &quot;n equals %d&quot;.text:0047036F call sub_468D1B ; printf.text:00470374 add esp, 8.text:00470377 jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:00470379 ; ---------------------------------------------------------------------------.text:00470379.text:00470379 loc_470379: ; CODE XREF: sub_4702A0+73↑j.text:00470379 ; DATA XREF: .text:jpt_470313↓o.text:00470379 mov eax, [ebp+var_C] ; jumptable 00470313 case 67.text:0047037C push eax.text:0047037D push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470382 call sub_468D1B ; printf.text:00470387 add esp, 8.text:0047038A jmp short def_470313 ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:0047038C ; ---------------------------------------------------------------------------.text:0047038C.text:0047038C loc_47038C: ; CODE XREF: sub_4702A0+73↑j.text:0047038C ; DATA XREF: .text:jpt_470313↓o.text:0047038C mov eax, [ebp+var_C] ; jumptable 00470313 case 3.text:0047038F push eax.text:00470390 push offset aNEqualsD ; &quot;n equals %d&quot;.text:00470395 call sub_468D1B ; printf.text:0047039A add esp, 8.text:0047039D.text:0047039D def_470313: ; CODE XREF: sub_4702A0+60↑j.text:0047039D ; sub_4702A0+73↑j ....text:0047039D push offset aPause ; jumptable 00470313 default case, cases 2,4,6-9,12-16,18-66.text:004703A2 call sub_46AFAD ; system.text:004703A7 add esp, 4 源码 1234567891011121314151617181920212223242526int number;scanf(&quot;%d&quot;, &amp;number);switch (number) {case 1: printf(&quot;n equals %d&quot;, number); break;case 5: printf(&quot;n equals %d&quot;, number); break;case 10: printf(&quot;n equals %d&quot;, number); break;case 17: printf(&quot;n equals %d&quot;, number); break;case 11: printf(&quot;n equals %d&quot;, number); break;case 67: printf(&quot;n equals %d&quot;, number); break;case 3: printf(&quot;n equals %d&quot;, number); break;}system(&quot;pause&quot;); 对跳转表和索引值表进行进一步解释： 先看跳转表： 可以看到跳转表只有简单的8种情况。但是编译器（反编译器？）只能根据case的最大值用笨方法枚举可能的值，这时候，就可以给这些枚举的值分成两种：一种是case里有的，一种是case里没有的。看跳转表的最后一个，叫def而不是loc，这个就是给case里没有的枚举值准备的。因为分为case里有的和没有的，因此，case里有的，会给出具体的索引值；case里没有的，统一导向跳转表的最后一个。再看索引值表： 可以看到，里面枚举了0到66对应的索引值。看汇编代码，是将输入的值作为索引值表的索引来用的，索引出来的值再作为跳转表的索引。注意看，索引值表的最小值为0，因此，跳转表和数组一样从0开始索引，而0-7对应跳转表的八种情况。通过进一步挖掘信息，还可以知道跳转表是把case按照从小到大的顺序排列的。因此，最开始会对输入值有一个减的操作。至于为什么减1，我们就可以推测最小的case是1了，因为索引从0开始，而最小的case在索引0处。 这样解释下来可能还有点绕，所以我们按照机器的动作走一遍： 首先，把case按顺序排出跳转表。 然后，假设我们拿到输入的值。作为机器，我们知道case有：1，3，5，10，17，11，67，所以先给输入的值减1，以便这个值是1的时候我们可以索引到跳转表下标0处。同时，如果这个值大于66，我们还可以直接跳过case检查，直接导出去（刚好和在case最大最小值范围内但不是case的值一样对待） 再然后，我们枚举0-66的值，并且把这些值和case里有的值一一比较，分出两种值：一种在case里，一种不再case里。 ok，然后我们建立索引值表，给在case里的枚举值对应的跳转表索引值，比如说枚举值2（输入值是3），刚好case里有3，按顺序排第二，我们就给索引值1（从0开始索引）。回头看截出来的索引值表，在下标2的地方刚好是1（枚举值索引出跳转表索引）；给不在case里的值索引到7，对应跳转表最后一位（为没在case里的值专门准备的那一位）。 最后，我们就准备好我们的解决方案了，对于任意输入的值我们就都有对策了。 请务必真正理解上述内容，因为在逆向工程中，这么绕的操作很常见。在PE文件结构部分，我们或许还有机会再接触到这么绕的操作。（其实只需要写出程序拿到ida里点开跳转表和索引值表（如果有的话）看几眼就明白了，亲身实践总比阅读文字来的有效，因为文字还取决于书写者的表达水平(●’◡’●)） 循环语句识别 第一种，for循环 12345678910111213141516171819202122232425.text:00464096 mov [ebp+var_8], 0 ; 一个变量初始化为0.text:0046409D mov [ebp+var_14], 1 ; 另一个变量初始化为1.text:004640A4 jmp short loc_4640AF.text:004640A6 ; ---------------------------------------------------------------------------.text:004640A6.text:004640A6 loc_4640A6: ; CODE XREF: sub_464070+4E↓j.text:004640A6 mov eax, [ebp+var_14].text:004640A9 add eax, 1 ; 用eax过渡，给[ebp+var_14]加1.text:004640AC mov [ebp+var_14], eax.text:004640AF.text:004640AF loc_4640AF: ; CODE XREF: sub_464070+34↑j.text:004640AF cmp [ebp+var_14], 0Ah.text:004640B3 jg short loc_4640C0 ; [ebp+var_14]大于0Ah时跳转（出循环）.text:004640B5 mov eax, [ebp+var_8].text:004640B8 add eax, [ebp+var_14] ; 用eax过渡，把[ebp+var_14]的值加到[ebp+var_8]上.text:004640BB mov [ebp+var_8], eax.text:004640BE jmp short loc_4640A6 ; 跳回去，形成循环.text:004640C0 ; ---------------------------------------------------------------------------.text:004640C0.text:004640C0 loc_4640C0: ; CODE XREF: sub_464070+43↑j.text:004640C0 mov eax, [ebp+var_8].text:004640C3 push eax.text:004640C4 push offset aCountD ; &quot;count : %d &quot;.text:004640C9 call sub_45DB54 ; printf.text:004640CE add esp, 8 源码 12345int count = 0;for (int i = 1; i &lt;= 10; i++) { count += i;}printf(&quot;count : %d &quot;, count); 第二种，while循环 123456789101112131415161718192021.text:004640D1 mov [ebp+var_8], 0 ; 一个变量初始化为0.text:004640D8 mov [ebp+var_20], 0Ah ; 另一个变量初始化为10.text:004640DF.text:004640DF loc_4640DF: ; CODE XREF: sub_464070+87↓j.text:004640DF cmp [ebp+var_20], 0.text:004640E3 jle short loc_4640F9 ; [ebp+var_20]小于等于0时跳转（出循环）.text:004640E5 mov eax, [ebp+var_8].text:004640E8 add eax, [ebp+var_20] ; eax过渡，把[ebp+var_20]值加到[ebp+var_8]上.text:004640EB mov [ebp+var_8], eax.text:004640EE mov eax, [ebp+var_20].text:004640F1 sub eax, 1 ; eax过渡，给[ebp+var_20]减1.text:004640F4 mov [ebp+var_20], eax.text:004640F7 jmp short loc_4640DF ; 回跳，形成循环.text:004640F9 ; ---------------------------------------------------------------------------.text:004640F9.text:004640F9 loc_4640F9: ; CODE XREF: sub_464070+73↑j.text:004640F9 mov eax, [ebp+var_8].text:004640FC push eax.text:004640FD push offset aCountD ; &quot;count : %d &quot;.text:00464102 call sub_45DB54 ; printf.text:00464107 add esp, 8 源码 1234567int count = 0;int n = 10;while (n &gt; 0) { count += n; n--;}printf(&quot;count : %d &quot;, count); 第三种，do-while循环 1234567891011121314151617.text:0046410A mov [ebp+var_8], 0 ; 一个变量初始化为0.text:00464111 mov [ebp+var_2C], 0Ah ; 另一个变量初始化为10.text:00464118.text:00464118 loc_464118: ; CODE XREF: sub_464070+BE↓j.text:00464118 mov eax, [ebp+var_8].text:0046411B add eax, [ebp+var_2C] ; eax过渡，把[ebp+var_2C]值加到[ebp+var_8]上.text:0046411E mov [ebp+var_8], eax.text:00464121 mov eax, [ebp+var_2C].text:00464124 sub eax, 1 ; eax过渡，给[ebp+var_2C]减1.text:00464127 mov [ebp+var_2C], eax.text:0046412A cmp [ebp+var_2C], 0.text:0046412E jg short loc_464118 ; [ebp+var_2C]大于0时回跳.text:00464130 mov eax, [ebp+var_8].text:00464133 push eax.text:00464134 push offset aCountD ; &quot;count : %d &quot;.text:00464139 call sub_45DB54 ; printf.text:0046413E add esp, 8 源码 1234567int count = 0;int i = 10;do { count += i; i--;} while (i &gt; 0);printf(&quot;count : %d &quot;, count);","link":"/2025/07/15/Day6-switch%E8%AF%AD%E5%8F%A5%E8%AF%86%E5%88%AB/"},{"title":"Day8:thiscall、类","text":"thiscall、类 调用约定：thiscall 对于C++this指针的特性，有一种专门的调用约定叫thiscall，主要用于类出现的场景 无论x86/x64，this指针均由ecx/rcx扮演，指向对象的内存地址 thiscall由被调用者清理参数占用的栈空间 类（一） 简单的构造析构分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130;main函数.text:004641E0 var_EC = dword ptr -0ECh.text:004641E0 var_30 = byte ptr -30h.text:004641E0 var_20 = dword ptr -20h.text:004641E0 var_4 = dword ptr -4.text:004641E0.text:004641E0 push ebp.text:004641E1 mov ebp, esp.text:004641E3 sub esp, 0F0h.text:004641E9 push ebx.text:004641EA push esi.text:004641EB push edi.text:004641EC lea edi, [ebp+var_30].text:004641EF mov ecx, 0Ch.text:004641F4 mov eax, 0CCCCCCCCh.text:004641F9 rep stosd.text:004641FB mov eax, ___security_cookie.text:00464200 xor eax, ebp.text:00464202 mov [ebp+var_4], eax.text:00464205 mov ecx, offset unk_54D014.text:0046420A call sub_45FF30.text:0046420F nop.text:00464210 push offset aXiaoming ; 参数&quot;xiaoming&quot;.text:00464215 push 1 ; 另一个参数.text:00464217 lea ecx, [ebp+var_20] ; [ebp+var_20]是一个对象，this指针指向该对象.text:0046421A call sub_46062E ; 构造函数.text:0046421F nop.text:00464220 push offset aPause ; &quot;pause&quot;.text:00464225 call sub_45F98B ; system.text:0046422A add esp, 4.text:0046422D mov [ebp+var_EC], 0.text:00464237 lea ecx, [ebp+var_20] ; this指针.text:0046423A call sub_45D38E ; 析构函数.text:0046423F mov eax, [ebp+var_EC].text:00464245 push edx.text:00464246 mov ecx, ebp.text:00464248 push eax.text:00464249 lea edx, dword_464274.text:0046424F call sub_45EC4D.text:00464254 pop eax.text:00464255 pop edx.text:00464256 pop edi.text:00464257 pop esi.text:00464258 pop ebx.text:00464259 mov ecx, [ebp+var_4].text:0046425C xor ecx, ebp ; StackCookie.text:0046425E call j_@__security_check_cookie@4 ; __security_check_cookie(x).text:00464263 add esp, 0F0h.text:00464269 cmp ebp, esp.text:0046426B call sub_45F175.text:00464270 mov esp, ebp.text:00464272 pop ebp.text:00464273 retn;构造函数.text:00463FC0 var_C = byte ptr -0Ch.text:00463FC0 var_8 = dword ptr -8.text:00463FC0 arg_0 = dword ptr 8.text:00463FC0 arg_4 = dword ptr 0Ch.text:00463FC0.text:00463FC0 push ebp.text:00463FC1 mov ebp, esp.text:00463FC3 sub esp, 0CCh.text:00463FC9 push ebx.text:00463FCA push esi.text:00463FCB push edi.text:00463FCC push ecx.text:00463FCD lea edi, [ebp+var_C].text:00463FD0 mov ecx, 3.text:00463FD5 mov eax, 0CCCCCCCCh.text:00463FDA rep stosd.text:00463FDC pop ecx.text:00463FDD mov [ebp+var_8], ecx ; 当前对象地址保存到[ebp+var_8].text:00463FE0 mov ecx, offset unk_54D014.text:00463FE5 call sub_45FF30.text:00463FEA nop.text:00463FEB mov eax, [ebp+var_8] ; 第一个对象成员.text:00463FEE mov ecx, [ebp+arg_0] ; 第一个参数1.text:00463FF1 mov [eax], ecx.text:00463FF3 push 4.text:00463FF5 mov eax, [ebp+arg_4] ; 第二个参数&quot;xiaoming&quot;.text:00463FF8 push eax.text:00463FF9 mov ecx, [ebp+var_8].text:00463FFC add ecx, 4 ; 第二个对象成员.text:00463FFF push ecx.text:00464000 call sub_45FCF1 ; memcpy().text:00464005 add esp, 0Ch.text:00464008 mov eax, [ebp+var_8] ; 返回的是对象地址.text:0046400B pop edi.text:0046400C pop esi.text:0046400D pop ebx.text:0046400E add esp, 0CCh.text:00464014 cmp ebp, esp.text:00464016 call sub_45F175.text:0046401B mov esp, ebp.text:0046401D pop ebp.text:0046401E retn 8;析构函数.text:00464040 var_C = byte ptr -0Ch.text:00464040 var_8 = dword ptr -8.text:00464040.text:00464040 push ebp.text:00464041 mov ebp, esp.text:00464043 sub esp, 0CCh.text:00464049 push ebx.text:0046404A push esi.text:0046404B push edi.text:0046404C push ecx.text:0046404D lea edi, [ebp+var_C].text:00464050 mov ecx, 3.text:00464055 mov eax, 0CCCCCCCCh.text:0046405A rep stosd.text:0046405C pop ecx.text:0046405D mov [ebp+var_8], ecx ; 把对象地址存到[ebp+var_8].text:00464060 mov ecx, offset unk_54D014.text:00464065 call sub_45FF30.text:0046406A nop.text:0046406B push offset aDestructing ; &quot;destructing......&quot;.text:00464070 call sub_45DB59 ; printf.text:00464075 add esp, 4.text:00464078 pop edi.text:00464079 pop esi.text:0046407A pop ebx.text:0046407B add esp, 0CCh.text:00464081 cmp ebp, esp.text:00464083 call sub_45F175.text:00464088 mov esp, ebp.text:0046408A pop ebp.text:0046408B retn 源码 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;class Student {private: int ID; char name[20];public: Student(int n = 0, const char* na = &quot;NONE&quot;) :ID(n) { memcpy(name, na, sizeof(na)); } void show(); ~Student();};void Student::show() { printf(&quot;%d %s\\n&quot;, ID, name);}Student::~Student() { printf(&quot;destructing......&quot;);}int main() { Student stu(001, &quot;xiaoming&quot;); system(&quot;pause&quot;); return 0;}","link":"/2025/07/21/Day8-%E7%B1%BB/"},{"title":"Day7:数组与指针识别","text":"数组与指针识别 数组与指针识别 整型一维数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.text:00464260 mov [ebp+var_14], 1.text:00464267 mov [ebp+var_10], 2.text:0046426E mov [ebp+var_C], 3.text:00464275 lea eax, [ebp+var_14] ; 数组首地址.text:00464278 push eax ; 传参.text:00464279 call sub_45D447.text:0046427E add esp, 4;sub_45D447.text:004640D0 arg_0 = dword ptr 8.text:004640D0.text:004640D0 push ebp.text:004640D1 mov ebp, esp.text:004640D3 sub esp, 0C0h.text:004640D9 push ebx.text:004640DA push esi.text:004640DB push edi.text:004640DC mov edi, ebp.text:004640DE xor ecx, ecx.text:004640E0 mov eax, 0CCCCCCCCh.text:004640E5 rep stosd.text:004640E7 mov ecx, offset unk_54D014.text:004640EC call sub_45FF35.text:004640F1 nop.text:004640F2 mov eax, 4.text:004640F7 shl eax, 1 ; eax=4*2^1=8.text:004640F9 mov ecx, [ebp+arg_0] ; [ebp+arg_0]是传入的参数，即数组首地址.text:004640FC mov edx, [ecx+eax] ; [ecx+eax]即[ebp+arg_0+eax]，即[ebp+10h].text:004640FF push edx.text:00464100 mov eax, 4.text:00464105 shl eax, 0 ; eax=4*2^0=4.text:00464108 mov ecx, [ebp+arg_0].text:0046410B mov edx, [ecx+eax] ; 即[ebp+0Ch].text:0046410E push edx.text:0046410F mov eax, 4.text:00464114 imul ecx, eax, 0 ; ecx=4*0=0.text:00464117 mov edx, [ebp+arg_0].text:0046411A mov eax, [edx+ecx] ; 即[ebp+8]，即[ebp+arg_0]，数组首位.text:0046411D push eax.text:0046411E push offset aDDD ; &quot;%d %d %d&quot;.text:00464123 call sub_45DB5E ; printf.text:00464128 add esp, 10h.text:0046412B pop edi.text:0046412C pop esi.text:0046412D pop ebx.text:0046412E add esp, 0C0h.text:00464134 cmp ebp, esp.text:00464136 call sub_45F17F.text:0046413B mov esp, ebp.text:0046413D pop ebp.text:0046413E retn 源码 12345678void IntShow(int* n) { printf(&quot;%d %d %d&quot;, n[0], n[1], n[2]);}int main(){ int arr[3] = { 1,2,3 }; IntShow(arr); return 0;} 字符型一维数组 123456789101112131415161718192021222324252627282930313233343536373839.text:00464281 mov eax, ds:dword_520E60 ; 'lleh'.text:00464286 mov [ebp+var_24], eax ; 用eax过渡，传给局部变量.text:00464289 mov cx, ds:word_520E64 ; 'o'.text:00464290 mov [ebp+var_20], cx ; 用cx过渡，传给局部变量.text:00464294 lea eax, [ebp+var_24].text:00464297 push eax ; 前半段的地址入栈.text:00464298 call sub_45E3AB.text:0046429D add esp, 4;sub_45E3AB.text:00463FC0 arg_0 = dword ptr 8.text:00463FC0.text:00463FC0 push ebp.text:00463FC1 mov ebp, esp.text:00463FC3 sub esp, 0C0h.text:00463FC9 push ebx.text:00463FCA push esi.text:00463FCB push edi.text:00463FCC mov edi, ebp.text:00463FCE xor ecx, ecx.text:00463FD0 mov eax, 0CCCCCCCCh.text:00463FD5 rep stosd.text:00463FD7 mov ecx, offset unk_54D014.text:00463FDC call sub_45FF35.text:00463FE1 nop.text:00463FE2 mov eax, [ebp+arg_0] ; 参数传给eax.text:00463FE5 push eax.text:00463FE6 push offset aS ; &quot;%s&quot;.text:00463FEB call sub_45DB5E ; printf.text:00463FF0 add esp, 8.text:00463FF3 pop edi.text:00463FF4 pop esi.text:00463FF5 pop ebx.text:00463FF6 add esp, 0C0h.text:00463FFC cmp ebp, esp.text:00463FFE call sub_45F17F.text:00464003 mov esp, ebp.text:00464005 pop ebp.text:00464006 retn 源码 12345678void CharShow(char* n) { printf(&quot;%s&quot;, n);}int main(){ char buf[] = { &quot;hello&quot; }; CharShow(buf); return 0;} 数组作为返回值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.text:004642C3 call sub_45FC79.text:004642C8 mov [ebp+var_40], eax ; 从返回值中取出传到局部变量.text:004642CB mov eax, [ebp+var_40] ; 放入寄存器中push作为参数.text:004642CE push eax.text:004642CF push offset aS ; &quot;%s&quot;.text:004642D4 call sub_45DB59 ; printf.text:004642D9 add esp, 8;sub_45FC79.text:00464020 var_14 = byte ptr -14h.text:00464020 var_10 = dword ptr -10h.text:00464020 var_C = word ptr -0Ch.text:00464020 var_A = byte ptr -0Ah.text:00464020 var_4 = dword ptr -4.text:00464020.text:00464020 push ebp.text:00464021 mov ebp, esp.text:00464023 sub esp, 0D4h.text:00464029 push ebx.text:0046402A push esi.text:0046402B push edi.text:0046402C lea edi, [ebp+var_14].text:0046402F mov ecx, 5.text:00464034 mov eax, 0CCCCCCCCh.text:00464039 rep stosd.text:0046403B mov eax, ___security_cookie.text:00464040 xor eax, ebp.text:00464042 mov [ebp+var_4], eax.text:00464045 mov ecx, offset unk_54E014.text:0046404A call sub_45FF35.text:0046404F nop.text:00464050 mov eax, ds:dword_521E60 ; 'oviv'.text:00464055 mov [ebp+var_10], eax ; eax过渡，传给局部变量.text:00464058 mov cx, ds:word_521E64 ; '05'.text:0046405F mov [ebp+var_C], cx ; cx过渡，传给局部变量.text:00464063 mov dl, ds:byte_521E66.text:00464069 mov [ebp+var_A], dl.text:0046406C lea eax, [ebp+var_10] ; 前半段给eax，作为返回值传递.text:0046406F push edx.text:00464070 mov ecx, ebp.text:00464072 push eax.text:00464073 lea edx, dword_4640A0.text:00464079 call sub_45EC52.text:0046407E pop eax.text:0046407F pop edx.text:00464080 pop edi.text:00464081 pop esi.text:00464082 pop ebx.text:00464083 mov ecx, [ebp+var_4].text:00464086 xor ecx, ebp ; StackCookie.text:00464088 call j_@__security_check_cookie@4 ; __security_check_cookie(x).text:0046408D add esp, 0D4h.text:00464093 cmp ebp, esp.text:00464095 call sub_45F17A.text:0046409A mov esp, ebp.text:0046409C pop ebp.text:0046409D retn 源码 123456789char* CrZT() { char temp[7] = &quot;vivo50&quot;; return temp;}int main(){ char* p = CrZT(); printf(&quot;%s&quot;, p); return 0;} 整形二维数组（和一维数组没有本质上的区别，都是占用一段连续的内存空间） 1234567891011121314151617181920212223242526272829303132333435.text:004642DC mov [ebp+var_58], 1.text:004642E3 mov [ebp+var_54], 2.text:004642EA mov [ebp+var_50], 3.text:004642F1 mov [ebp+var_4C], 4.text:004642F8 mov eax, 8.text:004642FD shl eax, 0 ; eax=8*2^0=8.text:00464300 lea ecx, [ebp+eax+var_58] ; 即[ebp+var_58+8]，即[ebp+var_50].text:00464304 mov edx, 4.text:00464309 shl edx, 0 ; edx=4*2^0=4.text:0046430C mov eax, [ecx+edx] ; 即[ebp+var_58+0Ch]，即[ebp+var_4C].text:0046430F push eax.text:00464310 mov ecx, 8.text:00464315 shl ecx, 0 ; ecx=8*2^0=8.text:00464318 lea edx, [ebp+ecx+var_58] ; 即[ebp+var_58+8]，即[ebp+var_50].text:0046431C mov eax, 4.text:00464321 imul ecx, eax, 0 ; ecx=0.text:00464324 mov edx, [edx+ecx] ; 即[ebp+var_50].text:00464327 push edx.text:00464328 mov eax, 8.text:0046432D imul ecx, eax, 0 ; ecx=8*0=0.text:00464330 lea edx, [ebp+ecx+var_58] ; 即[ebp+var_58].text:00464334 mov eax, 4.text:00464339 shl eax, 0 ; eax=4*2^0=4.text:0046433C mov ecx, [edx+eax] ; 即[ebp+var_54].text:0046433F push ecx.text:00464340 mov edx, 8.text:00464345 imul eax, edx, 0 ; eax=8*0=0.text:00464348 lea ecx, [ebp+eax+var_58] ; 即[ebp+var_58].text:0046434C mov edx, 4.text:00464351 imul eax, edx, 0 ; ecx=4*0=0.text:00464354 mov ecx, [ecx+eax] ; 即[ebp+var_58].text:00464357 push ecx.text:00464358 push offset aDDDD ; &quot;%d,%d,%d,%d&quot;.text:0046435D call sub_45DB59 ; printf.text:00464362 add esp, 14h 源码 12int num[2][2] = { {1,2},{3,4} };printf(&quot;%d,%d,%d,%d&quot;, num[0][0], num[0][1], num[1][0], num[1][1]);","link":"/2025/07/17/Day7-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E8%AF%86%E5%88%AB/"},{"title":"Day9:壳与脱壳（一）","text":"壳、壳的加载过程、工具脱壳、手动脱壳流程、esp定律（基于Xdbg） 壳 先看ctf-wiki对壳的介绍： 壳 是在一些计算机软件里一段专门负责保护软件不被非法修改或反编译的程序。 它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。 因此，加壳程序包含壳程序和原程序两个部分，且原程序在壳程序运行后才恢复到独立可执行的状态。因此，可以借助动态调试器在壳程序运行完后进行dump，从而获得独立可执行的原程序 常见的壳有压缩壳和加密壳两种： 压缩壳：upx、ASpack、PECompat等 加密壳：VMProtect、Themida、ASProtector等 壳的加载过程 壳和原程序在逻辑上基本没有关联，因此，壳程序在解析加壳后的二进制文件前，会先保存各寄存器的值，通常用pushad/puahfd实现 解析完成后，是原程序的逻辑部分，此时，壳程序给出控制权，寄存器恢复到解析前的状态，通常用popad/popfd实现 最后，程序跳到原程序入口点开始执行 工具脱壳 直接使用工具脱壳的情况主要有两种：一种是无修改的、只使用加壳程序加壳；另一种是使用加壳程序加壳后修改了区块名的。前者可以直接使用加壳程序脱壳（如果具备脱壳功能的话），后者先修改区块名再使用加壳程序脱壳。 upx无修改加壳示例： 拿到可执行文件，先到DIE查看，发现有壳。对壳的信息描述没有出现“modified”字眼，因此判断是无修改加壳，直接使用工具脱壳 直接使用upx -d脱壳 再次用DIE打开，发现没有识别出壳了 upx修改区块名加壳示例： 先到DIE查看壳信息，发现是upx modified 点击“区块“下方的”&gt;“查看区块信息，发现区块名有改动 010editor修改区块名 再次查看壳信息，变成无修改加壳了，直接工具脱壳 手动脱壳流程 步骤： 查壳：使用DIE、ExeinfoPE、PEiD等工具查壳 寻找程序原入口点(OEP)：通过各种方法找到壳代码结束、程序真正开始的地方 dump内存：借助插件从OEP开始dump出原程序 输入表(IAT)重建：借助插件重建输入表 关闭程序重定位：使用DIE等工具关闭程序重定位 寻找OEP的方法有很多，而dump和IAT重建以及关闭重定位的方法基本固定。先用一个例子展示整体流程，再详细展开寻找OEP的方法。upx手动脱壳示例： 查壳：显示是upx 寻找OEP： 采用esp定律法（详见下文）找到push ebp开头的一段代码 dump内存： 打开插件scylla，点击“转储”栏中的“转储”，会获得一个_dump后缀的exe文件 IAT重建： 点击“IAT自动搜索”，会有弹窗问是否使用高级搜索结果，点“是”。这时候，VA和“大小”两个框会被填充。 接下来点“获取导入”，上方的大框中会出现dll结尾的东西，需要把带红色X的取消勾选 然后点击修复转储，选择刚刚dump出来的文件，会得到一个再加上_SCY的exe文件。 此时程序大概率运行不了，会闪退。但是对于静态分析来说，到这一步已经足够了。 关闭重定位：把得到的_dump_SCY.exe文件拖到DIE，点击“区块”栏的“&gt;”，会弹出文件结构界面 先取消勾选右上角的“只读” 点击IMAGE_NT_HEADERS下的IMAGE_FILE_HEADER，在“标志”选项中勾选“RELOCS_STRIPPED”（图中未勾选） 再点击IMAGE_OPTIONAL_HEADERS，找到另一个标志(DllCharacteristics)，取消勾选“DYNAMIC_BASE”（图中未取消） 这样子，我们的程序就脱完壳并且可以正常运行了 PS：关于IAT重建这一步骤，为什么不能IAT自动搜索再转储一步到位？ 结合AI的解释，个人见解是IAT自动搜索的过程可能会运行程序，导致地址刷新，OEP失效，dump出来的程序不完整或者不对。因此，dump和IAT重建实际上是两个步骤，不过被集成到了一个界面。其实还有手动重建IAT的方法，这种情况下就确确实实需要先dump再导入重建的IAT了，因为在调试器中找到OEP后还要继续找IAT 寻找OEP的方法（一）ESP定律 前文，我们知道了壳程序解析时会有pushad\\popad或者pushfd\\popfd的操作。pushad时，随着通用寄存器值的入栈，esp的值会发生变化，又因为栈平衡的特性，最终esp的值会回到pushad后的这个值。因此，可以借助这一点，给pushad后的esp值下硬件访问断点，popad后就会触发断点，中断调试，进而实现跳过整个壳解析过程。当然，中断处还不是OEP，一般在中断处后会有一个跨度明显的jmp，甚至jmp后还有一个跳转表jmp才会到达真正的OEP 具体操作如下： xdbg打开，F9到程序所在内存区域 可以看到EIP所在就是pushad F8步过，esp更新 在右下角栈窗口设上硬件访问断点 点击工具栏“视图”下方的“-&gt;”，程序会执行过popad。可以看到下方不远处有个大跳 F8到大跳处F7步入，有跳转表继续F7步入，可以看到开辟栈帧操作，这里就是OEP了，在此处直接使用scylla dump出程序 单步跟踪法 如名，就是一直按F8，让程序尽量向下走，遇到循环就跳过，遇到近call就步入，重点关注大跳 参考ctf-wiki https://ctf-wiki.org/reverse/platform/windows/unpack/trace/","link":"/2025/07/29/Day9-%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Day5:函数调用约定","text":"函数调用约定 函数调用约定 主要有三种：cdecl、stdcall、fastcall。以求和函数为例 12345678910//求和#include&lt;stdio.h&gt;int sum(int a,int b,int c){ return a+b+c;}int main(){ int res=sum(1,2,3); printf(&quot;%d\\n&quot;,res); return 0;} cdecl：完全栈传参，参数从右往左入栈，由调用者清理参数占用的栈空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283; int __cdecl main()_main proc near ; CODE XREF: j__main↑j var_C = byte ptr -0Chres = dword ptr -8 push ebp mov ebp, esp sub esp, 0CCh push ebx push esi push edi __$EncStackInitStart_2: lea edi, [ebp+var_C] mov ecx, 3 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd_2: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop push 3 ; 参数c入栈 push 2 ; 参数b入栈 push 1 ; 参数a入栈 call j_?sum@@YAHHHH@Z ; sum(int,int,int) add esp, 0Ch ;这里调用者进行了清理参数占用的栈空间的操作(3个参数×4字节)，被调用者不负责 mov [ebp+res], eax mov eax, [ebp+res] push eax push offset _Format ; &quot;%d\\n&quot; call j__printf add esp, 8 xor eax, eax pop edi pop esi pop ebx add esp, 0CCh cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn_main endp; int __cdecl sum(int a, int b, int c)?sum@@YAHHHH@Z proc near ; CODE XREF: sum(int,int,int)↑j a = dword ptr 8b = dword ptr 0Chc = dword ptr 10h push ebp mov ebp, esp sub esp, 0C0h ;sum函数自身的栈空间 push ebx push esi push edi __$EncStackInitStart: mov edi, ebp xor ecx, ecx mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop mov eax, [ebp+a] add eax, [ebp+b] add eax, [ebp+c] pop edi pop esi pop ebx add esp, 0C0h ;清理自身栈空间 cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn?sum@@YAHHHH@Z endp stdcall：完全栈传参，参数从右往左入栈，由被调用者清理参数占用的栈空间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182; int __cdecl main()_main proc near ; CODE XREF: j__main↑j var_C = byte ptr -0Chres = dword ptr -8 push ebp mov ebp, esp sub esp, 0CCh push ebx push esi push edi __$EncStackInitStart_2: lea edi, [ebp+var_C] mov ecx, 3 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd_2: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop push 3 ; 参数c入栈 push 2 ; 参数b入栈 push 1 ; 参数a入栈 call j_?sum@@YGHHHH@Z ; sum(int,int,int) mov [ebp+res], eax ;这里直接到把返回值给res了，调用者不负责清理参数占用的栈空间 mov eax, [ebp+res] push eax push offset _Format ; &quot;%d\\n&quot; call j__printf add esp, 8 xor eax, eax pop edi pop esi pop ebx add esp, 0CCh cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn_main endp ; int __stdcall sum(int a, int b, int c)?sum@@YGHHHH@Z proc near ; CODE XREF: sum(int,int,int)↑j a = dword ptr 8b = dword ptr 0Chc = dword ptr 10h push ebp mov ebp, esp sub esp, 0C0h ;sum的栈空间 push ebx push esi push edi __$EncStackInitStart: mov edi, ebp xor ecx, ecx mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop mov eax, [ebp+a] add eax, [ebp+b] add eax, [ebp+c] pop edi pop esi pop ebx add esp, 0C0h ;清理自身栈空间 cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn 0Ch ;被调用者通过返回指令给esp增加0Ch，清理参数占用的栈空间?sum@@YGHHHH@Z endp fastcall：寄存器+栈传参，优先使用寄存器，剩余参数从右往左入栈，由被调用者清理参数占用的栈空间 寄存器传参优先级： x86：ecx edx 栈 x64：rcx rdx r8 r9 栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687; int __cdecl main()_main proc near ; CODE XREF: j__main↑j var_C = byte ptr -0Chres = dword ptr -8 push ebp mov ebp, esp sub esp, 0CCh push ebx push esi push edi __$EncStackInitStart_2: lea edi, [ebp+var_C] mov ecx, 3 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd_2: ; JMC_flag mov ecx, offset _6005466B_entry@cpp call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop push 3 ; 参数c入栈 mov edx, 2 ; 参数b存入寄存器 mov ecx, 1 ; 参数a存入寄存器 call j_?sum@@YIHHHH@Z ; sum(int,int,int) mov [ebp+res], eax ;这里也是没有调用者对参数占用的栈空间的清理 mov eax, [ebp+res] push eax push offset _Format ; &quot;%d\\n&quot; call j__printf add esp, 8 xor eax, eax pop edi pop esi pop ebx add esp, 0CCh cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn_main endp; int __fastcall sum(int a, int b, int c)?sum@@YIHHHH@Z proc near ; CODE XREF: sum(int,int,int)↑j var_18 = byte ptr -18hb = dword ptr -14ha = dword ptr -8c = dword ptr 8 push ebp mov ebp, esp sub esp, 0D8h ;sum开辟栈空间 push ebx push esi push edi push ecx __$EncStackInitStart: lea edi, [ebp+var_18] mov ecx, 6 mov eax, 0CCCCCCCCh rep stosd __$EncStackInitEnd: pop ecx mov [ebp+b], edx mov [ebp+a], ecx mov ecx, offset _6005466B_entry@cpp ; JMC_flag call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) nop mov eax, [ebp+a] add eax, [ebp+b] add eax, [ebp+c] pop edi pop esi pop ebx add esp, 0D8h ;sum清理栈空间 cmp ebp, esp call j___RTC_CheckEsp mov esp, ebp pop ebp retn 4 ;由于只有一个参数被push到栈上，所以被调用者返回4，清理参数占用的栈空间?sum@@YIHHHH@Z endp","link":"/2025/07/12/Day5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"},{"title":"Re:从0到1的脚本之路","text":"python脚本做题记录 [SWPUCTF 2021 新生赛]fakebase12345678910111213141516#给的代码如下：flag = 'xxxxxxxxxxxxxxxxxxx's_box = 'qwertyuiopasdfghjkzxcvb123456#$'tmp = ''for i in flag: tmp += str(bin(ord(i)))[2:].zfill(8)b1 = int(tmp,2)s = ''while b1//31 != 0: s += s_box[b1%31] b1 = b1//31print(s)# s = u#k4ggia61egegzjuqz12jhfspfkay 代码中，把flag逐字符转化为二进制，截掉前缀，填充为8位，再拼接这些二进制数得到tmp 然后把tmp转化为十进制b1，不断除31，同时用余数做S_box索引，把索引值拼接得到S 所以，解密思路是，首先，还原b1： b1利用后得到一系列索引值，所以由索引值反推b1 逆序s对照s_box得出索引（为了从最后一个余数开始还原b1）并组成一个列表。因为循环终止条件是b1//31==0，所以最后一次除只利用了商等于0，而余数未知，于是从0-30假设被弃掉的余数，枚举各种可能。 而如何判断哪种可能是我们需要的呢？就需要还原出flag并判断。把还原出来的b1转二进制，去掉前缀，填充到8的倍数方便截取二进制数，然后8个8个还原出字符，最后判断是不是flag就行了。 EXP： 1234567891011121314151617181920212223242526buf=&quot;u#k4ggia61egegzjuqz12jhfspfkay&quot;s_box = 'qwertyuiopasdfghjkzxcvb123456#$'index_list=[]#求索引值列表for i in buf[::-1]: for j in range(len(s_box)): if i == s_box[j]: index_list.append(j)#print(index_list)#枚举达到终止条件时的余数for i in range(31): #开始还原b1 b1=i for j in range(len(buf)): b1=b1*31+index_list[j]#不断加余数，乘31 tmp=str(bin(b1)[2:])#加密流程是把tmp从2进制转10进制，这里就反着来，把b1从10进制转2进制，截去前缀 tmp=tmp.zfill((len(tmp)//8+1)*8)#加密时字符转成8位2进制数，反着来就是把8位2进制数转为字符，所以先把tmp 8位对齐方便后续截取 flag='' for i in range(0,len(tmp),8): flag+=chr(int(tmp[i:i+8],2)) if 'NSSCTF' in flag: print(flag) #flag = &quot;NSSCTF{WHAt_BASe31}&quot; [SWPUCTF 2021 新生赛]非常简单的逻辑题 题目给的代码如下： 123456789flag = 'xxxxxxxxxxxxxxxxxxxxx's = 'wesyvbniazxchjko1973652048@$+-&amp;*&lt;&gt;'result = ''for i in range(len(flag)): s1 = ord(flag[i])//17 s2 = ord(flag[i])%17 result += s[(s1+i)%34]+s[-(s2+i+1)%34]print(result)# result = 'v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i' 加密思路是：逐字符取flag，通过//和%操作得到两个值s1和s2，把这两个值处理后，作为索引在s中索引出字符，拼接得到result 逆着来应该是把result错位分开，分成和s1有关的与和s2有关的，然后求出索引值，逆两个取余过程得到s1和s2，再把s1和s2运算得到flag字符 很显然，这个过程十分复杂，因为涉及取模的还原 所以考虑顺着加密的思路走，从常见的字符十进制值枚举，遇到加密后结果和result一样的就拿来拼接flag EXP: 123456789101112131415161718192021222324s = 'wesyvbniazxchjko1973652048@$+-&amp;*&lt;&gt;'result = 'v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i'tmp=''flag=''#提取出result里和s1、s2相关的字符s1_list=[]s2_list=[]for i in range(0,len(result),2): s1_list.append(result[i]) s2_list.append(result[i+1])#开始爆破#先求出加密过程两个索引值for i in range(len(s1_list)): index1=s.index(s1_list[i]) index2=s.index(s2_list[i]) #以索引值为判断条件，在常见字符的范围内重现加密过程，加密结果和索引值一致即为flag的字符 for j in range(33,126): s1=j//17 s2=j%17 if (s1 + i) % 34==index1 and -(s2 + i + 1) % 34==index2: flag+=chr(j) breakprint(flag)#flag = &quot;NSSCTF{Fake_RERE_QAQ}&quot;&quot; [SWPUCTF 2021 新生赛]re2 IDA打开，代码如下： 简单的字符处理，先判断字符是否在范围内，然后采用不同处理方式 直接正向利用代码，省点脑子。 EXP: 12345678910111213alpha='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890{}-_'dic={}str='ylqq]aycqyp{'flag=''for i in alpha: if (ord(i)&lt;=96 or ord(i)&gt;98) and (ord(i)&lt;=64 or ord(i)&gt;66): dic[chr(ord(i)-2)]=i else: dic[chr(ord(i)+24)]=ifor i in str: flag+=dic[i]print(flag)#flag = 'NSSCTF{nss_caesar}' 直接得出来的结果是{nss_c{es{r}，显然不对，猜测对应关系不唯一。打印出alpha经过处理后的结果，发现’{‘和’a’都对应’y’，所以把显然不对劲的两个’ { ‘改成’ a ‘ [WUSTCTF 2020]level1 附件给了ELF文件和一个txt，反汇编代码如下： 逻辑就是从flag文件里读数据，然后存到ptr里。后面是简单的可逆处理，但是要注意ptr是从下标1开始用的。给的txt应该就是处理后的结果，把它转成一个列表，第一位随便填一个数。然后逆。 EXP: 123456789output=[0, 198, 232, 816, 200, 1536, 300, 6144, 984, 51200, 570, 92160, 1200, 565248, 756, 1474560, 800, 6291456, 1782, 65536000]flag=''for i in range(1,len(output)): if (i&amp;1)!=0: flag+=chr(output[i]&gt;&gt;i) else: flag+=chr(output[i]//i)print(flag)#flag = 'NSSCTF{d9-dE6-20c}'（改了前缀） [SWPUCTF 2021 新生赛]简简单单的解密 给的python代码如下： 12345678910111213141516171819202122232425import base64,urllib.parsekey = &quot;HereIsFlagggg&quot;flag = &quot;xxxxxxxxxxxxxxxxxxx&quot;s_box = list(range(256))j = 0for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i]res = []i = j = 0for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k))cipher = &quot;&quot;.join(res)crypt = (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))enc = str(base64.b64decode(crypt),'utf-8')enc = urllib.parse.quote(enc)print(enc)# enc = %C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA 采用的加密算法是标准RC4，加密两遍恢复明文。最后面的调用base的两行经过调试发现相互抵消，所以整个逻辑就是先RC4加密，然后用urllib.parse.quote()方法编码，编码部分用原库自带的urllib.parse.unquote()就行了 EXP: 12345678910111213141516171819202122232425262728293031import urllib.parseenc = '%C2%A6n%C2%87Y%1Ag%3F%C2%A01.%C2%9C%C3%B7%C3%8A%02%C3%80%C2%92W%C3%8C%C3%BA'buf=urllib.parse.unquote(enc)result=[]for i in buf: result.append(i)key = &quot;HereIsFlagggg&quot;flag = ''def RC4(flag): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] res = [] i = j = 0 for s in flag: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] res.append(chr(ord(s) ^ k)) cipher = &quot;&quot;.join(res) return cipherflag+=RC4(result)print(flag)# flag = 'NSSCTF{REAL_EZ_RC4}' [LitCTF 2023]ez_XOR IDA打开，如图 用XOR函数对输入做处理后，与str比较。打开XOR： 功能就是遍历字符，异或处理，再异或一遍就可以了 EXP: 123456str='E`}J]OrQF[V8zV:hzpV}fVF[t'flag=''for i in range(len(str)): flag+=chr(ord(str[i])^9)print(flag)# flag = 'NSSCTF{XOR_1s_3asy_to_OR}'(前缀做了改动) [HUBUCTF 2022 新生赛]simple_RE IDA打开，如图 加密函数看起来逻辑很复杂，但是点开名字很奇怪的数组，发现一个编码表，可以推测是base64编码。 回过头看给的用来比较的字符串，基本可以确定是base64换表编码 找到了一个可以自定义编码表的python库cusbase64，可以用config指定编码表，这样就容易多了 EXP: 1234567import cusbase64table='qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD'enc='5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8=='b=cusbase64.CusBase64()b.config(table)b.decode(enc)#flag = 'NSSCTF{a8d4347722800e72e34e1aba3fe914ae}' [NSSCTF 2022 Spring Recruit]easy C 题目给的是c源文件，如下： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){ char a[]=&quot;wwwwwww&quot;; char b[]=&quot;d`vxbQd&quot;; //try to find out the flag printf(&quot;please input flag:&quot;); scanf(&quot; %s&quot;,&amp;a); if(strlen(a)!=7){ printf(&quot;NoNoNo\\n&quot;); system(&quot;pause&quot;); return 0; } for(int i=0;i&lt;7;i++){ a[i]++; a[i]=a[i]^2; } if(!strcmp(a,b)){ printf(&quot;good!\\n&quot;); system(&quot;pause&quot;); return 0; } printf(&quot;NoNoNo\\n&quot;); system(&quot;pause&quot;); return 0; //flag 记得包上 NSSCTF{} 再提交!!!} 分析逻辑，把输入的flag按字符先递增，再和2异或，得到的新数组应该和b一样。逆着来就是先异或再递减。 EXP： 123456str='d`vxbQd'flag=''for i in str: flag+=chr((ord(i)^2)-1)print(flag)#flag = 'NSSCTF{easy_Re}' [NSSCTF 2022 Spring Recruit]easy Python 题目给的py源码，如下： 12345678910111213141516171819202122232425262728293031import stringdef encode(string,string2): tmp_str = str() ret = str() bit_string_str = string.encode() remain = len( string ) % 3 remain_str = str() for char in bit_string_str: b_char = (bin(char)[2:]) b_char = '0'*(8-len(b_char)) + b_char tmp_str += b_char for i in range(len(tmp_str)//6): temp_nub = int(tmp_str[i*6:6*(i+1)],2) ret += string2[temp_nub] if remain==2: remain_str = tmp_str[-4:] + '0'*2 temp_nub = int(remain_str,2) ret += string2[temp_nub] + &quot;=&quot; elif remain==1: remain_str = tmp_str[-2:] + '0'*4 temp_nub = int(remain_str,2) ret += string2[temp_nub] + &quot;=&quot;*2 return ret.replace(&quot;=&quot;,&quot;&quot;)res = encode(input(),string.ascii_uppercase+string.ascii_lowercase+string.digits+'+/')if res == &quot;TlNTQ1RGe2Jhc2U2NCEhfQ&quot;: print(&quot;good!&quot;)else: print(&quot;bad!&quot;) 细细一看，encode()里面有加“=”的操作，并且使用的string2是字母大小写+数字+’+/‘，推测是base64，但是注意到encode()返回的时候把“=”替换成了“”，也就是删除了“==”，所以要把后面用于比较的也就是加密后的字符串加上“=” EXP: 12345import pybase64str='TlNTQ1RGe2Jhc2U2NCEhfQ=='flag=pybase64.b64decode(str)print(flag)#flag = 'NSSCTF{base64!!}' [SWPUCTF 2021 新生赛]fakerandom 依旧是Py源码： 12345678910111213import randomflag = 'xxxxxxxxxxxxxxxxxxxx'random.seed(1)l = []for i in range(4): l.append(random.getrandbits(8))result=[]for i in range(len(l)): random.seed(l[i]) for n in range(5): result.append(ord(flag[i*5+n])^random.getrandbits(8))print(result)# result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244] 逻辑就是，用生成的伪随机数来异或flag的特定位。异或可逆，已知种子，伪随机数可以确定。所以只需要在源码的基础上稍作改动，把result和flag的位置调换一下就可以了 EXP： 12345678910111213import randomflag = ''result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244]random.seed(1)l = []for i in range(4): l.append(random.getrandbits(8))for i in range(len(l)): random.seed(l[i]) for n in range(5): flag+=chr(result[i*5+n]^random.getrandbits(8))print(flag)#flag = 'NSSCTF{FakeE_random}' [HNCTF 2022 Week1]X0r IDA打开，main函数如下： 可以看出，逻辑就是对输入的字符串按字符异或处理，最后与给定的arr比较 EXP： 123456arr=[0x000003FE, 0x000003EB, 0x000003EB, 0x000003FB, 0x000003E4, 0x000003F6, 0x000003D3, 0x000003D0, 0x00000388, 0x000003CA, 0x000003EF, 0x00000389, 0x000003CB, 0x000003EF, 0x000003CB, 0x00000388, 0x000003EF, 0x000003D5, 0x000003D9, 0x000003CB, 0x000003D1, 0x000003CD]flag=''for i in range(0,len(arr)): flag+=chr((arr[i]-900)^0x34)print(flag)flag = 'NSSCTF{x0r_1s_s0_easy}' [HGAME 2023 week1]easyenc IDA打开，main函数如图 可以看到逻辑就是先遍历出输入字符串的长度（ * ( ( _BYTE *) v9 + v4 )这样的格式可以看成：v9[v4]，算是一种经验吧）然后循环对输入的字符串按字符进行运算，最后与给定的数据比较。 难点在于，给的是10个元素的数组，而输入的字符串却要求是41个字符。看来V7的格式不是很对，要把这么多位的数据进行划分才行。v7是DWORD类型，而参与运算的v9用的是BYTE类型，1DWORD=4BYTE，要把v7的数分成4部分，这里的数据不好提取，可以直接丢给AI。当然手动复制也可以。 EXP： 12345678910111213buf=[0x9FDFF04,0xB0F301,0xADF00500,0x5170607,0x17FD17EB,0x1EE01EA,0xFA05B1EA,0xAC170108,0xFDEA01EC,0x60705F0]flag=''buf1 = []for num in buf: bytes_data = num.to_bytes(4, byteorder='little') for byte in bytes_data: buf1.append(hex(byte))#print(buf1)for num in buf1: tmp=((int(num,16)+86)^0x32)&amp;0xff flag+=chr(tmp)print(flag)#flag = 'NSSCTF{4ddit1on_is_a_rever5ible_0peration}'（修改了前缀） 当然得多学一点，所以手搓v7，找DS问一下怎么处理数据，得到如上的方法。 用to_bytes把v7的数转成字节形式，byteorder指定了小端序，然后hex转换成十六进制数存入新列表。至于为什么要转成十六进制数，和下面的代码有关。 然后用新列表的元素进行逆运算。因为直接使用这些元素会被判成字符，所以前面先转成十六进制数，再用int转成十进制数，这样就可以正常运算了 最后还要&amp;0xff，因为逆出来的数据有点超出ascii码范围了 还有就是，这样得出来的flag其实缺了一个“ } ”。回头看反编译的代码，那个未命名的用来输入v9的实际上不是纯粹的scanf那样的函数。里面有个FILE指针，推测是读文件的函数。所以读取的内容结尾按道理会有’\\0’。但是，加上了’\\0’算出来的flag也没有’ } ‘。所以，凭常识加上’ } ‘。","link":"/2025/06/02/Re-%E4%BB%8E0%E5%88%B01%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8B%E8%B7%AF/"},{"title":"icarus主题优化","text":"icarus主题复制功能重构（仿照next主题）、firebase统计阅读人数 复制功能重构 icarus主题自带的复制功能是带文字选中的（如下图），个人感觉麻烦了点，于是考虑借鉴next的复制风格，一键复制 实现： hexo-theme-icarus/source/js/main.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 if (clipboard) {- new ClipboardJS('.highlight .copy', {- target: function(trigger) {- return trigger.parentNode.nextElementSibling;- }- }).on('success', function(e) {- e.clearSelection();- const tmp = e.trigger.innerHTML;- e.trigger.innerHTML = '&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt;';- setTimeout(function() {- e.trigger.innerHTML = tmp;- }, 2000);- });+ $('figure.highlight').each(function() {+ const target = $(this).find('figcaption div.level-right')[0];+ if (target) {+ registerCopyButton(target, this);+ }+ }); } ----------------------------------------------------------------------------------... $('.article &gt; .content &gt; table').each(function() { if ($(this).width() &gt; $(this).parent().width()) { $(this).wrap('&lt;div class=&quot;table-overflow&quot;&gt;&lt;/div&gt;'); } });+ // 注册复制按钮功能，仿照Next主题实现+ function registerCopyButton(target, element) {+ // 添加复制按钮+ target.insertAdjacentHTML('beforeend', '&lt;a href=&quot;javascript:;&quot; class=&quot;copy&quot; title=&quot;Copy&quot;&gt;&lt;i class=&quot;fas fa-copy&quot;&gt;&lt;/i&gt;&lt;/a&gt;');+ const button = target.querySelector('.copy');+ + button.addEventListener('click', function() {+ const code = element.querySelector('.code').innerText;+ + if (navigator.clipboard) {+ // 使用现代的Clipboard API+ navigator.clipboard.writeText(code).then(function() {+ button.querySelector('i').className = 'fas fa-check-circle';+ }, function() {+ button.querySelector('i').className = 'fas fa-times-circle';+ });+ } else {+ // 兼容性回退方案+ const ta = document.createElement('textarea');+ ta.style.top = window.scrollY + 'px';+ ta.style.position = 'absolute';+ ta.style.opacity = '0';+ ta.readOnly = true;+ ta.value = code;+ document.body.append(ta);+ ta.select();+ ta.setSelectionRange(0, code.length);+ ta.readOnly = false;+ const result = document.execCommand('copy');+ button.querySelector('i').className = result ? 'fas fa-check-circle' : 'fas fa-times-circle';+ ta.blur();+ button.blur();+ document.body.removeChild(ta);+ }+ });+ + // 鼠标离开300ms后恢复复制图标+ element.addEventListener('mouseleave', function() {+ setTimeout(function() {+ const icon = button.querySelector('i');+ if (icon) {+ icon.className = 'fas fa-copy';+ }+ }, 300);+ });+ } function adjustNavbar() { const navbarWidth = $('.navbar-main .navbar-start').outerWidth() + $('.navbar-main .navbar-end').outerWidth(); if ($(document).outerWidth() &lt; navbarWidth) { $('.navbar-main .navbar-menu').addClass('justify-content-start'); } else { $('.navbar-main .navbar-menu').removeClass('justify-content-start'); } } hexo-theme-icarus/layout/common/scripts.jsx 12345678910 return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt; &lt;script data-pjax src={url_for('/js/column.js')}&gt;&lt;/script&gt; &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt;- {clipboard &amp;&amp; &lt;script src={cdn('clipboard', '2.0.4', 'dist/clipboard.min.js')} defer&gt;&lt;/script&gt;} &lt;script data-pjax src={url_for('/js/main.js')} defer&gt;&lt;/script&gt; &lt;/Fragment&gt;; 使用firebase统计阅读人数config文件添加配置_config.icarus.yml 1234567+# Firebase Firestore 阅读人数统计+services:+ firebase:+ enable: true+ collection: articles # Firestore数据库中的集合名称+ apiKey: # 你的Firebase API Key+ projectId: # 你的Firebase项目ID 文章head增加人数统计hexo-theme-icarus/layout/common/articles.jsx 123456789 {/* Visitor counter */} {!index &amp;&amp; plugins &amp;&amp; plugins.busuanzi === true ? &lt;span class=&quot;level-item&quot; id=&quot;busuanzi_container_page_pv&quot; dangerouslySetInnerHTML={{ __html: _p('plugin.visit_count', '&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt;') }}&gt;&lt;/span&gt; : null}+ {/* Firebase Visitor counter */}+ {config.services &amp;&amp; config.services.firebase &amp;&amp; config.services.firebase.enable ? &lt;span class=&quot;level-item&quot;&gt;+ &lt;i class=&quot;far fa-eye mr-1&quot;&gt;&lt;/i&gt;+ &lt;span class=&quot;firestore-visitors-count&quot;&gt;0&lt;/span&gt;+ &lt;/span&gt; : null} 基于firebase的统计功能实现source/js/firebase_counter.js（新建） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187+/* global IcarusThemeSettings, firebase */++// Firebase Counter - 阅读量统计功能++if (IcarusThemeSettings &amp;&amp; IcarusThemeSettings.services &amp;&amp; IcarusThemeSettings.services.firebase &amp;&amp; IcarusThemeSettings.services.firebase.enable) {+ + // 初始化Firebase+ try {+ // 确保firebase对象存在+ if (typeof firebase === 'undefined') {+ console.error('Firebase library not loaded');+ // 如果Firebase库未加载，隐藏计数器元素+ document.querySelectorAll('.firestore-visitors-count').forEach(el =&gt; {+ el.style.display = 'none';+ });+ } else {+ + firebase.initializeApp({+ apiKey: IcarusThemeSettings.services.firebase.apiKey,+ projectId: IcarusThemeSettings.services.firebase.projectId+ });+ + // 开发环境检测+ const isLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname);+ const isDevelopment = isLocalhost || window.location.hostname.includes('192.168.');+ + // 移除所有调试日志输出+ + // 获取数据库引用+ const db = firebase.firestore();+ const articlesCollection = IcarusThemeSettings.services.firebase.collection || 'articles';+ const articles = db.collection(articlesCollection);+ + // 获取阅读次数函数+ const getCount = (doc, increaseCount) =&gt; {+ // 获取文档数据+ return doc.get().then(d =&gt; {+ // 初始化计数+ let count = d.exists ? d.data().count : 0;+ + // 如果需要增加计数（只在文章页面且未在同一会话访问过）+ if (increaseCount) {+ // 增加计数+ count++;+ return doc.set({ count }).then(() =&gt; {+ if (isDevelopment) console.log('计数已更新:', count);+ return count;+ }).catch(error =&gt; {+ console.error('Error updating count:', error);+ return count; // 返回增加前的计数+ });+ }+ + return count;+ }).catch(error =&gt; {+ console.error('Error getting count:', error);+ // 出错时返回默认值0+ return 0;+ });+ };++ // 处理阅读计数的函数+ const handleViewCount = () =&gt; {+ // 获取当前URL路径+ const currentPath = window.location.pathname;+ + // 增强首页识别：使用多个可能的选择器+ const isIndexPage = document.querySelector('.article-list') !== null ||+ document.querySelector('.article-card-list') !== null ||+ document.querySelectorAll('.article-card').length &gt; 0 || // 降低阈值以适应首页+ (currentPath === '/' &amp;&amp; document.querySelector('article.article') !== null); // 特殊处理：根路径+article.article元素+ + // 增强文章页面识别：使用更精确的选择器组合+ // 重要：首页优先判断，且文章页判断要排除首页的情况，并增加特定的文章页特征+ const isArticlePage = !isIndexPage &amp;&amp; (+ // 传统文章页选择器+ (document.querySelector('.article-container') !== null &amp;&amp; document.querySelector('.article-content') !== null) ||+ (document.querySelector('article.post') !== null &amp;&amp; document.querySelector('.article-content') !== null) ||+ document.querySelector('[id=&quot;post-content&quot;]') !== null ||+ // 针对hexo s环境的增强选择器，但需要确保不是首页+ (document.querySelector('article.article') !== null &amp;&amp; + document.querySelector('article.card-content.article') !== null &amp;&amp;+ document.querySelectorAll('.article-card').length === 0 &amp;&amp;+ currentPath !== '/')+ );+ + // 页面类型信息 - 仅在开发环境显示+ if (isDevelopment) {+ console.log(`[Firebase] 当前页面类型: ${isArticlePage ? '文章页' : isIndexPage ? '首页' : '其他页面'}`);+ }++ if (isArticlePage) {+ // 文章页面处理+ const titleElement = document.querySelector('.title.is-3, .title.is-4-mobile');+ const countElement = document.querySelector('.firestore-visitors-count');+ + if (titleElement &amp;&amp; countElement) {+ const title = titleElement.textContent.trim();+ const doc = articles.doc(title);+ + // 确定是否增加计数：不在本地开发环境且同一会话未访问过+ let increaseCount = !isDevelopment;+ + if (sessionStorage.getItem(title)) {+ increaseCount = false;+ } else {+ // 标记为在当前会话中已访问+ sessionStorage.setItem(title, true);+ }+ + getCount(doc, increaseCount).then(count =&gt; {+ countElement.innerText = count;+ }).catch(e =&gt; {+ // 移除错误日志+ });+ } else {+ // 静默处理：未找到文章标题或计数元素+ }+ } else if (isIndexPage) {+ // 首页文章列表处理+ // 修改选择器以匹配实际HTML结构+ // 首页文章结构: .card &gt; .card-content.article &gt; .title.is-3.is-size-4-mobile+ const titleElements = document.querySelectorAll(+ '.card .article .title.is-3, .card .article .title.is-4-mobile, ' ++ '.card article .title.is-3, .card article .title.is-4-mobile, ' ++ '.card .article p.title, .card article p.title'+ );+ const countElements = document.querySelectorAll('.card .article .firestore-visitors-count, .card article .firestore-visitors-count');+ + // 移除首页元素检测日志+ + if (titleElements.length &gt; 0 &amp;&amp; countElements.length &gt; 0) {+ const promises = [...titleElements].map(element =&gt; {+ const title = element.textContent.trim();+ const doc = articles.doc(title);+ // 首页只获取计数，不增加计数+ return getCount(doc, false).then(count =&gt; {+ return count;+ });+ });+ + Promise.all(promises).then(counts =&gt; {+ counts.forEach((val, idx) =&gt; {+ if (countElements[idx]) {+ countElements[idx].innerText = val;+ }+ });+ }).catch(e =&gt; {+ // 错误处理：尝试显示一些默认值或替代文本+ countElements.forEach(el =&gt; {+ if (el.innerText === '0') {+ el.innerText = '加载中...';+ }+ });+ });+ } else {+ // 尝试使用更通用的选择器+ const fallbackTitleElements = document.querySelectorAll('.article-card a[href^=&quot;/&quot;]');+ const fallbackCountElements = document.querySelectorAll('.article-card .firestore-visitors-count');+ + if (fallbackTitleElements.length &gt; 0 &amp;&amp; fallbackCountElements.length &gt; 0) {+ // 这里可以添加备选逻辑+ }+ }+ } else {+ // 静默处理：当前页面既不是文章页也不是首页+ }+ };+++ // 监听传统页面加载完成事件+ document.addEventListener('DOMContentLoaded', () =&gt; {+ handleViewCount();+ });+ + // 监听PJAX页面加载完成事件（适配Icarus主题的PJAX机制）+ document.addEventListener('page:loaded', () =&gt; {+ handleViewCount();+ });+ }+ } catch (error) {+ // 移除初始化失败日志+ // 如果初始化失败，尝试隐藏计数器元素以避免显示为0+ document.querySelectorAll('.firestore-visitors-count').forEach(el =&gt; {+ el.style.display = 'none';+ });+ }+} 其他一些优化hexo-theme-icarus/layout/common/scripts.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const { Component, Fragment } = require('inferno');const { toMomentLocale } = require('hexo/dist/plugins/helper/date');const Plugins = require('./plugins');module.exports = class extends Component { render() { const { site, config, helper, page } = this.props; const { url_for, cdn } = helper; const { article } = config; const language = toMomentLocale(page.lang || page.language || config.language || 'en'); let fold = 'unfolded'; let clipboard = true; if (article &amp;&amp; article.highlight) { if (typeof article.highlight.clipboard !== 'undefined') { clipboard = !!article.highlight.clipboard; } if (typeof article.highlight.fold === 'string') { fold = article.highlight.fold; } } const embeddedConfig = `var IcarusThemeSettings = { article: { highlight: { clipboard: ${clipboard}, fold: '${fold}' }+ },+ services: {+ firebase: ${config.services &amp;&amp; config.services.firebase ? JSON.stringify(config.services.firebase) : 'false'} } };`; return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt;+ {/* Firebase Firestore */}+ {config.services &amp;&amp; config.services.firebase &amp;&amp; config.services.firebase.enable ? (+ &lt;Fragment&gt;+ &lt;script src=&quot;https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js&quot;&gt;&lt;/script&gt;+ &lt;script src=&quot;https://www.gstatic.com/firebasejs/9.6.11/firebase-firestore-compat.js&quot;&gt;&lt;/script&gt;+ &lt;/Fragment&gt;+ ) : null} &lt;script data-pjax src={url_for('/js/column.js')}&gt;&lt;/script&gt; &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt; &lt;script data-pjax src={url_for('/js/main.js')} defer&gt;&lt;/script&gt;+ {/* Firebase counter script */}+ {config.services &amp;&amp; config.services.firebase &amp;&amp; config.services.firebase.enable ? (+ &lt;script data-pjax src={url_for('/js/firebase_counter.js')} defer&gt;&lt;/script&gt;+ ) : null} &lt;/Fragment&gt;; }};","link":"/2025/09/02/icarus%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"},{"title":"week27-week30","text":"2025年9月篇 week27 (2025.9.1-2025.9.7) 接下来打算把周记分成四周一篇了，每周照样更新，但是四周一篇文章 这周（其实是上周，这段是补的）把博客主题给换了。原先想着先配置完，到时候直接把文章移到新的博客文件里，但是进度太慢了。这周直接给原博客换皮😋还更了一篇博客,真好😋(虽然还是AI出力) moe week4上新题了,但是week3甚至week2还有没写完的题 安卓这块的笔记还没更,开学了找找时间补上 week28 (2025.9.8-2025.9.14) 好的手忙脚乱的开学第一周，目前学习计划有待更新。 这周和X2c的新师傅们组队参加了湾区杯，独立解出了一道题，还是太菜了。考察方向还挺全面，pc端、安卓甚至微信小程序都有。 week29 (2025.9.15-2025.9.21) 这周有个长城杯（还有个铁人三项长城杯，这俩好像不是一个），只分web、AI安全、数据安全三个方向，没做出来，爆0了 开学了学习状态又开始不稳定了，老是偷懒不找时间学😖这学期好几门数学相关课，要燃尽了 给博客新开了数据结构分类，能不能更下去看造化了( week30 (2025.9.22-2025.9.28) 这周又是没有新知识的一周 周六又干掉一道moectf的题，只剩最后一道week2的upx_revenge了，实在没招了😖 感觉还是没找到学业和比赛的平衡点，这样下去恐怕一学期学的都没有一个暑假多😖不得不吐槽为什么乱七八糟的课这么多啊😖","link":"/2025/09/08/week27-week30/"},{"title":"Moectf2025ReverseWriteUp","text":"Moectf2025 Reverse方向全解&amp;详解 week1upx 附件程序用010editor打开，可以看到upx版本，可以找对应版本upx程序脱壳，也可以手动脱壳（采用内存镜像法）： 用x64dbg打开程序，先移除预设断点 在“内存映射”窗口给程序的.rsrc段下一次性内存访问断点，F9运行 然后在UPX0段或者UPX1段下一次性内存写入断点，F9运行 回到“CPU”窗口，可以看到在RIP不远处有一个大跳（RIP在0x00007FF7BB887423处) 跟进去，还有个跳转表，继续跟进，可以看到程序的OEP了 然后在此处使用scylla dump出程序，并且修复IAT，得到upx_dump_SCY.exe，可以分析了 分析main函数，发现每个输入的字符异或了0x21，而非末位字符还异或了原来的下一位。由于异或有交换律，所以解密逻辑可以是：先对每个处理完的字符异或0x21，然后再从倒数第二位开始和下一位异或，这样就恢复了复原出了flag（但是给的密文少了最后一位，即字符串的结束符。根据最后一位和倒数第二位的关系0x56=125 ^ 0x21 ^ 末位 得出：末位=10，所以末位^0x21=43，将密文补充完整） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//main函数__int64 sub_7FF6FC2718A0(){ char *v0; // rdi __int64 i; // rcx FILE *Stream; // rax _BYTE v4[32]; // [rsp+0h] [rbp-20h] BYREF char v5; // [rsp+20h] [rbp+0h] BYREF _DWORD cipher[44]; // [rsp+30h] [rbp+10h] char flag[132]; // [rsp+E0h] [rbp+C0h] BYREF int length; // [rsp+164h] [rbp+144h] _BYTE v9[60]; // [rsp+188h] [rbp+168h] int j; // [rsp+1C4h] [rbp+1A4h] int Char; // [rsp+1E4h] [rbp+1C4h] int k; // [rsp+204h] [rbp+1E4h] v0 = &amp;v5; for ( i = 130LL; i; --i ) { *(_DWORD *)v0 = -858993460; v0 += 4; } sub_7FF6FC271375((__int64)&amp;word_7FF6FC28200E); cipher[0] = 35; cipher[1] = 43; cipher[2] = 39; cipher[3] = 54; cipher[4] = 51; cipher[5] = 60; cipher[6] = 3; cipher[7] = 72; cipher[8] = 100; cipher[9] = 11; cipher[10] = 29; cipher[11] = 118; cipher[12] = 123; cipher[13] = 16; cipher[14] = 11; cipher[15] = 58; cipher[16] = 63; cipher[17] = 101; cipher[18] = 118; cipher[19] = 41; cipher[20] = 21; cipher[21] = 55; cipher[22] = 28; cipher[23] = 10; cipher[24] = 8; cipher[25] = 33; cipher[26] = 62; cipher[27] = 60; cipher[28] = 61; cipher[29] = 22; cipher[30] = 11; cipher[31] = 36; cipher[32] = 41; cipher[33] = 36; cipher[34] = 86; sub_7FF6FC27119F((__int64)aPleaseInputYou); // &quot;please input your flag: &quot; Stream = _acrt_iob_func(0); fgets(flag, 100, Stream); length = j_strlen(flag); for ( j = 0; j &lt; length; ++j ) { Char = flag[j] ^ 0x21; if ( j &lt; length - 1 ) Char ^= flag[j + 1]; v9[j] = Char; } for ( k = 0; k &lt; 35; ++k ) { if ( (char)v9[k] != cipher[k] ) { sub_7FF6FC27119F((__int64)aYouWillNeverGe);// &quot;you will never get the flag!!!!\\n&quot; break; } } sub_7FF6FC271311(v4, qword_7FF6FC27AD00); return 0LL;} 解密脚本： 123456789101112131415enc=[ 0x23, 0x2b, 0x27, 0x36, 0x33, 0x3c, 0x03, 0x48, 0x64, 0x0b, 0x1d, 0x76, 0x7b, 0x10, 0x0b, 0x3a, 0x3f, 0x65, 0x76, 0x29, 0x15, 0x37, 0x1c, 0x0a, 0x08, 0x21, 0x3e, 0x3c, 0x3d, 0x16, 0x0b, 0x24, 0x29, 0x24, 0x56, 43 ]xored=[]for i in range(len(enc)): xored.append(enc[i]^0x21)#print(xored)for i in range(len(xored)-2,-1,-1): xored[i]=xored[i]^xored[i+1]flag=''.join(chr(i) for i in xored)print(flag) maze 附件程序main函数逻辑如下，wasd迷宫题，迷宫在函数maze_init中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394int __fastcall main(int argc, const char **argv, const char **envp){ unsigned __int64 count; // rax int v4; // ebx __int64 index; // r9 int v6; // r11d unsigned __int64 y; // r8 __int64 x; // r10 unsigned __int64 n0x37_1; // rdi char *Format; // rcx _BYTE flag[1008]; // [rsp+20h] [rbp-408h] maze_init(); printf(asc_140004138); printf(&amp;Format_); while ( 1 ) {LABEL_2: while ( 1 ) { printf(asc_140004190); scanf(&quot;%s&quot;); count = -1LL; do ++count; while ( flag[count] ); if ( count &lt;= 999 ) break; printf(&amp;Format__0); } v4 = 1; index = 0LL; v6 = 1; y = 1LL;// 起点y x = 1LL;// 起点x if ( (int)count &gt; 0 ) break;LABEL_19: Format = (char *)&amp;byte_140004118;LABEL_20: printf(Format); printf(&amp;Format__1); } n0x37_1 = 1LL; while ( 1 ) { switch ( flag[index] ) { case 'A': case 'a': --v4; --x; --n0x37_1; break; case 'D': case 'd': ++v4; ++x; ++n0x37_1; break; case 'S': case 's': ++v6; ++y; break; case 'W': case 'w': --v6; --y; break; default: printf(&amp;Format__2); printf(&amp;Format__1); goto LABEL_2; } if ( y &gt; 0x37 || n0x37_1 &gt; 0x37 ) { Format = (char *)&amp;unk_1400040D8; goto LABEL_20; } if ( byte_140005660[56 * y + x] == 49 ) { Format = (char *)&amp;unk_1400040F8; goto LABEL_20; } if ( y == 15 &amp;&amp; x == 32 ) break; if ( ++index &gt;= (int)count ) goto LABEL_19; } printf(asc_1400041E0); printf(&quot;moectf{%s}\\n&quot;); return 0;} maze_init函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116__int64 maze_init(){ const char *all_1; // r9 const char **v1; // rbx int n56_2; // r11d __int64 v3; // r10 __int64 n56; // rax int v5; // r8d __int64 i; // rax char v7; // dl __int64 v8; // rcx _QWORD v9[56]; // [rsp+20h] [rbp-E0h] BYREF v9[1] = &quot;10100000000000000010000011011101011111111101011100000111&quot;; all_1 = &quot;11111111111111111111111111111111111111111111111111111111&quot;; v9[0] = &quot;11111111111111111111111111111111111111111111111111111111&quot;; v9[2] = &quot;10111010111111111010111011000001000001000001000101110111&quot;; v9[3] = &quot;10000010000010000010001011011111111101110111011101110111&quot;; v9[4] = &quot;10111111111011101110111011010000000000010100010001110111&quot;; v9[5] = &quot;10100000001000101000100011010101111111011101110101110111&quot;; v9[6] = &quot;10101011111110111011101011010101000001000000010101110111&quot;; v9[7] = &quot;10101010000010100000101011110101110101111101111111110111&quot;; v9[8] = &quot;10111010111010101111101011100101000100000101000101110111&quot;; v9[9] = &quot;10000010001010001000001011001111011111010101011101110111&quot;; v9[10] = &quot;11111011101011111011111111101000100000101100101001110111&quot;; v9[11] = &quot;10001010001000100010000010001010011000100010010011000001&quot;; v9[12] = &quot;10111010111110101010111011011001011111010101011101011101&quot;; v9[13] = &quot;10001010001000001010001011000101000100000101000101011101&quot;; v9[14] = &quot;11101011101111111011101011110101110111111101110101011101&quot;; v9[15] = &quot;10001000101000001010001011000100010100000101000101011101&quot;; v9[16] = &quot;10111111101011101110111011011111110101110111011101011101&quot;; v9[17] = &quot;10001000001000100000001011000100000100010000000101011001&quot;; v9[18] = &quot;11101011111011111111101011110101111101111111110101011011&quot;; v9[19] = &quot;10101000000010001000101011010100000001000100010101011011&quot;; v9[20] = &quot;10101111111110101010101011010111111111010101010101011011&quot;; v9[21] = &quot;10100000000000100010101011010000000000010001010101011011&quot;; v9[22] = &quot;10111111111111111110111011011111111111111111011101011011&quot;; v9[23] = &quot;10000000001111000000000011110111010000111100011111011011&quot;; v9[24] = &quot;11101111100000011011011111111010110111011101100001011011&quot;; v9[25] = &quot;11101111111111111011011111111101110111101101100001011011&quot;; v9[26] = &quot;10001000111111000010000011111010110111011101100001011011&quot;; v9[27] = &quot;10111010111111111010111011110111010000111101100001010011&quot;; v9[28] = &quot;10000010000010000010001011111111111111111101100001010111&quot;; v9[29] = &quot;10111111111011101110111011110001000110001101100001010001&quot;; v9[30] = &quot;10100000001000101000100011110111011101111101100001011101&quot;; v9[31] = &quot;10101011111110111011101011110001000101111101100001011101&quot;; v9[32] = &quot;10101010000010100000101011111101011101111101100001011101&quot;; v9[33] = &quot;10111010111010101111101011110001000110001101100001011101&quot;; v9[34] = &quot;10000010001010101000001011111111111111111101100001011101&quot;; v9[35] = &quot;11111011101011111011111110000000000000001101100001011101&quot;; v9[36] = &quot;10001010001000100010000011111111111111111100110011011101&quot;; v9[37] = &quot;10111010111110101010111010010000000011111110001111011101&quot;; v9[38] = &quot;10001010001000001010001010110111000001111110100101011101&quot;; v9[39] = &quot;11101011101111111011101000110011001111111100110111011101&quot;; v9[40] = &quot;10001000101000001010001011111111111111111111110111010001&quot;; v1 = (const char **)v9; v9[55] = &quot;11111111111111111111111111111111111111111111111111111111&quot;; v9[41] = &quot;10111111101011101110111010100001001100000000000011011011&quot;; n56_2 = 0; v9[42] = &quot;10001000001000100000001011111111111101011101111001011011&quot;; v3 = 0LL; v9[43] = &quot;10101011111011111111101011000000000001000100010111011011&quot;; v9[44] = &quot;10101000000010001000101010010111111111111111111111011011&quot;; v9[45] = &quot;10101111111110101010101010110111111111111111111101011011&quot;; v9[46] = &quot;10100000000000100010101011100000000000000000000011011011&quot;; v9[47] = &quot;10111111111111111110011011111111111111111111111011011011&quot;; v9[48] = &quot;10000011111111111111000010000000000000000000000000011001&quot;; v9[49] = &quot;11111011111111111111111111111111111111111111111111111101&quot;; v9[50] = &quot;11111011100001100110110111000000000000000000000111111101&quot;; v9[51] = &quot;11111011101111011010000111011111111111111111110111111101&quot;; v9[52] = &quot;11111011100001000010110110000111111111111111110000000001&quot;; v9[53] = &quot;11111011101111011010110111101111111111111111111111111111&quot;; v9[54] = &quot;11110000000000011000110000000000000000000000000000000011&quot;; while ( 1 ) { n56 = -1LL; do ++n56; while ( all_1[n56] ); if ( n56 != 56 ) { printf((char *)&amp;Format__3); exit(1); } v5 = 0; for ( i = 0LL; i &lt; 56; ++i ) { v7 = all_1[i]; if ( (unsigned __int8)(v7 - 48) &gt; 1u ) { printf((char *)&amp;Format__4); exit(1); } v8 = v3 + i; ++v5; byte_140005660[v8] = v7; } ++n56_2; ++v1; v3 += 56LL; if ( n56_2 &gt;= 56 ) break; all_1 = *v1; } if ( n48 != 48 ) { printf((char *)&amp;Format); exit(1); } if ( n48_0 != 48 ) { printf((char *)&amp;Format__5); exit(1); } return i;} 使用神奇妙妙工具得到迷宫路径： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from mycode import mazeMaze = [ &quot;11111111111111111111111111111111111111111111111111111111&quot;, &quot;10100000000000000010000011011101011111111101011100000111&quot;, &quot;10111010111111111010111011000001000001000001000101110111&quot;, &quot;10000010000010000010001011011111111101110111011101110111&quot;, &quot;10111111111011101110111011010000000000010100010001110111&quot;, &quot;10100000001000101000100011010101111111011101110101110111&quot;, &quot;10101011111110111011101011010101000001000000010101110111&quot;, &quot;10101010000010100000101011110101110101111101111111110111&quot;, &quot;10111010111010101111101011100101000100000101000101110111&quot;, &quot;10000010001010001000001011001111011111010101011101110111&quot;, &quot;11111011101011111011111111101000100000101100101001110111&quot;, &quot;10001010001000100010000010001010011000100010010011000001&quot;, &quot;10111010111110101010111011011001011111010101011101011101&quot;, &quot;10001010001000001010001011000101000100000101000101011101&quot;, &quot;11101011101111111011101011110101110111111101110101011101&quot;, &quot;10001000101000001010001011000100010100000101000101011101&quot;, &quot;10111111101011101110111011011111110101110111011101011101&quot;, &quot;10001000001000100000001011000100000100010000000101011001&quot;, &quot;11101011111011111111101011110101111101111111110101011011&quot;, &quot;10101000000010001000101011010100000001000100010101011011&quot;, &quot;10101111111110101010101011010111111111010101010101011011&quot;, &quot;10100000000000100010101011010000000000010001010101011011&quot;, &quot;10111111111111111110111011011111111111111111011101011011&quot;, &quot;10000000001111000000000011110111010000111100011111011011&quot;, &quot;11101111100000011011011111111010110111011101100001011011&quot;, &quot;11101111111111111011011111111101110111101101100001011011&quot;, &quot;10001000111111000010000011111010110111011101100001011011&quot;, &quot;10111010111111111010111011110111010000111101100001010011&quot;, &quot;10000010000010000010001011111111111111111101100001010111&quot;, &quot;10111111111011101110111011110001000110001101100001010001&quot;, &quot;10100000001000101000100011110111011101111101100001011101&quot;, &quot;10101011111110111011101011110001000101111101100001011101&quot;, &quot;10101010000010100000101011111101011101111101100001011101&quot;, &quot;10111010111010101111101011110001000110001101100001011101&quot;, &quot;10000010001010101000001011111111111111111101100001011101&quot;, &quot;11111011101011111011111110000000000000001101100001011101&quot;, &quot;10001010001000100010000011111111111111111100110011011101&quot;, &quot;10111010111110101010111010010000000011111110001111011101&quot;, &quot;10001010001000001010001010110111000001111110100101011101&quot;, &quot;11101011101111111011101000110011001111111100110111011101&quot;, &quot;10001000101000001010001011111111111111111111110111010001&quot;, &quot;10111111101011101110111010100001001100000000000011011011&quot;, &quot;10001000001000100000001011111111111101011101111001011011&quot;, &quot;10101011111011111111101011000000000001000100010111011011&quot;, &quot;10101000000010001000101010010111111111111111111111011011&quot;, &quot;10101111111110101010101010110111111111111111111101011011&quot;, &quot;10100000000000100010101011100000000000000000000011011011&quot;, &quot;10111111111111111110011011111111111111111111111011011011&quot;, &quot;10000011111111111111000010000000000000000000000000011001&quot;, &quot;11111011111111111111111111111111111111111111111111111101&quot;, &quot;11111011100001100110110111000000000000000000000111111101&quot;, &quot;11111011101111011010000111011111111111111111110111111101&quot;, &quot;11111011100001000010110110000111111111111111110000000001&quot;, &quot;11111011101111011010110111101111111111111111111111111111&quot;, &quot;11110000000000011000110000000000000000000000000000000011&quot;, &quot;11111111111111111111111111111111111111111111111111111111&quot;]start=(1,1)end=(15,32)path=maze.solve(Maze,start,end)print(path)#mycode.maze:from collections import dequedef solve(maze, start, end, directions=None, wall='1', free='0'): &quot;&quot;&quot; 参数: maze: 二维字符串列表 start: 起点坐标 (row, col) end: 终点坐标 (row, col) directions: 自定义方向指令 (默认WASD) wall: 墙字符 (默认'1') free: 通路字符 (默认'0') 返回: 移动指令字符串 或 None(无解) &quot;&quot;&quot; if directions is None: directions = { 'W': (-1, 0), # 上 'A': (0, -1), # 左 'S': (1, 0), # 下 'D': (0, 1) # 右 } rows, cols = len(maze), len(maze[0]) # 坐标验证 def is_valid(pos): r, c = pos return (0 &lt;= r &lt; rows and 0 &lt;= c &lt; cols and maze[r][c] == free) if not is_valid(start): raise ValueError(f&quot;无效起点 {start}&quot;) if not is_valid(end): raise ValueError(f&quot;无效终点 {end}&quot;) # BFS核心（修复了变量名冲突） queue = deque([(start[0], start[1], &quot;&quot;)]) visited = set([(start[0], start[1])]) while queue: row, col, current_path = queue.popleft() # 改名为 current_path if (row, col) == end: return current_path for move, (dr, dc) in directions.items(): new_row, new_col = row + dr, col + dc if (0 &lt;= new_row &lt; rows and 0 &lt;= new_col &lt; cols and maze[new_row][new_col] == free and # 使用通路字符 free (new_row, new_col) not in visited): visited.add((new_row, new_col)) queue.append((new_row, new_col, current_path + move)) # 使用 current_path return None # 无解 flower 附件程序用IDA打开，在汇编界面上下滑动可以找到花指令引起的红色栈帧报错。打开IDA工具栏的“Options”选项的“General”，勾选“Stackpointer”，可以看到栈帧信息 可以看到红色报错的函数栈帧超过了1000，有点反常，找到栈帧发生突变的地方，发现用sub rsp,1000h改变了栈帧，把这条指令nop掉。本题这个类型的花指令占绝大多数，需要耐心的一个一个nop掉。（还有sub rsp,400h的，主要留意栈帧大于100） 还有另一种花指令： 图中Label+1是0x004048EF，被0x004048EE处的指令覆盖住了，所以undefine一下，IDA就会自动纠错。把没用的指令nop掉 接下来要做的修改有2点。首先可以看到0x004048E5处有一个恒跳花指令，这个要nop掉。 然后是call loc_4048EF，由于call是会占用栈帧的，更何况call一个标签没有ret恢复栈帧，后面栈帧还是会报错（这里有一个试错过程，不把call改成jmp的话，函数undefine+code+create function后依旧反编译不了）。做法就是工具栏edit-&gt;patch program-&gt;change byte，把十六进制码E8改成E9 然后就是选中函数名undefine+code+create function了，就可以正常反编译了 main函数逻辑主要是把flag掐头去尾，中间部分加密后比对 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061unsigned __int64 __fastcall solve(_QWORD *flag){ char v1; // bl bool v2; // r12 __int64 v3; // rax __int64 v4; // rbx __int64 v5; // rax char *flag[i]; // rax __int64 v7; // rax char v9; // [rsp+17h] [rbp-59h] BYREF int i; // [rsp+18h] [rbp-58h] int len; // [rsp+1Ch] [rbp-54h] __int64 flag_start; // [rsp+20h] [rbp-50h] BYREF __int64 flag_end; // [rsp+28h] [rbp-48h] BYREF void *fl4g[5]; // [rsp+30h] [rbp-40h] BYREF unsigned __int64 v15; // [rsp+58h] [rbp-18h] __int64 savedregs; // [rsp+70h] [rbp+0h] BYREF v15 = __readfsqword(0x28u); v1 = 0; v2 = 1; if ( (unsigned __int64)length((__int64)flag) &gt; 7 ) { substr(fl4g, flag, 0LL, 7uLL); v1 = 1; if ( !(unsigned __int8)cmp((__int64)fl4g, (__int64)&quot;moectf{&quot;) &amp;&amp; *(_BYTE *)get_last_str(flag) == 125 ) v2 = 0; } if ( v1 ) std::string::~string(fl4g); if ( v2 ) { v3 = cout((std::ostream *)&amp;std::cout); out(v3, (__int64 (*)(void))std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); } else { std::allocator&lt;char&gt;::allocator((unsigned int)&amp;savedregs - 89); flag_end = getEnd(flag); v4 = cutTail(&amp;flag_end, 1LL); flag_start = getStart((__int64)flag); v5 = cutHead(&amp;flag_start, 7LL); std::string::basic_string&lt;__gnu_cxx::__normal_iterator&lt;char *,std::string&gt;,void&gt;(fl4g, v5, v4, (__int64)&amp;v9);// 掐头去尾 std::string::operator=(flag, fl4g); std::string::~string(fl4g); std::allocator&lt;char&gt;::~allocator(); len = length((__int64)flag); if ( len == 32 ) { for ( i = 0; i &lt; len; ++i ) { flag[i] = (char *)toList(flag, i); // flag[i] if ( (unsigned int)encode(*flag[i]) != enc[i] ) break; } } v7 = cout((std::ostream *)&amp;std::cout); out(v7, (__int64 (*)(void))std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); } return v15 - __readfsqword(0x28u);} 加密函数encode如下，就是把flag[i]和key异或，key会递增。需要注意的是，静态分析下得到的key是不正确的（静态分析得到的key是0x23，但是动态调试会发现程序运行到此处key变成0x29），动调得到的key才能解密出flag 解密脚本： 12345678910111213data = [ 0x4F, 0x1A, 0x59, 0x1F, 0x5B, 0x1D, 0x5D, 0x6F, 0x7B, 0x47, 0x7E, 0x44, 0x6A, 0x07, 0x59, 0x67, 0x0E, 0x52, 0x08, 0x63, 0x5C, 0x1A, 0x52, 0x1F, 0x20, 0x7B, 0x21, 0x77, 0x70, 0x25, 0x74, 0x2B]key=0x29result=[]for i in range(len(data)): plaintext=(data[i]^key)&amp;0xff key+=1 result.append(plaintext)flag=''.join(chr(x) for x in result)print(flag) tea IDA打开附件程序，main函数逻辑是将输入的flag分成10份，每次取两份进行加密，加密出来的数据和enc比较。key和enc已经给定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//main函数int __fastcall main(int argc, const char **argv, const char **envp){ char *v3; // rdi __int64 i; // rcx _BYTE v6[32]; // [rsp+0h] [rbp-20h] BYREF char v7; // [rsp+20h] [rbp+0h] BYREF _DWORD key[12]; // [rsp+28h] [rbp+8h] BYREF _DWORD enc[20]; // [rsp+58h] [rbp+38h] _DWORD fl4g[20]; // [rsp+A8h] [rbp+88h] BYREF _DWORD Flag[20]; // [rsp+F8h] [rbp+D8h] BYREF char flag[64]; // [rsp+148h] [rbp+128h] BYREF size_t length; // [rsp+188h] [rbp+168h] int j; // [rsp+1A4h] [rbp+184h] unsigned int part1; // [rsp+1C8h] [rbp+1A8h] BYREF int part2; // [rsp+1CCh] [rbp+1ACh] int v17; // [rsp+1E4h] [rbp+1C4h] int k; // [rsp+204h] [rbp+1E4h] v3 = &amp;v7; for ( i = 130LL; i; --i ) { *(_DWORD *)v3 = -858993460; v3 += 4; } sub_7FF6DAA21384(byte_7FF6DAA33015); key[0] = 289739801; key[1] = 427884820; key[2] = 1363251608; key[3] = 269567252; enc[0] = 2026214571; enc[1] = 578894681; enc[2] = 1193947460; enc[3] = -229306230; enc[4] = 73202484; enc[5] = 961145356; enc[6] = -881456792; enc[7] = 358205817; enc[8] = -554069347; enc[9] = 119347883; enc[10] = 0; memset(fl4g, 0, 44uLL); memset(Flag, 0, 44uLL); printf(&amp;You_are_wrong___); scanf(&quot;%s&quot;, flag); length = j_strlen(flag); j_memcpy(fl4g, flag, length); for ( j = 0; j &lt; 5; ++j ) { part1 = fl4g[2 * j]; part2 = fl4g[2 * j + 1]; tea(&amp;part1, key);// 这里传的是地址，tea内可以通过part1的地址得到part2 Flag[2 * j] = part1; Flag[2 * j + 1] = part2; } v17 = 1; for ( k = 0; k &lt; 11; ++k ) { if ( Flag[k] != enc[k] ) { v17 = 0; printf(&quot;You are wrong!!&quot;); break; } } if ( v17 == 1 ) printf(&quot;Congratulations!!!!&quot;); sub_7FF6DAA21320(v6, &amp;unk_7FF6DAA2AE60); return 0;} 加密函数是改动的tea加密 1234567891011121314151617181920212223__int64 __fastcall Tea(unsigned int *part1, _DWORD *key){ __int64 n4; // rax int delta; // [rsp+24h] [rbp+4h] unsigned int p1; // [rsp+44h] [rbp+24h] unsigned int p2; // [rsp+64h] [rbp+44h] int i; // [rsp+A4h] [rbp+84h] sub_7FF6DAA21384((__int64)&amp;byte_7FF6DAA33015); delta = 0; p1 = *part1; p2 = part1[1]; for ( i = 0; i &lt; 32; ++i ) { delta += 1131796; p1 += (key[1] + (p2 &gt;&gt; 5)) ^ (delta + p2) ^ (*key + 16 * p2); p2 += (key[3] + (p1 &gt;&gt; 5)) ^ (delta + p1) ^ (key[2] + 16 * p1); } *part1 = p1; n4 = 4LL; part1[1] = p2; return n4;} 解密逻辑：将tea内的p1 p2位置对调，”+”改成”-“，然后delta从最后一轮的值往回递减就可以了。解密脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;void tea_decrypt(uint32_t *a,uint32_t *k) { uint32_t delta = 1131796 * 32; uint32_t p1 = *a; uint32_t p2 = *(a + 1); for (int i = 0; i &lt; 32; i++) { p2 -= ((k[3] + (p1 &gt;&gt; 5)) ^ (delta + p1) ^ (k[2] + 16 * p1)); p1 -= ((k[1] + (p2 &gt;&gt; 5)) ^ (delta + p2) ^ (*k + 16 * p2)); delta -= 1131796; } *a = p1; *(a+1)= p2;}int main() { uint32_t key[4]; uint32_t enc[11]; key[0] = 289739801; key[1] = 427884820; key[2] = 1363251608; key[3] = 269567252; enc[0] = 2026214571; enc[1] = 578894681; enc[2] = 1193947460; enc[3] = -229306230; enc[4] = 73202484; enc[5] = 961145356; enc[6] = -881456792; enc[7] = 358205817; enc[8] = -554069347; enc[9] = 119347883; enc[10] = 0; char flag[45] = { 0 }; for (int i = 0; i &lt; 5; i++) { uint32_t block[2] = {enc[2*i],enc[2*i+1]}; tea_decrypt(block, key); for (int j = 0; j &lt; 4; j++) { flag[8 * i + j] = (block[0] &gt;&gt; (j * 8)) &amp; 0xff;//右移j个字符，然后取最后一个 flag[8 * i + j + 4] = (block[1] &gt;&gt; (j * 8)) &amp; 0xff; } } printf(&quot;%s&quot;, flag); return 0;} ez3 附件程序main函数逻辑主要是获取flag，然后掐头去尾，对中间部分进行check。main函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int __fastcall main(int argc, const char **argv, const char **envp){ char v3; // bl bool v4; // r12 __int64 v5; // rbx __int64 v6; // rax char v8; // [rsp+Fh] [rbp-71h] BYREF __int64 Start; // [rsp+10h] [rbp-70h] BYREF __int64 end; // [rsp+18h] [rbp-68h] BYREF _BYTE flag[32]; // [rsp+20h] [rbp-60h] BYREF _QWORD fl4g[8]; // [rsp+40h] [rbp-40h] BYREF fl4g[5] = __readfsqword(0x28u); printf(&quot;Input your flag:\\n&gt; &quot;, argv, envp); fflush(stdout); std::string::basic_string(flag); cin(&amp;std::cin); if ( length(flag) == 42 ) { v3 = 0; v4 = 1; if ( length(flag) &gt; 7 ) { substr(fl4g, flag, 0LL, 7LL); v3 = 1; if ( !cmp(fl4g, &quot;moectf{&quot;) &amp;&amp; *get_last_str(flag) == 125 ) v4 = 0; } if ( v3 ) std::string::~string(fl4g); if ( v4 ) { puts(&quot;FORMAT ERROR!&quot;); } else { std::allocator&lt;char&gt;::allocator(&amp;v8); end = getEnd(flag); v5 = cutTail(&amp;end, 1LL); Start = getStart(flag); v6 = cutHead(&amp;Start, 7LL); std::string::basic_string&lt;__gnu_cxx::__normal_iterator&lt;char *,std::string&gt;,void&gt;(fl4g, v6, v5, &amp;v8); strcopy(flag, fl4g); std::string::~string(fl4g); std::allocator&lt;char&gt;::~allocator(&amp;v8); std::string::basic_string(fl4g, flag); LOBYTE(v5) = check(fl4g); std::string::~string(fl4g); if ( v5 ) { puts(&quot;OK&quot;); puts(&quot;But I don't know what the true flag is&quot;); } else { puts(&quot;try again~&quot;); } } } else { puts(&quot;Length error!&quot;); } std::string::~string(flag); return 0;} check函数： 题目提示了z3，所以使用z3约束求解。思路就是复现check函数逻辑，爆破出flag 脚本： 12345678910111213141516171819202122232425262728293031from z3 import *enc = [ 0x0B1B0, 0x5678, 0x7FF2, 0xA332, 0xA0E8, 0x364C, 0x2BD4, 0xC8FE, 0x4A7C, 0x18, 0x2BE4, 0x4144, 0x3BA6, 0xBE8C, 0x8F7E, 0x35F8, 0x61AA, 0x2B4A, 0x6828, 0xB39E, 0xB542, 0x33EC, 0xC7D8, 0x448C, 0x9310, 0x8808, 0xADD4, 0x3CC2, 0x796, 0xC940, 0x4E32, 0x4E2E, 0x924A, 0x5B5C]s=Solver()flag=[BitVec(f'flag_{i}',32)for i in range(34)]b=[BitVec(f'b_{i}',32)for i in range(34)]for i in range(34): s.add(flag[i]&gt;=32,flag[i]&lt;=126)for i in range(34): if i==0: s.add(b[0]==(47806*flag[0])%51966) else: b_value=47806*(flag[i]+i) b_xored=b_value^(b[i-1]^0x114514) s.add(b[i]==b_xored%51966) s.add(b[i]==enc[i])print(&quot;solutions found:&quot;)while s.check()==sat: model=s.model() solution=''.join([chr(model[flag[i]].as_long())for i in range(34)]) print(solution) exception=Or([flag[i]!=model[flag[i]]for i in range(34)])#避免重复情况 s.add(exception) 逆向工程入门指北 IDA打开附件程序，在字符串窗口可以直接看到flag week2base 运行附件程序，直接让输入flag。IDA打开分析main函数，发现使用了标准base64加密，并且密文直接给了。cyberchef一把梭 1234567891011121314151617181920212223242526272829303132333435363738394041//main函数int __fastcall main(int argc, const char **argv, const char **envp){ FILE *Stream; // rax __int64 v4; // rdx __int64 length; // rax unsigned __int64 n; // rax char *Str1; // rbx int v8; // eax char *Format; // rcx char v11[16]; // [rsp+20h] [rbp-98h] BYREF char flag[112]; // [rsp+30h] [rbp-88h] BYREF printf(::Format); printf((char *)&amp;Format_); Stream = _acrt_iob_func(0); fgets(flag, 100, Stream); v4 = -1LL; length = -1LL; do ++length; while ( flag[length] ); if ( length &amp;&amp; v11[length + 15] == 10 ) { n = length - 1; if ( n &gt;= 0x64 ) _report_securityfailure_(flag); flag[n] = 0; } do ++v4; while ( flag[v4] ); Str1 = (char *)baseEncode(flag, v4, v11);// 标准base64加密 v8 = strcmp(Str1, &quot;bW9lY3Rme1kwdV9DNG5fRzAwZF9BdF9CNDVlNjQhIX0=&quot;); Format = (char *)&amp;unk_140003300; if ( v8 ) Format = (char *)&amp;byte_140003318; printf(Format); free(Str1); return 0;} speed 附件程序运行出现一道黑影，看不清。IDA分析main函数，发现使用了WNDCLASSA结构体（详细信息见：WNDCLASSA （winuser.h） - Win32 apps | Microsoft Learn），主要逻辑是创建窗口，关键部分是窗口结构体变量lpfnWndProc，它指向了窗口的逻辑（即代码中的WndProc函数） 分析WndProc函数发现，窗口似乎直接输出flag。于是下断点，动态调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//WndProc函数LRESULT __fastcall WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam){ tagPAINTSTRUCT Paint; // [rsp+30h] [rbp-50h] BYREF char Destination[14]; // [rsp+80h] [rbp+0h] BYREF __int16 v7; // [rsp+8Eh] [rbp+Eh] __int64 v8; // [rsp+90h] [rbp+10h] __int64 v9; // [rsp+98h] [rbp+18h] __int64 v10; // [rsp+A0h] [rbp+20h] __int64 v11; // [rsp+A8h] [rbp+28h] __int64 v12; // [rsp+B0h] [rbp+30h] __int64 v13; // [rsp+B8h] [rbp+38h] __int64 v14; // [rsp+C0h] [rbp+40h] __int64 v15; // [rsp+C8h] [rbp+48h] __int64 v16; // [rsp+D0h] [rbp+50h] __int64 v17; // [rsp+D8h] [rbp+58h] __int64 v18; // [rsp+E0h] [rbp+60h] __int64 v19; // [rsp+E8h] [rbp+68h] __int64 v20; // [rsp+F0h] [rbp+70h] __int64 v21; // [rsp+F8h] [rbp+78h] struct tagRECT Rect; // [rsp+100h] [rbp+80h] BYREF char mylittlepony[13]; // [rsp+113h] [rbp+93h] BYREF char Source[8]; // [rsp+120h] [rbp+A0h] BYREF __int64 v25; // [rsp+128h] [rbp+A8h] _QWORD v26[2]; // [rsp+130h] [rbp+B0h] int i; // [rsp+140h] [rbp+C0h] int n12; // [rsp+144h] [rbp+C4h] HDC hdc; // [rsp+148h] [rbp+C8h] if ( Msg == 2 ) { PostQuitMessage(0); return 0LL; } else if ( Msg == 15 ) { hdc = BeginPaint(hWnd, &amp;Paint); strcpy(Destination, &quot;Your flag is &quot;); v7 = 0; v8 = 0LL; v9 = 0LL; v10 = 0LL; v11 = 0LL; v12 = 0LL; v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; v17 = 0LL; v18 = 0LL; v19 = 0LL; v20 = 0LL; v21 = 0LL; *(_QWORD *)Source = 0x7F1B3E885EF9160LL; v25 = 0x2CD336BCB0464A89LL; v26[0] = 0xEF5FC91642917EE1uLL; *(_QWORD *)((char *)v26 + 6) = 0x739D40A4E356EF5FLL; strcpy(mylittlepony, &quot;mylittlepony&quot;); n12 = 12; i = strlen(Source); RC4Crypt((unsigned __int8 *)Source, i, (const unsigned __int8 *)mylittlepony, 12); strcat(Destination, Source); GetClientRect(hWnd, &amp;Rect); DrawTextA(hdc, Destination, -1, &amp;Rect, 0x40005u); EndPaint(hWnd, &amp;Paint); return 0LL; } else { return DefWindowProcA(hWnd, Msg, wParam, lParam); }} 动态调试结果如图： ezpy 使用decompyle3反编译得到： 1234567891011121314151617181920212223def caesar_cipher_encrypt(text, shift): result = [] for char in text: if char.isalpha(): if char.islower(): new_char = chr((ord(char) - ord(&quot;a&quot;) + shift) % 26 + ord(&quot;a&quot;)) elif char.isupper(): new_char = chr((ord(char) - ord(&quot;A&quot;) + shift) % 26 + ord(&quot;A&quot;)) result.append(new_char) else: result.append(char) return &quot;&quot;.join(result)user_input = input(&quot;please input your flag：&quot;)a = 1if a != 1: plaintext = user_input shift = 114514 encrypted_text = caesar_cipher_encrypt(plaintext, shift) if encrypted_text == &quot;wyomdp{I0e_Ux0G_zim}&quot;: print(&quot;Correct!!!!&quot;) 可以看出实现了一个凯撒加密，分析逻辑可以看出实际上是给每个字母移位了10（ascii码+10），所以给字母减10就ok了，可以基于源码进行微小改动得到解密脚本： 12345678910111213141516def caesar_cipher_decrypt(text, shift): result = [] for char in text: if char.isalpha(): if char.islower(): new_char = chr((ord(char) - ord(&quot;a&quot;) - shift) % 26 + ord(&quot;a&quot;))#'+'改为-&quot; elif char.isupper(): new_char = chr((ord(char) - ord(&quot;A&quot;) - shift) % 26 + ord(&quot;A&quot;)) result.append(new_char) else: result.append(char) return &quot;&quot;.join(result)enc=&quot;wyomdp{I0e_Ux0G_zim}&quot;flag=caesar_cipher_decrypt(enc,114514)print(flag) catch 先看main函数反编译结果，发现只有简单的两个函数，其中solve函数有更复杂的逻辑： 然而solve函数并不能看出什么有用的逻辑出来，sub_114514出现了flag字样，但是动调发现没有用处 结合题目提示try catch不能被正确反编译，于是直接查看汇编代码。在汇编代码里看到一个类似flag格式的字符串，分析后续逻辑发现对这个字符串进行了处理，分析发现处理结果就是flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154.text:00000001400014D6 ; =============== S U B R O U T I N E =======================================.text:00000001400014D6.text:00000001400014D6 ; Attributes: bp-based frame fpd=10h.text:00000001400014D6.text:00000001400014D6 ; void __noreturn solve(void).text:00000001400014D6 public _Z5solvev.text:00000001400014D6 _Z5solvev proc near ; CODE XREF: main+D↓p.text:00000001400014D6 ; DATA XREF: .pdata:000000014002D078↓o ....text:00000001400014D6.text:00000001400014D6 length = dword ptr -1Ch.text:00000001400014D6 C = dword ptr -18h.text:00000001400014D6 count = dword ptr -14h.text:00000001400014D6.text:00000001400014D6 ; __unwind { // __gxx_personality_seh0.text:00000001400014D6 push rbp.text:00000001400014D7 push rsi.text:00000001400014D8 push rbx.text:00000001400014D9 sub rsp, 30h.text:00000001400014DD lea rbp, [rsp+30h].text:00000001400014E2 lea rax, aMyFlagIsHidden ; &quot;my flag is hidden in this program. Can &quot;....text:00000001400014E9 mov rcx, rax ; char *.text:00000001400014EC call print.text:00000001400014F1 ; try {.text:00000001400014F1 call _Z10sub_114514v ; sub_114514(void).text:00000001400014F1 ; } // starts at 1400014F1.text:00000001400014F6 mov ecx, 10h ; thrown_size.text:00000001400014FB call __cxa_allocate_exception.text:0000000140001500 mov rbx, rax.text:0000000140001503 lea rax, aNothingButErro ; &quot;nothing but error&quot;.text:000000014000150A mov rdx, rax ; char *.text:000000014000150D mov rcx, rbx ; this.text:0000000140001510 ; try {.text:0000000140001510 call _ZNSt11logic_errorC1EPKc ; std::logic_error::logic_error(char const*).text:0000000140001510 ; } // starts at 140001510.text:0000000140001515 mov r8, cs:_refptr__ZNSt11logic_errorD1Ev ; void (*)(void *).text:000000014000151C lea rax, _ZTISt11logic_error ; `typeinfo for'std::logic_error.text:0000000140001523 mov rdx, rax ; lptinfo.text:0000000140001526 mov rcx, rbx ; void *.text:0000000140001529 ; try {.text:0000000140001529 call __cxa_throw.text:0000000140001529 ; } // starts at 140001529.text:000000014000152E ; ---------------------------------------------------------------------------.text:000000014000152E ; cleanup() // owned by 140001510.text:000000014000152E mov rsi, rax.text:0000000140001531 mov rcx, rbx ; void *.text:0000000140001534 call __cxa_free_exception.text:0000000140001539 mov rax, rsi.text:000000014000153C jmp short $+2.text:000000014000153E ; ---------------------------------------------------------------------------.text:000000014000153E.text:000000014000153E loc_14000153E: ; CODE XREF: solve(void)+66↑j.text:000000014000153E ; catch(...) // owned by 1400014F1 ; void *.text:000000014000153E ; catch(...) // owned by 140001529.text:000000014000153E mov rcx, rax.text:0000000140001541 call __cxa_begin_catch.text:0000000140001546 lea rax, enc ; &quot;zbrpgs{F4z3_Ge1px_jvgu_@sybjre_qrfhjn}&quot;.text:000000014000154D mov rcx, rax ; Str.text:0000000140001550 call strlen.text:0000000140001555 mov [rbp+10h+length], eax.text:0000000140001558 mov [rbp+10h+count], 0.text:000000014000155F jmp loc_14000160E.text:0000000140001564 ; ---------------------------------------------------------------------------.text:0000000140001564.text:0000000140001564 loc_140001564: ; CODE XREF: solve(void)+13E↓j.text:0000000140001564 mov eax, [rbp+10h+count].text:0000000140001567 cdqe.text:0000000140001569 lea rdx, enc ; &quot;zbrpgs{F4z3_Ge1px_jvgu_@sybjre_qrfhjn}&quot;.text:0000000140001570 movzx eax, byte ptr [rax+rdx].text:0000000140001574 movzx eax, al.text:0000000140001577 mov [rbp+10h+C], eax.text:000000014000157A mov eax, [rbp+10h+C].text:000000014000157D mov ecx, eax ; C.text:000000014000157F mov rax, cs:__imp_islower.text:0000000140001586 call rax ; __imp_islower ; 判断字母大小写.text:0000000140001588 test eax, eax.text:000000014000158A jz short loc_1400015B9 ; 大写字母跳转.text:000000014000158C mov eax, [rbp+10h+C] ; enc[count].text:000000014000158F lea edx, [rax-54h] ; enc[count]-0x54.text:0000000140001592 movsxd rax, edx.text:0000000140001595 imul rax, 4EC4EC4Fh ; 从这里开始.text:000000014000159C shr rax, 20h.text:00000001400015A0 sar eax, 3.text:00000001400015A3 mov ecx, edx.text:00000001400015A5 sar ecx, 1Fh.text:00000001400015A8 sub eax, ecx.text:00000001400015AA imul ecx, eax, 1Ah.text:00000001400015AD mov eax, edx.text:00000001400015AF sub eax, ecx ; 到这里结束，实现的是除以26.text:00000001400015B1 add eax, 61h ; 'a' ; 加上0x61.text:00000001400015B4 mov [rbp+10h+C], eax.text:00000001400015B7 jmp short loc_1400015F6.text:00000001400015B9 ; ---------------------------------------------------------------------------.text:00000001400015B9.text:00000001400015B9 loc_1400015B9: ; CODE XREF: solve(void)+B4↑j.text:00000001400015B9 mov eax, [rbp+10h+C].text:00000001400015BC mov ecx, eax ; C.text:00000001400015BE mov rax, cs:__imp_isupper.text:00000001400015C5 call rax ; __imp_isupper ; 判断字母大小写.text:00000001400015C7 test eax, eax.text:00000001400015C9 jz short loc_1400015F6 ; 非字母跳转.text:00000001400015CB mov eax, [rbp+10h+C] ; enc[count].text:00000001400015CE lea edx, [rax-34h] ; enc[count]-0x34.text:00000001400015D1 movsxd rax, edx.text:00000001400015D4 imul rax, 4EC4EC4Fh ; 从这里开始.text:00000001400015DB shr rax, 20h.text:00000001400015DF sar eax, 3.text:00000001400015E2 mov ecx, edx.text:00000001400015E4 sar ecx, 1Fh.text:00000001400015E7 sub eax, ecx.text:00000001400015E9 imul ecx, eax, 1Ah.text:00000001400015EC mov eax, edx.text:00000001400015EE sub eax, ecx ; 到这里结束，实现的是除以26.text:00000001400015F0 add eax, 41h ; 'A' ; 加上0x41.text:00000001400015F3 mov [rbp+10h+C], eax.text:00000001400015F6.text:00000001400015F6 loc_1400015F6: ; CODE XREF: solve(void)+E1↑j.text:00000001400015F6 ; solve(void)+F3↑j.text:00000001400015F6 mov eax, [rbp+10h+C].text:00000001400015F9 mov ecx, eax.text:00000001400015FB mov eax, [rbp+10h+count].text:00000001400015FE cdqe.text:0000000140001600 lea rdx, enc ; &quot;zbrpgs{F4z3_Ge1px_jvgu_@sybjre_qrfhjn}&quot;.text:0000000140001607 mov [rax+rdx], cl.text:000000014000160A add [rbp+10h+count], 1.text:000000014000160E.text:000000014000160E loc_14000160E: ; CODE XREF: solve(void)+89↑j.text:000000014000160E mov eax, [rbp+10h+count].text:0000000140001611 cmp eax, [rbp+10h+length].text:0000000140001614 jl loc_140001564.text:000000014000161A lea rax, aSoYouDidnTCatc ; &quot;so you didn't catch me?\\n&quot;.text:0000000140001621 mov rcx, rax ; char *.text:0000000140001624 ; try {.text:0000000140001624 call print.text:0000000140001624 ; } // starts at 140001624.text:0000000140001629 call __cxa_end_catch.text:000000014000162E jmp short loc_140001644.text:0000000140001630 ; ---------------------------------------------------------------------------.text:0000000140001630 ; cleanup() // owned by 140001624.text:0000000140001630 mov rbx, rax.text:0000000140001633 call __cxa_end_catch.text:0000000140001638 mov rax, rbx.text:000000014000163B mov rcx, rax ; gcc_exc.text:000000014000163E call _Unwind_Resume.text:000000014000163E ; ---------------------------------------------------------------------------.text:0000000140001643 align 4.text:0000000140001644.text:0000000140001644 loc_140001644: ; CODE XREF: solve(void)+158↑j.text:0000000140001644 add rsp, 30h.text:0000000140001648 pop rbx.text:0000000140001649 pop rsi.text:000000014000164A pop rbp.text:000000014000164B retn.text:000000014000164B ; } // starts at 1400014D6.text:000000014000164B _Z5solvev endp 解密脚本： 12345678910111213141516171819def decode(s): result = [] for char in s: #小写字母 if 'a' &lt;= char &lt;= 'z': new_char = chr((ord(char) - 0x54) % 26 + 0x61) result.append(new_char) #大写字母 elif 'A' &lt;= char &lt;= 'Z': new_char = chr((ord(char) - 0x34) % 26 + 0x41) result.append(new_char) #非字母 else: result.append(char) return ''.join(result)enc = &quot;zbrpgs{F4z3_Ge1px_jvgu_@sybjre_qrfhjn}&quot;flag = decode(enc)print(flag) upx_revenge 附件程序运行不了，如图： 题目提示upx特征段魔改，但是自己尝试后发现魔改特征段不会导致程序运行不了 后来琢磨了半天，拷打(bushi了一下出题人，才发现这个程序缺了bytes（看了官方WriteUp，发现这确实是一个考点😭，我真傻，真的，我单知道upx魔改会改特征段数据，我不知道还可以删数据😭） 缺少的地方在upx特征段，可以发现upx1段开头的四个字节错位了，错位到upx特征段上了，所以要给特征段插入四个字节 用010editor在49 01 00 C3后面按Ctrl+shift+I插入4bytes（默认填充为0），会发现程序可以运行了 采用手动脱壳的办法。具体操作可以参考week1_upx的解法或者看看Day9:壳与脱壳（一）和Day10:壳与脱壳（二）（王婆卖瓜这一块，这里从找到OEP开始： 下断点F9运行到上图这个大跳，然后F7步入 RIP指向此处时，打开scylla进行转储和IAT重建修复转储。这里需要注意，IAT搜索出来的结果里有一个损坏的导入，需要把它删掉 脱壳后的_dump_SCY.exe文件就可以用IDA打开正常分析了 首先查看字符串表，可以发现可疑的的提示”correct” 跟踪correct可以找到main函数。下面是优化后的main函数和相关的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192// Hidden C++ exception states: #wind=5int __fastcall main(int argc, const char **argv, const char **envp){ __int64 v3; // rax __int64 v4; // rdx unsigned __int8 v5; // al __int64 v6; // r8 void **v7; // rdx void **v8; // rsi size_t length; // rdi void *v10; // rax void *v11; // rcx _QWORD *newBuffer; // rax char *v13; // rbx char *enc; // rax char *v15; // rbx void **encryptedFlag; // rcx int v17; // eax char *outString; // rdx __int64 v19; // rax void *v20; // rcx void *v21; // rcx void *v22; // rcx void *v23; // rcx void *CopiedFlag[2]; // [rsp+28h] [rbp-51h] BYREF char *bufferEnd; // [rsp+38h] [rbp-41h] void *flag[2]; // [rsp+40h] [rbp-39h] BYREF __m128i si128; // [rsp+50h] [rbp-29h] void *encodeResult[2]; // [rsp+60h] [rbp-19h] BYREF size_t Size; // [rsp+70h] [rbp-9h] unsigned __int64 v31; // [rsp+78h] [rbp-1h] void *modifiedBaseTable[2]; // [rsp+80h] [rbp+7h] BYREF __m128i v33; // [rsp+90h] [rbp+17h] __int128 v34; // [rsp+A0h] [rbp+27h] __int64 v35; // [rsp+B0h] [rbp+37h] __int64 v36; // [rsp+B8h] [rbp+3Fh] v3 = output(std::cout, pleaseEnterYourFlag); std::istream::operator&gt;&gt;(v3, out_flush); *flag = 0LL; si128 = _mm_load_si128(&amp;xmmword_7FF7420B44B0); LOBYTE(flag[0]) = 0; LOBYTE(v4) = 10; v5 = std::ios::widen(&amp;std::cin + *(std::cin + 4LL), v4); input(std::cin, flag, v5); v7 = flag; if ( si128.m128i_i64[1] &gt; 0xFuLL ) // si128.m128i_i64[1]是输入的flag的长度 v7 = flag[0]; v8 = flag; if ( si128.m128i_i64[1] &gt; 0xFuLL ) v8 = flag[0]; *CopiedFlag = 0LL; bufferEnd = 0LL; length = v7 + si128.m128i_i64[0] - v8; if ( length ) { if ( length &gt; 0x7FFFFFFFFFFFFFFFLL ) lengthError(); if ( length &lt; 0x1000 ) { newBuffer = operator new(length); } else { if ( length + 39 &lt; length ) sub_7FF7420B1170(); v10 = operator new(length + 39); v11 = v10; if ( !v10 )LABEL_31: invalid_parameter_noinfo_noreturn(); newBuffer = ((v10 + 39) &amp; 0xFFFFFFFFFFFFFFE0uLL); *(newBuffer - 1) = v11; } CopiedFlag[0] = newBuffer; v13 = newBuffer + length; bufferEnd = newBuffer + length; memmove(newBuffer, v8, length); CopiedFlag[1] = v13; } XORencrypt(modifiedBaseTable, v7, v6); // 魔改base64的编码表 baseEncode(encodeResult, CopiedFlag, modifiedBaseTable);// base64编码 v34 = 0LL; enc = operator new(0x30uLL); v15 = enc; *&amp;v34 = enc; v35 = 44LL; v36 = 47LL; strcpy(enc, &quot;lY7bW=\\\\ck?eyjX7]TZ\\\\}CVbh\\\\tOyTH6&gt;jH7XmFifG]H7&quot;); encryptedFlag = encodeResult; if ( v31 &gt; 0xF ) encryptedFlag = encodeResult[0]; if ( Size != 44 || (v17 = memcmp(encryptedFlag, enc, 0x2CuLL), outString = aCorrect, v17) ) outString = aWrong; v19 = output(std::cout, outString); std::istream::operator&gt;&gt;(v19, out_flush); j_j_free(v15); if ( v31 &gt; 0xF ) { v20 = encodeResult[0]; if ( v31 + 1 &gt;= 0x1000 ) { v20 = *(encodeResult[0] - 1); if ( (encodeResult[0] - v20 - 8) &gt; 0x1F ) invalid_parameter_noinfo_noreturn(); } j_j_free(v20); } Size = 0LL; v31 = 15LL; LOBYTE(encodeResult[0]) = 0; if ( v33.m128i_i64[1] &gt; 0xFuLL ) { v21 = modifiedBaseTable[0]; if ( (v33.m128i_i64[1] + 1) &gt;= 0x1000 ) { v21 = *(modifiedBaseTable[0] - 1); if ( (modifiedBaseTable[0] - v21 - 8) &gt; 0x1F ) invalid_parameter_noinfo_noreturn(); } j_j_free(v21); } v33 = _mm_load_si128(&amp;xmmword_7FF7420B44B0); LOBYTE(modifiedBaseTable[0]) = 0; v22 = CopiedFlag[0]; if ( CopiedFlag[0] ) { if ( (bufferEnd - CopiedFlag[0]) &gt;= 0x1000 ) { v22 = *(CopiedFlag[0] - 1); if ( (CopiedFlag[0] - v22 - 8) &gt; 0x1F ) goto LABEL_31; } j_j_free(v22); } if ( si128.m128i_i64[1] &gt; 0xFuLL ) { v23 = flag[0]; if ( (si128.m128i_i64[1] + 1) &gt;= 0x1000 ) { v23 = *(flag[0] - 1); if ( (flag[0] - v23 - 8) &gt; 0x1F ) invalid_parameter_noinfo_noreturn(); } j_j_free(v23); } return 0;}// Hidden C++ exception states: #wind=5_QWORD *__fastcall XORencrypt(_QWORD *modifiedTable, __int64 a2, __int64 a3){ void **pTableStart; // rdx void **pCurrentPos; // rdi void **i; // rsi char xored; // r9 unsigned __int64 cucrrentSize; // rcx unsigned __int64 capacity; // rdx _QWORD *Table; // rax *modifiedTable = 0LL; modifiedTable[2] = 0LL; modifiedTable[3] = 15LL; *modifiedTable = 0; pTableStart = &amp;oriTable; pCurrentPos = &amp;oriTable; if ( *(&amp;xmmword_7FF7420B6760 + 1) &gt; 0xFuLL ) { pCurrentPos = oriTable; // oriTable是原始的base64编码表 pTableStart = oriTable; } for ( i = (pTableStart + xmmword_7FF7420B6760); pCurrentPos != i; pCurrentPos = (pCurrentPos + 1) ) { xored = *pCurrentPos ^ 0xE; // 遍历Table并异或0xE，创建一个魔改的编码表 cucrrentSize = modifiedTable[2]; capacity = modifiedTable[3]; if ( cucrrentSize &gt;= capacity ) { needExpand(modifiedTable, capacity, a3, xored); } else { modifiedTable[2] = cucrrentSize + 1; // 此处开始写入xor处理后的table字符 Table = modifiedTable; if ( capacity &gt; 0xF ) Table = *modifiedTable; *(Table + cucrrentSize) = xored; *(Table + cucrrentSize + 1) = 0; } } return modifiedTable;} 可以看出逻辑就是先魔改base64的编码表，然后再用魔改的编码表对flag进行base64编码，最后和给定的密文比较。可以先对enc进行异或，然后再base64解码 1234567enc = &quot;lY7bW=\\\\ck?eyjX7]TZ\\\\}CVbh\\\\tOyTH6&gt;jH7XmFifG]H7&quot;data = &quot;&quot;for char in enc: data += chr(ord(char) ^ 0xE)print(data)#bW9lY3Rme1kwdV9SZTRsMXlfRzAwZF80dF9VcHghISF9 Two cups of tea 反编译的代码分析优化后大概是这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//main函数部分int __fastcall main(int argc, const char **argv, const char **envp){ __int64 n; // rbx FILE *Stream; // rax size_t length; // rax __int64 v6; // rdx __int64 count; // rax unsigned __int64 tmp4key; // [rsp+20h] [rbp-E0h] BYREF char key_2; // [rsp+28h] [rbp-D8h] __int64 key_1; // [rsp+30h] [rbp-D0h] BYREF int key_3; // [rsp+38h] [rbp-C8h] int key_4; // [rsp+3Ch] [rbp-C4h] _DWORD enc[10]; // [rsp+40h] [rbp-C0h] _OWORD flag[2]; // [rsp+68h] [rbp-98h] BYREF __int64 v16; // [rsp+88h] [rbp-78h] char Buffer[16]; // [rsp+90h] [rbp-70h] BYREF __int128 v18; // [rsp+A0h] [rbp-60h] __int64 v19; // [rsp+B0h] [rbp-50h] n = 0LL; key_1 = 2LL; key_2 = 0; key_3 = 2; key_4 = 5; enc[0] = 0x5D624C34; enc[1] = 0x8629FEAD; enc[2] = 0x9D11379B; enc[3] = 0xFCD53211; enc[4] = 0x460F63CE; enc[5] = 0xC5816E68; enc[6] = 0xFE5300AD; enc[7] = 0xA0015EE; enc[8] = 0x9806DBBB; enc[9] = 0xEF4A2648; tmp4key = 0xD0FCC6A7B8941CAFuLL; key_init(*&amp;argc, &amp;tmp4key, &amp;key_1);// 这里初始化了key,不必理会具体实现，可以动调得到结果 printf(&amp;pleaseEnterYourFlag); Stream = _acrt_iob_func(0); fgets(Buffer, 100, Stream); length = strcspn(Buffer, &quot;\\n&quot;);// 获取flag的长度 if ( length &gt;= 0x64 ) _report_securityfailure_(); Buffer[length] = 0; flag[0] = *Buffer; key_1 = tmp4key; v16 = v19; flag[1] = v18; key_3 = 0x12345678; key_4 = 0x9ABCDEF0; modefiedTea(flag, v6, &amp;key_1);// 魔改的tea，加密flag以便比对验证 count = -1LL; do ++count; while ( Buffer[count] );// 确认flag长度 if ( count == 40 ) { while ( *(flag + n * 4) == enc[n] )// 比对验证 { if ( ++n &gt;= 10 ) { printf(right); return 0; } } printf(wrong); } else { printf(Format_0); } return 0;}//魔改tea部分__int64 __fastcall modefiedTea(unsigned int *flag, __int64 a2, __int64 key){ unsigned int flag_9; // r9d int delta; // r11d unsigned int flag_eight; // edx unsigned int flag_1; // esi unsigned int flag_2; // ebp unsigned int flag_3; // r14d unsigned int flag_4; // r15d unsigned int flag_5; // r12d unsigned int flag_6; // r13d int flag_o; // ebx unsigned int flag_7; // ecx int key_0; // edi int key_1; // ebx __int64 key_3; // r10 int key_2; // r11d int v18; // eax bool Count; // zf __int64 flag_seven; // rax unsigned int flag_0; // [rsp+0h] [rbp-58h] unsigned int flag_nine; // [rsp+4h] [rbp-54h] int count; // [rsp+8h] [rbp-50h] int delta_1; // [rsp+68h] [rbp+10h] __int64 Key; // [rsp+70h] [rbp+18h] unsigned int flag_8; // [rsp+78h] [rbp+20h] Key = key; flag_9 = flag[9]; delta = 0; flag_eight = flag[8]; flag_1 = flag[1]; flag_2 = flag[2]; flag_3 = flag[3]; flag_4 = flag[4]; flag_5 = flag[5]; flag_6 = flag[6]; flag_o = *flag; flag_7 = flag[7]; flag_8 = flag_eight; flag_nine = flag_9; count = 11; while ( 1 ) { delta_1 = delta - 1640531527; key_0 = *(key + 4LL * (((delta - 1640531527) &gt;&gt; 2) &amp; 3)); flag_0 = flag_o + ((((16 * flag_9) ^ (flag_1 &gt;&gt; 3)) + ((flag_9 &gt;&gt; 5) ^ (4 * flag_1))) ^ (((delta - 1640531527) ^ flag_1) + (key_0 ^ flag_9))); key_1 = *(Key + 4 * (((delta - 1640531527) &gt;&gt; 2) &amp; 3 ^ 1LL)); flag_1 += ((flag_0 ^ key_1) + ((delta - 1640531527) ^ flag_2)) ^ (((16 * flag_0) ^ (flag_2 &gt;&gt; 3)) + ((flag_0 &gt;&gt; 5) ^ (4 * flag_2))); key_3 = ((delta - 1640531527) &gt;&gt; 2) &amp; 3 ^ 3LL; key_2 = *(Key + 4 * (((delta - 1640531527) &gt;&gt; 2) &amp; 3 ^ 2LL)); flag_2 += ((flag_1 ^ key_2) + (delta_1 ^ flag_3)) ^ (((16 * flag_1) ^ (flag_3 &gt;&gt; 3)) + ((flag_1 &gt;&gt; 5) ^ (4 * flag_3))); flag_3 += ((delta_1 ^ flag_4) + (flag_2 ^ *(Key + 4 * key_3))) ^ (((16 * flag_2) ^ (flag_4 &gt;&gt; 3)) + ((flag_2 &gt;&gt; 5) ^ (4 * flag_4))); flag_4 += ((flag_3 ^ key_0) + (delta_1 ^ flag_5)) ^ (((16 * flag_3) ^ (flag_5 &gt;&gt; 3)) + ((flag_3 &gt;&gt; 5) ^ (4 * flag_5))); flag_5 += ((flag_4 ^ key_1) + (delta_1 ^ flag_6)) ^ (((16 * flag_4) ^ (flag_6 &gt;&gt; 3)) + ((flag_4 &gt;&gt; 5) ^ (4 * flag_6))); v18 = (flag_5 ^ key_2) + (delta_1 ^ flag_7); delta = delta_1; flag_6 += v18 ^ (((16 * flag_5) ^ (flag_7 &gt;&gt; 3)) + ((flag_5 &gt;&gt; 5) ^ (4 * flag_7))); flag_7 += ((flag_6 ^ *(Key + 4 * key_3)) + (delta_1 ^ flag_8)) ^ (((16 * flag_6) ^ (flag_8 &gt;&gt; 3)) + ((flag_6 &gt;&gt; 5) ^ (4 * flag_8))); flag_8 += ((flag_7 ^ key_0) + (delta_1 ^ flag_nine)) ^ (((16 * flag_7) ^ (flag_nine &gt;&gt; 3)) + ((flag_7 &gt;&gt; 5) ^ (4 * flag_nine))); flag_9 = (((flag_8 ^ key_1) + (delta_1 ^ flag_0)) ^ (((16 * flag_8) ^ (flag_0 &gt;&gt; 3)) + ((flag_8 &gt;&gt; 5) ^ (4 * flag_0)))) + flag_nine; key = Key; Count = count-- == 1; flag_nine = flag_9; if ( Count ) break; flag_o = flag_0; } flag_seven = flag_7; flag[1] = flag_1; flag[2] = flag_2; flag[3] = flag_3; flag[4] = flag_4; flag[5] = flag_5; flag[6] = flag_6; flag[7] = flag_7; flag[8] = flag_8; flag[9] = flag_9; *flag = flag_0; return flag_seven;} 由于加密主要依赖的是异或，只要复原出加密时的环境（相关变量），就可以再次加密实现复原。下图是AI给的加密逻辑分析。首先每轮加密的密钥不同，其次每个字符块的加密都依赖前一块和后一块。突破口：对于flag9而言，它的前一块和后一块都是经过本轮加密的，也就是说在最后一轮，flag9依赖的是最终密文的flag0和flag8，可以利用最终密文直接解密。解密出最后一轮的未加密flag9后，就可以往回解密flag8-flag0，就这样11轮解密回去。 123456789101112131415161718192021222324252627282930313233343536373839┌─────────────────────────────────────────────────────────────────────────┐│ 修改版TEA加密（10块Feistel结构，11轮） │└─────────────────────────────────────────────────────────────────────────┘输入: flag[0]...flag[9] (10个32位字), key[0]...key[3] (128位密钥)初始化: delta = 0 count = 11开始循环（11轮）: delta_1 = delta - 0x61C88647 (无符号减法，1640531527的十六进制) 密钥调度: k0 = key[(delta_1&gt;&gt;2) &amp; 3] k1 = key[((delta_1&gt;&gt;2) &amp; 3) ^ 1] k2 = key[((delta_1&gt;&gt;2) &amp; 3) ^ 2] k3 = key[((delta_1&gt;&gt;2) &amp; 3) ^ 3] 加密链（每轮更新所有10个字，顺序依赖）: flag0 += F(flag9, flag1, delta_1, k0) flag1 += F(flag0, flag2, delta_1, k1) flag2 += F(flag1, flag3, delta_1, k2) flag3 += F(flag2, flag4, delta_1, k3) flag4 += F(flag3, flag5, delta_1, k0) flag5 += F(flag4, flag6, delta_1, k1) flag6 += F(flag5, flag7, delta_1, k2) flag7 += F(flag6, flag8, delta_1, k3) flag8 += F(flag7, flag9, delta_1, k0) flag9 += F(flag8, flag0, delta_1, k1) 其中 F(a, b, delta, k) = ((16*a) ^ (b&gt;&gt;3)) + ((a&gt;&gt;5) ^ (4*b))) ^ ( (delta ^ b) + (k ^ a) ) 更新delta = delta_1循环结束（count减至1）输出: 加密后的flag[0]...flag[9] 解密脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void modefiedTea_decrypt(uint32_t* flag, uint32_t* key) { int32_t deltas[11]; int32_t delta = 0; for (int i = 0; i &lt; 11; i++) { delta -= 1640531527; deltas[i] = delta; } for (int round = 10; round &gt;= 0; round--) { uint32_t delta_1 = deltas[round]; uint32_t k0 = key[((delta_1 &gt;&gt; 2) &amp; 3)]; uint32_t k1 = key[((delta_1 &gt;&gt; 2) &amp; 3) ^ 1]; uint32_t k2 = key[((delta_1 &gt;&gt; 2) &amp; 3) ^ 2]; uint32_t k3 = key[((delta_1 &gt;&gt; 2) &amp; 3) ^ 3]; flag[9] -= ((flag[8] ^ k1) + (delta_1 ^ flag[0])) ^ (((16 * flag[8]) ^ (flag[0] &gt;&gt; 3)) + ((flag[8] &gt;&gt; 5) ^ (4 * flag[0]))); flag[8] -= ((flag[7] ^ k0) + (delta_1 ^ flag[9])) ^ (((16 * flag[7]) ^ (flag[9] &gt;&gt; 3)) + ((flag[7] &gt;&gt; 5) ^ (4 * flag[9]))); flag[7] -= ((flag[6] ^ k3) + (delta_1 ^ flag[8])) ^ (((16 * flag[6]) ^ (flag[8] &gt;&gt; 3)) + ((flag[6] &gt;&gt; 5) ^ (4 * flag[8]))); flag[6] -= ((flag[5] ^ k2) + (delta_1 ^ flag[7])) ^ (((16 * flag[5]) ^ (flag[7] &gt;&gt; 3)) + ((flag[5] &gt;&gt; 5) ^ (4 * flag[7]))); flag[5] -= ((flag[4] ^ k1) + (delta_1 ^ flag[6])) ^ (((16 * flag[4]) ^ (flag[6] &gt;&gt; 3)) + ((flag[4] &gt;&gt; 5) ^ (4 * flag[6]))); flag[4] -= ((flag[3] ^ k0) + (delta_1 ^ flag[5])) ^ (((16 * flag[3]) ^ (flag[5] &gt;&gt; 3)) + ((flag[3] &gt;&gt; 5) ^ (4 * flag[5]))); flag[3] -= ((flag[2] ^ k3) + (delta_1 ^ flag[4])) ^ (((16 * flag[2]) ^ (flag[4] &gt;&gt; 3)) + ((flag[2] &gt;&gt; 5) ^ (4 * flag[4]))); flag[2] -= ((flag[1] ^ k2) + (delta_1 ^ flag[3])) ^ (((16 * flag[1]) ^ (flag[3] &gt;&gt; 3)) + ((flag[1] &gt;&gt; 5) ^ (4 * flag[3]))); flag[1] -= ((flag[0] ^ k1) + (delta_1 ^ flag[2])) ^ (((16 * flag[0]) ^ (flag[2] &gt;&gt; 3)) + ((flag[0] &gt;&gt; 5) ^ (4 * flag[2]))); flag[0] -= ((flag[9] ^ k0) + (delta_1 ^ flag[1])) ^ (((16 * flag[9]) ^ (flag[1] &gt;&gt; 3)) + ((flag[9] &gt;&gt; 5) ^ (4 * flag[1]))); }}int main() { uint32_t enc[10] = { 0x5D624C34, 0x8629FEAD, 0x9D11379B, 0xFCD53211, 0x460F63CE, 0xC5816E68, 0xFE5300AD, 0x0A0015EE, 0x9806DBBB, 0xEF4A2648 }; uint32_t key[4] = { 0x63656F6D, 0x21216674, 0x12345678, 0x9ABCDEF0 }; modefiedTea_decrypt(enc, key); unsigned char* flag_str = (unsigned char*)enc; for (int i = 0; i &lt; 40; i++) { if (flag_str[i] &gt;= 32 &amp;&amp; flag_str[i] &lt;= 126) { printf(&quot;%c&quot;, flag_str[i]); } else { printf(&quot;\\\\x%02X&quot;, flag_str[i]); } } printf(&quot;\\n&quot;); return 0;} week3have_fun 附件是一个Windows GUI程序，界面如图。工具栏的“交互”实现flag的验证。 main函数主要实现的是创建窗口，涉及到WNDCLASSEXW结构体（详细信息见：WNDCLASSEXW （winuser.h） - Win32 apps | Microsoft Learn）。其中，结构体变量lpfnWndProc涉及窗口过程的实现，所以flag验证的相关逻辑在lpfnWndProc指向的函数中查看（图中重命名为ToolBar） ToolBar中，实现了工具栏三个选项的交互逻辑，其中，DialogBoxParamW实现的是”交互“选项（因为参数DialogFunc看着最复杂，最像flag验证逻辑） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ToolBar函数LRESULT __fastcall ToolBar(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam){ HDC hdc; // rsi HFONT FontW; // rdi HGDIOBJ h; // rbx tagPAINTSTRUCT Paint; // [rsp+70h] [rbp-88h] BYREF switch ( Msg ) { case 2u: PostQuitMessage(0); break; case 0xFu: hdc = BeginPaint(hWnd, &amp;Paint); SetTextColor(hdc, 0xFFu); SetBkMode(hdc, 1); FontW = CreateFontW(36, 0, 0, 0, 700, 0, 0, 0, 1u, 0, 0, 0, 0x20u, &amp;pszFaceName); h = SelectObject(hdc, FontW); TextOutW(hdc, 500, 160, &amp;String, 15); TextOutW(hdc, 500, 200, &amp;word_7FF6D7EA3350, 10); SelectObject(hdc, h); DeleteObject(FontW); EndPaint(hWnd, &amp;Paint); break; case 0x111u: switch ( wParam ) { case 0x68u: DialogBoxParamW(hInstance, 0x67, hWnd, sub_7FF6D7EA1420, 0LL); break; case 0x69u: DestroyWindow(hWnd); break; case 0x9C42u: DialogBoxParamW(hInstance, 0x66, hWnd, DialogFunc, 0LL);//“交互”选项 break; default: return DefWindowProcW(hWnd, Msg, wParam, lParam); } break; default: return DefWindowProcW(hWnd, Msg, wParam, lParam); } return 0LL;} DialogFunc函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596INT_PTR __fastcall DialogFunc(HWND hDlg, int a2, unsigned __int16 n1003){ HWND hDlg_1; // rbx int v4; // edx __int64 length; // rax int n32_2; // r8d __m128 si128; // xmm2 __int64 v8; // rdx unsigned __int64 v9; // rcx __m128 v10; // xmm0 __m128 v11; // xmm1 __m128 v12; // xmm0 __m128 v13; // xmm1 __int64 count; // rdx unsigned __int16 *currentChar; // rdx int currentEnc; // r8d int judgeNumber; // r9d const WCHAR *PrintText; // r8 _OWORD v20[2]; // [rsp+0h] [rbp-1D8h] BYREF WCHAR flag[8]; // [rsp+20h] [rbp-1B8h] BYREF _OWORD v22[12]; // [rsp+30h] [rbp-1A8h] BYREF _WORD flag_xored[104]; // [rsp+F0h] [rbp-E8h] BYREF hDlg_1 = hDlg; v4 = a2 - 272; if ( !v4 ) { PrintText = &amp;word_7FF6D7EA3368;LABEL_22: SetDlgItemTextW(hDlg, 1002, PrintText); return 1LL; } if ( v4 != 1 ) return 0LL; if ( (n1003 - 1) &gt; 1u ) { if ( n1003 == 1003 ) { GetDlgItemTextW(hDlg, 1001, flag, 100); length = -1LL; do ++length; while ( flag[length] ); n32_2 = 0; if ( length &gt;= 32 )// flag长度大于32的情况（实际上不能是这种情况） { si128 = _mm_load_si128(&amp;xmmword_7FF6D7EA33F0); v8 = 0LL; v9 = 0LL; do { v10 = _mm_loadu_si128(&amp;flag[v9 / 2]); n32_2 += 32; v8 += 32LL; v11 = _mm_loadu_si128(&amp;v22[v9 / 0x10]); v9 += 64LL; v22[v9 / 0x10 + 8] = _mm_xor_ps(v10, si128); v12 = _mm_loadu_si128(&amp;v20[v9 / 0x10]); v22[v9 / 0x10 + 9] = _mm_xor_ps(v11, si128); v13 = _mm_loadu_si128(&amp;v20[v9 / 0x10 + 1]); v22[v9 / 0x10 + 10] = _mm_xor_ps(v12, si128); v22[v9 / 0x10 + 11] = _mm_xor_ps(v13, si128); } while ( v8 &lt; (length - (length &amp; 31)) ); } count = n32_2;// 上述情况应不成立，因此n32_2为0 if ( n32_2 &lt; length ) { do { flag_xored[count] = flag[count] ^ 0x2A; ++count; } while ( count &lt; length ); } flag_xored[length] = 0; currentChar = flag_xored; do { currentEnc = *(currentChar + &amp;enc - flag_xored);// enc[currentChar-flag_xored] judgeNumber = *currentChar - currentEnc; if ( judgeNumber ) break; ++currentChar; } while ( currentEnc ); if ( judgeNumber || (PrintText = &amp;right, length != 16) )// flag长度由此处得出 PrintText = &amp;wrong; hDlg = hDlg_1; goto LABEL_22; } return 0LL; } EndDialog(hDlg, n1003); return 1LL;} 逻辑很明显，遍历flag，每个字符异或0x2A，然后和enc比较。解密脚本： 12345enc = [ 0x0047, 0x0045, 0x004F, 0x0049, 0x005E, 0x004C, 0x0051, 0x0062, 0x006A, 0x005C, 0x001E, 0x0075, 0x004C, 0x007F, 0x0044, 0x0057]flag = ''.join(chr(b ^ 0x2A) for b in enc)print(flag) guess 附件程序是一个猜数字游戏，用IDA打开，通过字符串表的关键数据”You are right!\\n”可以快速定位到main函数的位置 main函数F5反编译不了，sp value报错，说明有花指令。把栈指针勾选上，会发现栈帧突变的位置： 栈帧改变太多，明显不对，把sub rsp, rax给nop掉。然后可以发现函数末尾栈帧会有点问题： 把add rsp, 1428h也给nop掉，这样main函数基本上可以反编译了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//优化后的main函数// bad sp value at call has been detected, the output may be wrong!int __fastcall main(int argc, const char **argv, const char **envp){ bool v3; // dl std::ostream *v4; // rax unsigned int v5; // eax _QWORD *v6; // rax std::ostream *v8; // rax __int64 v9; // rax __int64 v10; // rbx std::ostream *v11; // rax std::ostream *v12; // rax std::ostream *v13; // rax std::ostream *v14; // rax unsigned int n0x64; // [rsp+2Ch] [rbp-54h] _BYTE v17[2512]; // [rsp+30h] [rbp-50h] BYREF _BYTE v18[2512]; // [rsp+A00h] [rbp+980h] BYREF _BYTE v19[32]; // [rsp+13D0h] [rbp+1350h] BYREF _BYTE v20[40]; // [rsp+13F0h] [rbp+1370h] BYREF unsigned int n0x64_1; // [rsp+1418h] [rbp+1398h] int i; // [rsp+141Ch] [rbp+139Ch] _main(argc, argv, envp); std::ios_base::sync_with_stdio(0LL, v3); std::ios::tie((char *)in + 16, 0LL); cout(out, &quot;Welcome to MoeCTF 2025!\\n&quot;); cout(out, &quot;Let's play a game!\\n&quot;); cout(out, &quot;I have a secret number between 0 and 99, and you can guess it 10 times.\\n&quot;); v4 = (std::ostream *)cout(out, &quot;If you successly guessed it, I will give you the flag!&quot;); endl(v4); random_device((std::random_device *)v18); v5 = random_operator(v18); mersenne_twister_engine(v17, v5); std::random_device::~random_device((std::random_device *)v18); n0x64_1 = (unsigned int)mersenne_twister_engine_operator(v17) % 0x64; for ( i = 0; i &lt;= 9; ++i ) { cout(out, &quot;Please input your number: &quot;); std::ostream::flush(out); v6 = (_QWORD *)cin(in); if ( (unsigned __int8)std::ios::operator!((char *)v6 + *(_QWORD *)(*v6 - 24LL)) || n0x64 &gt;= 0x64 ) { v8 = (std::ostream *)cout(out, &quot;Invalid input&quot;); endl(v8); std::ios::clear((char *)in + 16, 0LL); v9 = std::numeric_limits&lt;long long&gt;::max(); std::istream::ignore(in, v9, 10); } else { if ( n0x64_1 == n0x64 ) { cout(out, &quot;You are right!\\n&quot;); v10 = cout(out, &quot;The flag is moectf{&quot;); hex_to_binary(v20, &amp;enc[abi:cxx11]); rc4_decrypt(v19, v20, &amp;key[abi:cxx11]); v11 = (std::ostream *)std::operator&lt;&lt;&lt;char&gt;(v10, v19); v12 = (std::ostream *)cout(v11, &quot;}.&quot;); endl(v12); std::string::~string(v19); std::string::~string(v20); break; } v13 = (std::ostream *)cout(out, &quot;That's not right...&quot;); endl(v13); } } v14 = (std::ostream *)cout(out, &quot;Thanks for your playing!&quot;); endl(v14); return 0;} 可以看出，main函数的逻辑是先获取一个数字输入，然后经过和随机数有关的各种操作来判断是否符合条件，符合条件就输出flag。既然可以直接输出flag，不妨就动调改变判断结果直接得到flag。找到和输出有关的判断逻辑的位置： 动调程序步过此处后，改一下ZF即可让程序跳到”You are right!\\n”处获得flag输出。好在本题没有给动调挖坑，可以直接得到flag： rusty_sudoku rust语言的数独游戏。运行附件程序，提示逆向分析程序找到数独并求解。用IDA打开，结合AI辅助优化后main函数长这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474__int64 __fastcall rusty_sudoku::main(__int64 a1, __int64 a2, __int64 a3){ __int128 *md5_ctx_prt; // rdi __int64 temp; // rdx size_t cupy_size; // rdx unsigned __int8 *input_end; // rcx unsigned __int8 *trimmed_length; // rsi unsigned __int8 *trimmed_start; // r9 unsigned __int8 *input_ptr; // r8 char is_whitespace; // r11 unsigned __int8 *current_ptr; // rbx unsigned __int8 *trimmed_count; // rax unsigned int codepoint; // r11d int v14; // r9d int temp_val1; // r14d int temp_val2; // ebp unsigned int high_byte; // ebx __int64 alloc_result; // rbx char is_whitespace2; // bl unsigned __int8 *end_ptr; // r11 unsigned int codepoint2; // esi char byte1; // bl char byte2; // bp int temp_val3; // ebp int temp_val4; // ebx unsigned int high_byte2; // ebx size_t actual_size; // r15 __int64 alloc_size; // r14 __int64 allocated_mem; // rax __int64 expected_char; // r9 __int64 input_data; // rdx __int64 index; // rax int user_char; // ecx int v34; // edx int temp_val5; // r8d __int64 result; // rax __int64 user_index; // rax __int64 sudoku_index; // rdx int user_codepointer; // r8d int v40; // r9d int temp_val6; // r11d int temp_val7; // r10d int v43; // r10d int temp_val8; // ebp int temp_val9; // r11d __int64 temp_arg1; // rdx __int64 temp_arg2; // rdx __int64 temp_arg3; // rdx _BYTE buf[88]; // [rsp+30h] [rbp-178h] BYREF __int128 fmt_arg1; // [rsp+90h] [rbp-118h] BYREF __int128 fmt_arg2; // [rsp+A0h] [rbp-108h] __int128 fmt_arg3; // [rsp+B0h] [rbp-F8h] __int128 fmt_arg4; // [rsp+C0h] [rbp-E8h] __int128 fmt_arg5; // [rsp+D0h] [rbp-D8h] __int64 fmt_arg6; // [rsp+E0h] [rbp-C8h] _OWORD stdin_handle[5]; // [rsp+F0h] [rbp-B8h] BYREF char board_data; // [rsp+140h] [rbp-68h] _BYTE md5_hash[16]; // [rsp+150h] [rbp-58h] BYREF *buf = &amp;welcome; // &quot;Welcome to MoeCTF 2025!\\nPlease **find** my sudoku and fill it correctly.\\nAnd then I will give you the flag.\\nInput your answer in one line (without spaces).\\nfor example, 854219763397865421261473985785126394649538172132947856926384517513792648478651239 represents:\\n854|219|763\\n397|865|421\\n261|473|985\\n-----------\\n785|126|394\\n649|538|172\\n132|947|856\\n-----------\\n926|384|517\\n513|792|648\\n478|651|239\\n\\nYour answer:\\n&quot; *&amp;buf[8] = 1LL; *&amp;buf[16] = 8LL; *&amp;buf[24] = 0LL; std::io::stdio::_print(a1, a2, a3, buf); *buf = 0LL; *&amp;buf[8] = 1LL; *&amp;buf[16] = 0LL; *&amp;stdin_handle[0] = std::io::stdio::stdin(); md5_ctx_prt = stdin_handle; if ( (std::io::stdio::Stdin::read_line(stdin_handle, a2, buf, stdin_handle) &amp; 1) != 0 ) { *&amp;fmt_arg1 = temp; core::result::unwrap_failed(stdin_handle, a2, 14, &quot;Invalid input.src\\\\main.rs&quot;, &amp;fmt_arg1, &amp;off_7FF6BF752050); } cupy_size = *&amp;buf[8]; input_end = (*&amp;buf[8] + *&amp;buf[16]); if ( *&amp;buf[16] ) { trimmed_length = 0LL; trimmed_start = 0LL; input_ptr = *&amp;buf[8]; while ( 1 ) { current_ptr = input_ptr; trimmed_count = trimmed_start; codepoint = *input_ptr; if ( (codepoint &amp; 0x80u) != 0 ) { v14 = codepoint &amp; 0x1F; temp_val1 = input_ptr[1] &amp; 0x3F; if ( codepoint &lt;= 0xDFu ) { input_ptr += 2; codepoint = temp_val1 | (v14 &lt;&lt; 6); } else { temp_val2 = (temp_val1 &lt;&lt; 6) | input_ptr[2] &amp; 0x3F; if ( codepoint &lt; 0xF0u ) { input_ptr += 3; codepoint = (v14 &lt;&lt; 12) | temp_val2; } else { input_ptr += 4; codepoint = ((codepoint &amp; 7) &lt;&lt; 18) | (temp_val2 &lt;&lt; 6) | current_ptr[3] &amp; 0x3F; } } } else { ++input_ptr; } trimmed_start = &amp;trimmed_count[input_ptr - current_ptr]; if ( codepoint - 9 &gt;= 5 &amp;&amp; codepoint != 32 ) { if ( codepoint &lt; 0x80 ) goto LABEL_27; high_byte = codepoint &gt;&gt; 8; if ( codepoint &gt;&gt; 8 &gt; 0x1F ) { if ( high_byte == 32 ) { is_whitespace = *(core::unicode::unicode_data::white_space::WHITESPACE_MAP + codepoint) &gt;&gt; 1; } else { if ( high_byte != 48 ) goto LABEL_27; is_whitespace = codepoint == 12288; } } else if ( high_byte ) { if ( high_byte != 22 ) goto LABEL_27; is_whitespace = codepoint == 5760; } else { is_whitespace = *(core::unicode::unicode_data::white_space::WHITESPACE_MAP + codepoint); } if ( (is_whitespace &amp; 1) == 0 ) goto LABEL_27; } if ( input_ptr == input_end ) { alloc_result = 1LL; goto LABEL_58; } } } trimmed_start = 0LL; input_ptr = *&amp;buf[8]; trimmed_count = 0LL;LABEL_27: if ( input_ptr == input_end ) goto LABEL_53; while ( 1 ) { end_ptr = input_end; codepoint2 = *(input_end - 1); if ( (codepoint2 &amp; 0x80000000) != 0 ) { byte1 = *(input_end - 2); if ( byte1 &gt;= -64 ) { input_end -= 2; temp_val4 = byte1 &amp; 0x1F; } else { byte2 = *(input_end - 3); if ( byte2 &gt;= -64 ) { input_end -= 3; temp_val3 = byte2 &amp; 0xF; } else { input_end -= 4; temp_val3 = ((*(end_ptr - 4) &amp; 7) &lt;&lt; 6) | byte2 &amp; 0x3F; } temp_val4 = (temp_val3 &lt;&lt; 6) | byte1 &amp; 0x3F; } codepoint2 = (temp_val4 &lt;&lt; 6) | codepoint2 &amp; 0x3F; if ( codepoint2 - 9 &lt; 5 ) goto LABEL_31; } else { --input_end; if ( codepoint2 - 9 &lt; 5 ) goto LABEL_31; } if ( codepoint2 == 32 ) goto LABEL_31; if ( codepoint2 &lt; 0x80 ) break; high_byte2 = codepoint2 &gt;&gt; 8; if ( codepoint2 &gt;&gt; 8 &lt;= 0x1F ) { if ( high_byte2 ) { if ( high_byte2 != 22 ) break; is_whitespace2 = codepoint2 == 5760; } else { is_whitespace2 = *(core::unicode::unicode_data::white_space::WHITESPACE_MAP + codepoint2); } goto LABEL_30; } if ( high_byte2 == 32 ) { is_whitespace2 = *(core::unicode::unicode_data::white_space::WHITESPACE_MAP + codepoint2) &gt;&gt; 1; goto LABEL_30; } if ( high_byte2 != 48 ) break; is_whitespace2 = codepoint2 == 12288;LABEL_30: if ( (is_whitespace2 &amp; 1) == 0 ) break;LABEL_31: if ( input_ptr == input_end ) goto LABEL_53; } trimmed_start = &amp;end_ptr[trimmed_start - input_ptr];LABEL_53: trimmed_length = (trimmed_start - trimmed_count); if ( trimmed_start - trimmed_count &lt; 0 ) { alloc_size = 0LL; goto LABEL_110; } cupy_size = &amp;trimmed_count[*&amp;buf[8]]; if ( trimmed_start == trimmed_count ) { alloc_result = 1LL; trimmed_length = 0LL; goto LABEL_58; } actual_size = &amp;trimmed_count[*&amp;buf[8]]; RNvCs73fAdSrgOJL_7___rustc35___rust_no_alloc_shim_is_unstable_v2(stdin_handle, trimmed_length); alloc_size = 1LL; allocated_mem = __rustc::__rust_alloc(stdin_handle, trimmed_length, 1LL, trimmed_length); if ( !allocated_mem )LABEL_110: alloc::raw_vec::handle_error(stdin_handle, trimmed_length, trimmed_length, alloc_size, &amp;off_7FF6BF7521D8);// &quot;/rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\\\\library\\\\alloc\\\\src\\\\slice.rs&quot; alloc_result = allocated_mem; cupy_size = actual_size;LABEL_58: memcpy(stdin_handle, trimmed_length, cupy_size); input_data = *buf; if ( *buf ) __rustc::__rust_dealloc(stdin_handle, trimmed_length, *buf, *&amp;buf[8], 1LL); if ( trimmed_length == 81 ) { index = 0LL; while ( index != 81 ) { user_char = *(alloc_result + index); if ( (user_char &amp; 0x80u) == 0 ) { ++index; } else { v34 = user_char &amp; 0x1F; expected_char = *(alloc_result + index + 1) &amp; 0x3F; if ( user_char &lt;= 0xDFu ) { index += 2LL; input_data = expected_char | (v34 &lt;&lt; 6); user_char = input_data; } else { expected_char = (expected_char &lt;&lt; 6); temp_val5 = expected_char | *(alloc_result + index + 2) &amp; 0x3F; if ( user_char &lt; 0xF0u ) { index += 3LL; input_data = (v34 &lt;&lt; 12); user_char = input_data | temp_val5; } else { input_data = (user_char &amp; 7) &lt;&lt; 18; user_char = input_data | (temp_val5 &lt;&lt; 6) | *(alloc_result + index + 3) &amp; 0x3F; if ( user_char == 1114112 ) break; index += 4LL; } } } if ( (user_char - 58) &lt; 0xFFFFFFF6 ) goto LABEL_72; } user_index = 0LL; sudoku_index = 0LL; while ( user_index != 81 ) { user_codepointer = *(alloc_result + user_index); if ( (user_codepointer &amp; 0x80u) != 0 ) { v40 = user_codepointer &amp; 0x1F; temp_val6 = *(alloc_result + user_index + 1) &amp; 0x3F; if ( user_codepointer &lt;= 0xDFu ) { user_index += 2LL; expected_char = temp_val6 | (v40 &lt;&lt; 6); user_codepointer = expected_char; if ( sudoku_index == 81 ) break; } else { temp_val7 = (temp_val6 &lt;&lt; 6) | *(alloc_result + user_index + 2) &amp; 0x3F; if ( user_codepointer &lt; 0xF0u ) { user_index += 3LL; expected_char = (v40 &lt;&lt; 12); user_codepointer = expected_char | temp_val7; if ( sudoku_index == 81 ) break; } else { expected_char = (user_codepointer &amp; 7) &lt;&lt; 18; user_codepointer = expected_char | (temp_val7 &lt;&lt; 6) | *(alloc_result + user_index + 3) &amp; 0x3F; if ( user_codepointer == 1114112 ) break; user_index += 4LL; if ( sudoku_index == 81 ) break; } } } else { ++user_index; if ( sudoku_index == 81 ) break; } expected_char = sudoku[sudoku_index]; if ( (expected_char &amp; 0x80u) != 0LL ) { v43 = expected_char &amp; 0x1F; temp_val8 = sudoku[sudoku_index + 1] &amp; 0x3F; if ( expected_char &lt;= 0xDFu ) { sudoku_index += 2LL; expected_char = temp_val8 | (v43 &lt;&lt; 6); if ( user_codepointer == 1114112 ) break; } else { temp_val9 = (temp_val8 &lt;&lt; 6) | sudoku[sudoku_index + 2] &amp; 0x3F; if ( expected_char &lt; 0xF0u ) { sudoku_index += 3LL; expected_char = (v43 &lt;&lt; 12) | temp_val9; if ( user_codepointer == 1114112 ) break; } else { expected_char = ((expected_char &amp; 7) &lt;&lt; 18) | (temp_val9 &lt;&lt; 6) | sudoku[sudoku_index + 3] &amp; 0x3Fu; if ( expected_char == 1114112 ) break; sudoku_index += 4LL; if ( user_codepointer == 1114112 ) break; } } } else { ++sudoku_index; if ( user_codepointer == 1114112 ) break; } if ( expected_char != 46 &amp;&amp; user_codepointer != expected_char ) { *&amp;stdin_handle[0] = aYouShouldNotCh; *(&amp;stdin_handle[0] + 1) = 32LL; *&amp;fmt_arg1 = stdin_handle; *(&amp;fmt_arg1 + 1) = &lt;&amp;T_as_core::fmt::Display&gt;::fmt; *buf = &amp;unk_7FF6BF7524E0; *&amp;buf[8] = 2LL; *&amp;buf[32] = 0LL; *&amp;buf[16] = &amp;fmt_arg1; *&amp;buf[24] = 1LL; result = std::io::stdio::_print(stdin_handle, 81LL, sudoku_index, buf); goto LABEL_73; } } sudoku::board::sudoku::Sudoku::from_str_line(stdin_handle, 81LL, alloc_result, buf, 81LL, expected_char); if ( buf[0] == 1 ) { *&amp;fmt_arg1 = *&amp;buf[4]; core::result::unwrap_failed( stdin_handle, 81, 43, &quot;called `Result::unwrap()` on an `Err` value&quot;, &amp;fmt_arg1, &amp;unk_7FF6BF752070); } board_data = buf[81]; stdin_handle[4] = *&amp;buf[65]; stdin_handle[3] = *&amp;buf[49]; stdin_handle[2] = *&amp;buf[33]; stdin_handle[1] = *&amp;buf[17]; stdin_handle[0] = *&amp;buf[1]; if ( sudoku::board::sudoku::Sudoku::is_solved(stdin_handle, 81LL, temp_arg1, stdin_handle) ) { *buf = &amp;off_7FF6BF752490; // &quot;Congratulation!\\n&quot; *&amp;buf[8] = 1LL; *&amp;buf[16] = 8LL; *&amp;buf[24] = 0LL; std::io::stdio::_print(stdin_handle, 81LL, temp_arg2, buf); fmt_arg4 = 0LL; fmt_arg3 = 0LL; fmt_arg2 = 0LL; fmt_arg1 = 0LL; fmt_arg6 = 0LL; fmt_arg5 = ::fmt_arg5; md5_ctx_prt = &amp;fmt_arg1; md5::consume(&amp;fmt_arg1, 81LL, alloc_result, &amp;fmt_arg1, 81LL); *&amp;buf[80] = fmt_arg6; *&amp;buf[64] = fmt_arg5; *&amp;buf[48] = fmt_arg4; *&amp;buf[32] = fmt_arg3; *&amp;buf[16] = fmt_arg2; *buf = fmt_arg1; md5::Context::finalize(&amp;fmt_arg1, 81LL, buf, md5_hash); *&amp;fmt_arg1 = md5_hash; *(&amp;fmt_arg1 + 1) = &lt;md5::Digest_as_core::fmt::LowerHex&gt;::fmt; *buf = &amp;YourFlagIs; // &quot;Your flag is moectf{&quot; *&amp;buf[8] = 2LL; *&amp;buf[32] = 0LL; *&amp;buf[16] = &amp;fmt_arg1; *&amp;buf[24] = 1LL; result = std::io::stdio::_print(&amp;fmt_arg1, 81LL, temp_arg3, buf); } else { *buf = &amp;TryAgain; // &quot;try again~\\n&quot; *&amp;buf[8] = 1LL; *&amp;buf[16] = 8LL; *&amp;buf[24] = 0LL; result = std::io::stdio::_print(stdin_handle, 81LL, temp_arg2, buf); } } else {LABEL_72: *buf = &amp;Invalid; // &quot;Invalid Solution.\\n&quot; *&amp;buf[8] = 1LL; *&amp;buf[16] = 8LL; *&amp;buf[24] = 0LL; result = std::io::stdio::_print(stdin_handle, trimmed_length, input_data, buf); }LABEL_73: if ( trimmed_length ) return __rustc::__rust_dealloc(md5_ctx_prt, trimmed_length, trimmed_length, alloc_result, 1LL); return result;} rust逆向的伪代码不好分析，但是作为数独游戏，只需要找到数独就可以了，可以shift+F12在字符串表窗口找到可疑的数据： 结合伪代码，可以分析出程序接受用户输入的已求解的数独后会进行检验，若数独正确且求解成功，会输出flag，flag是md5加密后的数独。所以直接利用程序得到flag即可。网上找一个数独求解工具求解：数独求解器 - 免费在线数独方案解题工具（建议不要直接把数独复制给AI求解，因为AI会乱改数据，笔者卡在求解这一步好久😅） IDA动态调试（直接运行程序输入正确数独貌似会闪退），把解出来的数独按提示的顺序输入，就可以得到flag： week4ezandroid 附件apk用JEB打开，发现逻辑主要是将输入的文本base64加密后进行比较 cyberchef一把梭 ezandroid.pro 附件apk用JEB打开，可以发现使用了一个从native层ezandroidpro库载入的函数check，由check判断输入是否正确 把apk解压，在IDA中打开lib/armeabi-v7a/libezandroidpro.so，在Exports界面找到Java_com_example_ezandroidpro_MainActivity_check函数，即apk载入的check函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899bool __fastcall Java_com_example_ezandroidpro_MainActivity_check(int JENV, int a2, int a3){ _BOOL4 ret; // r5 const char *flag; // r0 const char *src; // r4 size_t length; // r0 size_t n; // r5 char *dest; // r9 unsigned int v11; // r10 char *str; // r4 int n96; // r2 int v14; // r0 unsigned __int8 *v15; // r2 int v16; // r1 char *_str; // r3 void *s1_1; // r6 unsigned __int8 v20; // [sp+4h] [bp-44h] BYREF _BYTE v21[7]; // [sp+5h] [bp-43h] BYREF void *s1; // [sp+Ch] [bp-3Ch] _DWORD v23[2]; // [sp+10h] [bp-38h] BYREF void *key; // [sp+18h] [bp-30h] _DWORD v25[2]; // [sp+1Ch] [bp-2Ch] BYREF void *dest_1; // [sp+24h] [bp-24h] ret = 0; flag = (const char *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)JENV + 676))(JENV, a3, 0); if ( !flag ) return ret; src = flag; length = strlen(flag); if ( length &gt;= 0xFFFFFFF0 ) std::__basic_string_common&lt;true&gt;::__throw_length_error(v25); n = length; if ( length &gt;= 0xB ) { v11 = (length + 16) &amp; 0xFFFFFFF0; dest = (char *)operator new(v11); v25[1] = n; dest_1 = dest; v25[0] = v11 + 1; goto LABEL_7; } LOBYTE(v25[0]) = 2 * length; dest = (char *)v25 + 1; if ( length )LABEL_7: j_memcpy(dest, src, n); dest[n] = 0; (*(void (__fastcall **)(int, int, const char *))(*(_DWORD *)JENV + 680))(JENV, a3, src); key = (void *)operator new(0x20u); strcpy((char *)key, &quot;moectf2025!!!!!!&quot;); v23[1] = 16; v23[0] = 33; str = (char *)operator new(0x70u); strcpy(str, &quot;4EEB1EEF2914D79BFA8C5006332097ED2EF06C4A59CAE31C827A08D45CC649C0B971BF2EFBCB160E531A646DF7A6AC0B&quot;); sm4Encrypt((int)&amp;v20, (int)v25, (int)v23); n96 = *(_DWORD *)&amp;v21[3]; v14 = v20 &amp; 1; if ( !v14 ) n96 = v20 &gt;&gt; 1; if ( n96 == 96 ) { if ( v14 ) { s1_1 = s1; ret = memcmp(s1, str, 0x60u) == 0; goto LABEL_20; } v15 = v21; v16 = v20 &gt;&gt; 1; _str = str; do { ret = *v15 == (unsigned __int8)*_str; if ( *v15 != (unsigned __int8)*_str ) break; ++_str; ++v15; --v16; } while ( v16 ); } else { ret = 0; } if ( v14 ) { s1_1 = s1;LABEL_20: operator delete(s1_1); } operator delete(str); if ( LOBYTE(v23[0]) &lt;&lt; 31 ) operator delete(key); if ( LOBYTE(v25[0]) &lt;&lt; 31 ) operator delete(dest_1); return ret;} 可以看到，check函数使用了sm4加密，密钥可能是“moectf2025!!!!!!”，还需要知道加密模式。借助AI分析具体加密函数知道采用ECB加密模式，cyberchef一把梭： A simple program 附件程序main函数反编译出来大概是这样： 但是Str2这个像模像样的flag是假的，提交会显示错误。结合题目提示，flag应该藏在其他地方。 IDA看不出有什么套路在里面，但是在X32Dbg，strncmp是可以点进去的（在IDA中，strncmp是粉色的导入函数，点击函数没有详细内容），点进去会发现，里面还有一个strncmp 加上注释： 所以真正的检验逻辑在strncmp里，程序从chall.4D31A4取出真正的密文，然后把输入的flag进行异或处理再比较。在转储中跟随4D31A4可以获得密文： 解密脚本： 12345enc=[0x4E, 0x4C, 0x46, 0x40, 0x57, 0x45, 0x58, 0x7A, 0x13, 0x56, 0x7C, 0x73, 0x17, 0x50, 0x50, 0x66, 0x47, 0x02, 0x02, 0x5E]flag=&quot;&quot;for i in enc: flag+=chr(i^0x23)print(flag) week52048_master_re 附件程序是一个2048小游戏，通过方向键来操作数字整体移动。根据游戏窗口可以推测这也是一个GUI程序。 用IDA打开附件程序，shift+F12可以在字符串窗口看见一些蛛丝马迹（因为是MFC GUI程序，也可以直接找WinMain函数，然后再从中找出和flag检验有关的逻辑）： 跟踪flag.txt可以发现一个疑似的关键函数： 通过粗略分析可以推测程序从flag.txt里读取数据，然后进行检验。但是此处没有直接的和flag相关的提示，跟踪到上级函数看看。选中函数名按X查找交叉引用，跳转到上一级函数： 出题人根据可疑函数的返回值设置了提示，看来flag检验逻辑在此没错了。回到可疑函数，可以看到函数后半部分是对Block的检验，所以推测sub_401A81是一个加密函数。跟踪进去可以找到一个魔改xxtea函数和一个疑似数据格式转换的函数。这是优化后的样子： 到这里大概掌握了一些信息了。但还是要完整分析一下程序的整体逻辑，继续找上级函数，回溯到WinMain函数。下面是沿着正向调用逻辑的分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd){ MSG Msg; // [rsp+60h] [rbp-90h] BYREF WNDCLASSEXA v6; // [rsp+90h] [rbp-60h] BYREF memset(&amp;v6, 0, sizeof(v6)); v6.cbSize = 80; v6.lpfnWndProc = check_2048; // 游戏的检验逻辑 v6.hInstance = hInstance; v6.hCursor = LoadCursorA(0LL, 0x7F00); v6.hbrBackground = 5; v6.lpszClassName = &quot;WindowClass&quot;; v6.hIcon = LoadIconA(0LL, 0x7F00); v6.hIconSm = LoadIconA(0LL, 0x7F00); if ( RegisterClassExA(&amp;v6) ) { if ( CreateWindowExA( 0x200u, &quot;WindowClass&quot;, &quot;2048&quot;, 0x10CF0000u, 0x80000000, 0x80000000, 640, 480, 0LL, 0LL, hInstance, 0LL) ) { while ( GetMessageA(&amp;Msg, 0LL, 0, 0) &gt; 0 ) { TranslateMessage(&amp;Msg); DispatchMessageA(&amp;Msg); } return Msg.wParam; } else { MessageBoxA(0LL, &quot;Window Creation Failed!&quot;, &quot;Error!&quot;, 0x30u); return 0; } } else { MessageBoxA(0LL, &quot;Window Registration Failed!&quot;, &quot;Error!&quot;, 0x30u); return 0; }}//游戏检验函数LRESULT __fastcall check_2048(HWND hWnd, UINT n20, WPARAM wParam, LPARAM lParam){ unsigned int v4; // eax tagPAINTSTRUCT Paint; // [rsp+50h] [rbp-30h] BYREF struct tagRECT Rect; // [rsp+230h] [rbp+1B0h] BYREF HGDIOBJ h; // [rsp+248h] [rbp+1C8h] HDC hdcSrc; // [rsp+250h] [rbp+1D0h] HDC hdc; // [rsp+258h] [rbp+1D8h] LONG dwNewLong; // [rsp+264h] [rbp+1E4h] HMENU SystemMenu; // [rsp+268h] [rbp+1E8h] int i2; // [rsp+274h] [rbp+1F4h] int i1; // [rsp+278h] [rbp+1F8h] int nn; // [rsp+27Ch] [rbp+1FCh] int mm; // [rsp+280h] [rbp+200h] int kk; // [rsp+284h] [rbp+204h] int v18; // [rsp+288h] [rbp+208h] int jj; // [rsp+28Ch] [rbp+20Ch] int i14; // [rsp+290h] [rbp+210h] int i13; // [rsp+294h] [rbp+214h] int i12; // [rsp+298h] [rbp+218h] int i11; // [rsp+29Ch] [rbp+21Ch] int i10; // [rsp+2A0h] [rbp+220h] int v25; // [rsp+2A4h] [rbp+224h] int i9; // [rsp+2A8h] [rbp+228h] int i8; // [rsp+2ACh] [rbp+22Ch] int i7; // [rsp+2B0h] [rbp+230h] int i6; // [rsp+2B4h] [rbp+234h] int i5; // [rsp+2B8h] [rbp+238h] int i4; // [rsp+2BCh] [rbp+23Ch] int v32; // [rsp+2C0h] [rbp+240h] int i3; // [rsp+2C4h] [rbp+244h] int ii; // [rsp+2C8h] [rbp+248h] int n; // [rsp+2CCh] [rbp+24Ch] int m; // [rsp+2D0h] [rbp+250h] int k; // [rsp+2D4h] [rbp+254h] int j; // [rsp+2D8h] [rbp+258h] int v39; // [rsp+2DCh] [rbp+25Ch] int i; // [rsp+2E0h] [rbp+260h] char v41; // [rsp+2E7h] [rbp+267h] int i16; // [rsp+2E8h] [rbp+268h] int i15; // [rsp+2ECh] [rbp+26Ch] if ( n20 == 15 ) // 下面开始是一大串的检验操作 { hdc = BeginPaint(hWnd, &amp;Paint); hdcSrc = CreateCompatibleDC(hdc); GetClientRect(hWnd, &amp;Rect); h = CreateCompatibleBitmap(hdc, Rect.right, Rect.bottom); SelectObject(hdcSrc, h); sub_4022AF(hdcSrc); BitBlt(hdc, 0, 0, Rect.right, Rect.bottom, hdcSrc, 0, 0, 0xCC0020u); DeleteObject(h); DeleteDC(hdcSrc); EndPaint(hWnd, &amp;Paint); } else if ( n20 &gt; 0xF ) { //...此处省略 } else if ( n20 == 1 ) { SystemMenu = GetSystemMenu(hWnd, 0); dwNewLong = GetWindowLongA(hWnd, -16) &amp; 0xFFF8FFFF; SetWindowLongA(hWnd, -16, dwNewLong); SetWindowPos(hWnd, 0LL, 0, 0, 0, 0, 3u); ShowWindow(hWnd, 1); v4 = time64(0LL); srand(v4); hThread = CreateThread(0LL, 0LL, StartAddress, 0LL, 0, 0LL); CreateThread(0LL, 0LL, check_flag, 0LL, 0, 0LL);// 这里创建了线程，而flag的检验函数就在这个线程里 if ( sub_401DBF(&quot;layout.dat&quot;) ) { sub_4645D0(&amp;Paint, &quot;layout.dat&quot;, 8); for ( i15 = 1; i15 &lt;= 4; ++i15 ) { for ( i16 = 1; i16 &lt;= 4; ++i16 ) sub_453880(&amp;Paint, &amp;dword_4B6040[5 * i15 + i16]); } sub_453880(&amp;Paint, &amp;dword_4B60A4); sub_464580(&amp;Paint); if ( MessageBoxA(0LL, &quot;Continue?&quot;, &quot;E=hv&quot;, 4u) == 7 ) { memset(dword_4B6040, 0, sizeof(dword_4B6040)); check(); check(); InvalidateRect(hWnd, 0LL, 1); dword_4B60A4 = 0; } sub_464C70(&amp;Paint); } else { check(); check(); dword_4B60A4 = 0; } } else { if ( n20 != 2 ) return DefWindowProcA(hWnd, n20, wParam, lParam); TerminateThread(hThread, 0); PostQuitMessage(0); } return 0LL;}//flag的检验函数__int64 __fastcall check_flag(LPVOID lpThreadParameter){ if ( !sub_401DBF(&quot;flag.txt&quot;) ) return 0LL; if ( get_check_flag() ) // 获取并检验flag { MessageBoxA( hWnd, &quot;It seems you've uncovered some clues, but they're not enough to unlock the deepest secrets.&quot;, &quot;sandtea&quot;, 0x30u); return 1LL; } else { MessageBoxA(hWnd, &quot;You have found the final secret of 2048! - sandtea&quot;, &quot;Congratulations&quot;, 0x40u); return 0LL; }}//获取并检验flag的函数__int64 get_check_flag(){ size_t length; // rax char flag[136]; // [rsp+20h] [rbp-D0h] BYREF unsigned __int64 block_num; // [rsp+A8h] [rbp-48h] BYREF char key[32]; // [rsp+B0h] [rbp-40h] BYREF void *Block; // [rsp+D0h] [rbp-20h] FILE *FILE; // [rsp+D8h] [rbp-18h] unsigned __int64 i; // [rsp+E0h] [rbp-10h] unsigned int v8; // [rsp+ECh] [rbp-4h] FILE = fopen(&quot;flag.txt&quot;, &quot;r&quot;); file_read(FILE, &quot;%100s&quot;, flag); fclose(FILE); if ( strlen(flag) != 37 ) return 1LL; strcpy(key, &quot;2048master2048ma&quot;); length = strlen(flag); Block = encrypt(flag, length, key, &amp;block_num); if ( Block ) { v8 = 0; for ( i = 0LL; i &lt; block_num; ++i ) { if ( *(Block + i) != byte_495280[i] ) v8 = 1; } free(Block); return v8; } else { sub_428D00(&quot;Encryption failed\\n&quot;); return 1LL; }}//加密函数__int64 __fastcall encrypt(__int64 flag, unsigned __int64 length, _QWORD *key, __int64 block_num){ __int64 v5; // rdx _QWORD Key[3]; // [rsp+20h] [rbp-30h] BYREF unsigned __int64 word_num; // [rsp+38h] [rbp-18h] BYREF _WORD *block; // [rsp+40h] [rbp-10h] void *mem; // [rsp+48h] [rbp-8h] mem = new_mem(flag, length, &amp;word_num); // 根据传入的flag申请了一块内存，word_num是申请的word个数 if ( !mem ) return 0LL; v5 = key[1]; // 这是传入的密钥 Key[0] = *key; Key[1] = v5; modifiedXXTea(mem, word_num, Key); // xxtea加密 block = make_blocks(mem, word_num, block_num);// 对加密后的数据进行一些转换，以便后续和给定的数据进行校验 free(mem); return block;}//申请内存的函数_DWORD *__fastcall new_mem(__int64 flag, unsigned __int64 length, unsigned __int64 *word_num){ _DWORD *mem; // [rsp+28h] [rbp-18h] unsigned __int64 Word_num; // [rsp+30h] [rbp-10h] unsigned __int64 i; // [rsp+38h] [rbp-8h] Word_num = (length + 3) &gt;&gt; 2; // 10 mem = calloc(Word_num, 4uLL); // 10*4字节的内存空间 if ( !mem ) return 0LL; for ( i = 0LL; i &lt; length; ++i ) mem[i &gt;&gt; 2] |= *(flag + i) &lt;&lt; (8 * (i &amp; 3)); *word_num = Word_num; return mem;}//魔改xxtea函数bool __fastcall modifiedXXTea(unsigned int *block, int word_num, __int64 key){ unsigned int *p1; // rax unsigned int *last_one1; // rax bool result; // al unsigned int *v6; // rax int v7; // [rsp+8h] [rbp-18h] unsigned int v8; // [rsp+8h] [rbp-18h] int round; // [rsp+Ch] [rbp-14h] int v10; // [rsp+Ch] [rbp-14h] unsigned int j; // [rsp+10h] [rbp-10h] int i; // [rsp+10h] [rbp-10h] unsigned int delta; // [rsp+14h] [rbp-Ch] unsigned int delta1; // [rsp+14h] [rbp-Ch] unsigned int last_one; // [rsp+18h] [rbp-8h] unsigned int v16; // [rsp+18h] [rbp-8h] unsigned int v17; // [rsp+18h] [rbp-8h] unsigned int p2; // [rsp+1Ch] [rbp-4h] unsigned int v19; // [rsp+1Ch] [rbp-4h] int v20; // [rsp+38h] [rbp+18h] if ( word_num &lt;= 1 ) { if ( word_num &lt; -1 ) { v20 = -word_num; v10 = 52 / -word_num + 6; delta1 = 0x3E9779B9 * v10; v19 = *block; do { v8 = (delta1 &gt;&gt; 2) &amp; 3; for ( i = v20 - 1; i; --i ) { v16 = block[i - 1]; v6 = &amp;block[i]; *v6 -= (((4 * v19) ^ (v16 &gt;&gt; 5)) + ((v19 &gt;&gt; 3) ^ (16 * v16))) ^ ((v19 ^ delta1) + (v16 ^ *(4LL * (v8 ^ i &amp; 3) + key))); v19 = *v6; } v17 = block[v20 - 1]; *block -= (((4 * v19) ^ (v17 &gt;&gt; 5)) + ((v19 &gt;&gt; 3) ^ (16 * v17))) ^ ((v19 ^ delta1) + (v17 ^ *(4LL * v8 + key))); v19 = *block; delta1 -= 0x3E9779B9; result = --v10 != 0; } while ( v10 ); } } else { round = 52 / word_num + 6; delta = 0; last_one = block[word_num - 1]; do { delta += 0x3E9779B9; v7 = (delta &gt;&gt; 2) &amp; 3; for ( j = 0; word_num - 1 &gt; j; ++j ) { p2 = block[j + 1]; p1 = &amp;block[j]; *p1 += (((4 * p2) ^ (last_one &gt;&gt; 5)) + ((p2 &gt;&gt; 3) ^ (16 * last_one))) ^ ((p2 ^ delta) + (last_one ^ *(4LL * (v7 ^ j &amp; 3) + key))); last_one = *p1; } last_one1 = &amp;block[word_num - 1]; *last_one1 += (((4 * *block) ^ (last_one &gt;&gt; 5)) + ((*block &gt;&gt; 3) ^ (16 * last_one))) ^ ((*block ^ delta) + (last_one ^ *(4LL * (v7 ^ j &amp; 3) + key))); last_one = *last_one1; result = --round != 0; } while ( round ); } return result;}//数据格式转换函数_WORD *__fastcall make_blocks(__int64 mem, unsigned __int64 num_word, size_t *block_num){ _WORD *block; // [rsp+20h] [rbp-10h] unsigned __int64 i; // [rsp+28h] [rbp-8h] *block_num = 4 * num_word; block = malloc(*block_num); if ( !block ) return 0LL; for ( i = 0LL; i &lt; num_word; ++i ) { block[2 * i] = *(4 * i + mem); LOBYTE(block[2 * i + 1]) = BYTE2(*(4 * i + mem)); HIBYTE(block[2 * i + 1]) = HIBYTE(*(4 * i + mem)); } return block;} 所以要解出flag，就需要逆向这个xxtea加密。把这个任务交给AI，可以得到解密脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;// 加密数据（make_blocks的输出）uint8_t encrypted_data[40] = { 0x35, 0x79, 0x77, 0xCC, 0x1B, 0x13, 0x41, 0x34, 0xF9, 0xFF, 0x9F, 0x91, 0xFF, 0x5B, 0x94, 0x78, 0x86, 0x2A, 0xAF, 0xAE, 0xD7, 0x9E, 0x31, 0x4D, 0x7A, 0xC4, 0xA5, 0x51, 0xD1, 0xD9, 0x6E, 0x44, 0x18, 0x52, 0x86, 0x1B, 0x42, 0x8A, 0xC9, 0x63};// 密钥char key[17] = &quot;2048master2048ma&quot;;// 逆make_blocks：将_WORD数组转换回DWORD数组uint32_t* unmake_blocks(uint8_t* blocks, size_t block_bytes, size_t* num_dwords) { *num_dwords = block_bytes / 4; uint32_t* dwords = (uint32_t*)malloc(*num_dwords * 4); for (size_t i = 0; i &lt; *num_dwords; i++) { // 将两个WORD合并为一个DWORD uint16_t low_word = *(uint16_t*)&amp;blocks[4 * i]; uint16_t high_word = *(uint16_t*)&amp;blocks[4 * i + 2]; dwords[i] = (high_word &lt;&lt; 16) | low_word; } return dwords;}// 逆modifiedXXTea解密void decrypt_tea(uint32_t* data, int num_dwords, uint32_t* tea_key) { if (num_dwords &lt;= 1) return; int rounds = 52 / num_dwords + 6; uint32_t delta = 0x3E9779B9 * rounds; // 1050114489 uint32_t sum = delta; uint32_t y = data[0]; for (int i = 0; i &lt; rounds; i++) { uint32_t e = (sum &gt;&gt; 2) &amp; 3; for (int j = num_dwords - 1; j &gt; 0; j--) { uint32_t z = data[j - 1]; data[j] -= (((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (tea_key[(j ^ e) &amp; 3] ^ z)); y = data[j]; } uint32_t z = data[num_dwords - 1]; data[0] -= (((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (tea_key[e] ^ z)); y = data[0]; sum -= 0x3E9779B9; }}// 从DWORD数组提取字符串char* extract_string(uint32_t* dwords, size_t num_dwords, size_t original_len) { char* str =(char*) malloc(original_len + 1); memset(str, 0, original_len + 1); for (size_t i = 0; i &lt; original_len; i++) { uint32_t dword = dwords[i &gt;&gt; 2]; str[i] = (dword &gt;&gt; (8 * (i &amp; 3))) &amp; 0xFF; } return str;}int main() { // 步骤1: 逆make_blocks size_t num_dwords; uint32_t* tea_encrypted = unmake_blocks(encrypted_data, 40, &amp;num_dwords); printf(&quot;After unmake_blocks (%zu DWORDs):\\n&quot;, num_dwords); for (size_t i = 0; i &lt; num_dwords; i++) { printf(&quot;0x%08X &quot;, tea_encrypted[i]); } printf(&quot;\\n\\n&quot;); // 步骤2: 准备TEA密钥（将字符串转换为4个32位整数） uint32_t tea_key[4]; memcpy(tea_key, key, 16); printf(&quot;TEA Key:\\n&quot;); for (int i = 0; i &lt; 4; i++) { printf(&quot;0x%08X &quot;, tea_key[i]); } printf(&quot;\\n\\n&quot;); // 步骤3: 逆modifiedXXTea解密 decrypt_tea(tea_encrypted, num_dwords, tea_key); printf(&quot;After TEA decryption:\\n&quot;); for (size_t i = 0; i &lt; num_dwords; i++) { printf(&quot;0x%08X &quot;, tea_encrypted[i]); } printf(&quot;\\n\\n&quot;); // 步骤4: 提取flag字符串（原始长度37字节） char* flag = extract_string(tea_encrypted, num_dwords, 37); printf(&quot;Decrypted flag: %s\\n&quot;, flag); // 清理 free(tea_encrypted); free(flag); return 0;}","link":"/2025/10/12/Moectf2025ReverseWriteUp/"},{"title":"周记","text":"简单记录每周收获 week1 (2025.3.4-2025.3.9) 看到群友讲到周报，灵光一闪觉得可以写写周记来记录自己的学习，也当作一种督促 这周主要学习李承远老师的《逆向工程核心原理》（去年12月图书馆借的，这周才正式开始看😓） 主要学习了动态调试的基础技能。有： 调试器的基础操作，查找目标代码的方法（干找，字符串检索，下断点，API检索及下断点） 打补丁patch修改输出的字符串（直接修改或者导向修改的NULL填充区域）并导出新的可执行文件 字节序、寄存器基础 栈、栈帧 函数调用约定（cdecl（调用者处理栈）、stdcall（被调用者处理栈）、fastcall（同stdcall，但是结合了栈和寄存器）） week2 (2025.3.10-2025.3.16) 这周主要学习了PE文件结构的内容，同步更新了学习笔记 ，主要是PE文件的基本组成介绍，理论知识 周末本想接着下一章的学习，但是摆大烂了，甚至PE笔记还没写完 下周末就是NCTF了，一点准备没有，要炸掉了 week3 (2025.3.17-2025.3.23) 这周过得又忙又不知道在忙什么，PE文件结构最后的EAT部分没看懂，(T_T)，笔记还没补完 NCTF爆零了，编码能力是硬伤，知识更是伤上加伤 (T_T) 好了，真是糟糕的一周 week4 (2025.3.24-2025.3.30) offline一周 week5 (2025.3.31-2025.4.6) 想了想，发现自己一直存在一个错误，就是为了笔记而做笔记，纯粹的是记录；但是好像以总结或者说复述的方式来做笔记才比较有用 这周碰上清明了，有个三天假。虽然但是，依旧是没怎么学新东西 但是至少是做了点什么。周日把PE文件格式收尾了（还是有点难度的，因为回头看了前面做的笔记，发现对IAT和EAT的认识有点不对劲，重新梳理了一遍，删删改改）。学聪明了，这次是看完书完整地把例子先走了一遍再做的笔记 这周在咸鱼2元淘到了一包课，后面发现里面有一套课体系挺完整的，也是有课跟了 还有就是尝试了自己写python解密脚本，发现没体系学过一遍真不能硬上 week6 (2025.4.7-2025.4.13) 这周找了个短一些的python视频，跟着过了一遍，然后试着做题写脚本，您猜怎么着，还是不太会🤡 解密实在是太吃操作了，细细一想，好像解密这玩意更吃数学，一个取模逆向DS直接上公式，我还在循环爆破被除数🤡 不得不拿出四字真言：菜就多练。所以，这周就试着刷题来了 节奏还是慢了点，唉 week7 (2025.4.14-2025.4.20) emmm怎么说，这周前面几天倒是抽时间刷题了，但是一到周末，明显感到懒了 周三花了一个下午搞明白重定位表，笔记写了，但是切入点好像不是很对。这次的笔记，因为参考了DS给的辅助讲解，所以跟前面的有点不一样。感觉用形象的例子来类比以及从设计者角度描述细节，更有利于后期复习再理解 还是感觉效率上不来🤔，我在想要不然先跟课走，不懂的地方再看书，会不会学的清楚一点，省的老啃一处 本来打算周末来个脱壳练习的，鸽了（；´д｀）ゞ week8 (2025.4.21-2025.4.27) 这几天图床崩了，图片上传不了，之前的图在博客里也有点显示不出来，找了好久没找到问题在哪里，只能传到本地和其他文件一起打包传github了 五一调休使我本就短暂的周末更加短暂（虽然目前为止周末还没有被我真正利用过），这周拿得出手的就只是一道题目 em…实际上这周花了不少时间搞脱壳练习的环境。买的课里头老师说用vs2008练习，但是该死的虚拟机没联网得自己安装netframework，这就花了不少时间，以及灵机一动把环境搭在win11上了，这又花了一点时间。还有一点时间尝试用自己写的程序加壳脱壳，但是没折腾成功。 还有，我有点怀疑这个老师的成分了，一口一个抛砖引玉，一口一个自己看（我要是自己会学还看课干什么）🫠。但是找不到比他的课更完整的win逆向资源了😔 week9 (2025.4.28-2025.5.4) 这周碰上了实验周和五一假期，看似空闲时间很多，但实际上并非如此（借口 CS啊，三天速通数学实验，还要写老厚一本的实验报告，甚至报告还包括两篇论文，离谱了🫠 好的，看来这周依旧是没什么学习收获的一周。除了单开了一个IDApro的学习笔记（四处碰壁只能学学工具的使用了） week10 (2025.5.5-2025.5.11) 这周折腾电装实习和数学实验，还要复习大物和高数，忙死了，唉 week11 (2025.5.12-2025.5.18) 诶，浅摆一周 week12 (2025.5.19-2025.5.25) 快期末月了啊，哎呀，一学期又要过去了 开始有点考试前的紧张感了，这周主要拿来搞学业了，大物、高数、电工模电还有六级多手抓🙃 诶，但是优化了一下博客的界面，折腾了快有三天时间。主要就是给主页改成了分类卡片，下一级才是文章，这样子结构更清晰一点。还有一些小地方的美化，以及阅读次数统计的问题（从leancloud国内版到不蒜子到leancloud国际版又回到leancloud国内版…哇，看来我和DS老师的协调能力还不是很好，毕竟光这一项就要了差不多1天时间🙃头都大了） 本来打算周末把没跟上的课业补上，但是优化博客就占了周六一个上午，周六一个下午搞那个C++慕课（不当人啊，题目让直接复制的输出实现代码和输出要求一模两样），但是我还有高数大物特别是模电和六级以及还有个电装实习报告和物理实验报告，压力都给到周日，可想而知 还有一件事，这周逮空看了看hello算法（就是这个：https://www.hello-algo.com/chapter_hello_algo/ ，上学期囤下来的资源）最近刚好买的课里头讲C和C++的时候提到了数据结构，但是实在找不到时间看视频，就只能看看书了。哇，U1S1是真优质资料啊。回头看看再加一个数据结构与算法的分类，反正下学期好像也要学了 其实还有点事情，写这个博客的初心其实不是什么记录收获，而是因为我没有找到可以学习效仿的对象，看大佬的博客都是更新知识，很少有人提到为什么会想到去学这些知识，就是，没人会告诉你下一步该干什么，知识那么多却又找不到学习的方向，就是这种感觉。所以想记录记录自己的学习经历，方便梳理学习路线，也希望多少可以给将来像我一样迷茫的人一些指引。 其实开始学习的时候，我会时不时去看看同级的大佬的博客，看到他们更新的都是我没有听说过的知识，看着他们变得越来越专业越来越厉害，长久下来心里很不是滋味。高中时候那种无力感就又出现了。后来我就隐约觉得不对劲，这不就把大学又过成高中了吗？“比较的终点是自卑，专注的终点是自由”，想想当初想学信安不就是因为喜欢吗（虽然那时候确实不知道具体得学什么），为什么要和别人比呢？高中的时候我总是刻意不融入比较的氛围，而现在没有了那样厚重的学习环境，我却不自觉开始比较起来了，唉😔所以这些天其实一直在调整自己的心态，好在现在我感觉慢慢地不再频繁站在外界去审视自己了，开始觉得每天能看见阳光、能够在晚自习上下课的路上边听歌边走路、能够实现引体向上拉0个到拉6个（尽管是在有弹力带辅助的情况下、能够在社团的宣讲活动上承担一部分发言的责任……这些都让我的生活变得越来越美好。这可能就是知足常乐的感觉吧，反正活得更开心了，也更有行动的能量了，也挺好 今天的字数有点超标了哈哈😄但是不管了 接下来一个月多不知道会不会还有机会更新点知识笔记，但是希望暑假可以好好学学吧（求求我自己了 既然提到了学习路线，要不然这里梳理一段吧，其实有些东西没记上来。刚开始是从《逆向工程核心原理》开始学的，但是学了快一个月感觉效率也不行啊，后面开始找课，找到了一个全路线的课（目录里是包含了渗透测试和逆向免杀的）但是感觉逆向那部分老师有点混啊，上课就展示笔记 ，说话也含含糊糊的，还时不时来句主要是抛砖引玉，就感觉这样下来也学得迷迷糊糊的，所以又去找新的课。现在是找到了另外两套，一套是windows内核安全，一套是红队免杀（两套课同一家机构的，jayx），这个体系感觉也很清晰，老师讲课（至少看了几节课下来）倒也清楚，实践为主。所以现在确定下来是跟着最新的两套学。后面可能会考虑改改之前记的笔记。 啊对了，还得狡辩一下。我发现week2开始就不是记录收获了，像是报备干了什么😄其实也没什么写的，因为还在摸索。 week13 (2025.5.26-2025.6.1) 这周本来是试着把博客部署到vercel上方便国内访问的（DeepSeek说可以的），但是没折腾明白，所以本来没打算写什么的。结果，周日晚上11点多打开博客文件夹，发现有点不对劲，一访问，博客崩了😅 千错万错就不该错在什么都不懂还跟着DeepSeek走，哇，真的，难以描述这种感觉，光这篇周记就有77天了啊，😅 这段话其实是6.2写的，周日晚上修博客修到1点，尝试修复但是行不通😅 哇，这个人工智能，它教我用rm rf，虽然不是windows的指令，但是它能在教程里用上这样的指令，哇，真的，真是这个👍。我真的，哇，要无语死了 6.2就折腾一天的博客，把原来的博客废掉了，重构了一个。哇，一搜教程，和当初刚开始搞博客时看到的完全不一样了，下下来的NexT还是新版的，配置变了不是一点，哇😅 吃一堑长一智了，以后找教程不先搜别人写的直接问AI我就是这个👍 week14 (2025.6.2-2025.6.8) OK，这周主要任务就是重新搭了一个博客。博客建了半年了，都忘了怎么建起来的了，重搭去找教程，搜出来的结果和印象里半年前的还不一样，迭代速率真快啊 好在旧的博客没有全毁，在残存的next文件里找到了一些还能抄的配置 才半年NexT都更新到8.23了，评论系统和访客系统变了不少，老配置用不上只能换新的配置了 完了都没什么可以写的了 预计接下来几周就不会有什么内容了，马上就是期末周了。唉，大大小小的作业报告考试又来了🫠 week15,16,17 (2025.6.9-2025.6.29) 期末月断更 week18 (2025.6.30-2025.7.6) OK，也是考完试了。回家两天也是闲里偷忙地看了一点课 接下来看看能不能持续更个几十天，我已经“计划”好了一些要更的内容了，能不能更成就看我自己了（ week19 (2025.7.7-2025.7.13) 这周开始学习基础一点的知识，主要是汇编。下周应该是程序逆向基础的东西了。 笔记有点乱。这周主要围绕汇编，学习了不同架构不同模式下的汇编的基础知识，包括最基本的寄存器、汇编指令、函数的汇编形式、栈帧、不同架构模式的汇编差异等。整体而言其实不是很繁杂的东西，内容也不多，所以说其实这周还是处于想起来该学了的时候才学的状态。看了看其他的囤起来的资料，有一说一，开学后还真不一定可以有连续的时间学，这样子没有先起个体系感觉还是很难真正学懂。 week20 (2025.7.14-2025.7.20) 一言难尽属于是，总而言之这周没怎么集中精力去给第一部分的汇编学习收尾 还有结构体、类什么的还没有尝试，为了降低难度没有引入C++复杂的语法，但是总感觉哪里有点不对劲 这样下去不是很ok啊(ˉ▽ˉ；)… week21 (2025.7.21-2025.7.27) 摆烂一周🤪🤪 其实这一周我没写周记，甚至把它隐藏了。week22学了几天良心过不去又恢复文章了(～￣▽￣)～ week22 (2025.7.28-2025.8.3) 这周收获颇丰啊，脱壳这一块卡了半年多了应该有，也是终于走到逆向真正有魅力的地方了，脱壳、花指令、反调试都学上了，虽然偏理论，但是至少有点见识了 美中不足的是，代码编译着编译着突然冒出了一个调用约定冲突（x86环境）🫠花指令之前都没发现这个问题，真是奇了怪了🫠重装一遍VS甚至还是有这个问题 这周找校队师傅沟通了一下，好像参加考核得跟着新一轮招新时间线来，不然要有拿得出手的实力才可以打破人家的招新计划🫠🫠 week23 (2025.8.4-2025.8.10) 上周末开始想着给博客换个主题（这个主题感觉被我搞得有点老了），一如既往的遭罪啊🫠这周本来想找机会把要换的主题准备好，但是，一折腾就是半天🫠 x2c开始招新了，唉，还没准备好🫠 本来这周到OLLVM了，但是尝试后发现自己写的程序OLLVM没有效果，不知道是逻辑太简单还是IDA太强大了还是什么，另外解法还有牵扯到angr的，索性深的就往后延延了，先把知识面拓开，安卓还没看呢，py还有其它语言的逆向也没怎么接触过呢🫠 怎么感觉状态起起落落的😅 week24 (2025.8.11-2025.8.17) 这周开始赶进度，学了点安卓逆向基础，然后投了简历。也算是见识到了招新考核了。感谢师傅手下留情，也是终于被收留了🫡。 然后就是打moe，感觉比0xGame还上了点难度，第一周就有upx的题了，还有C++的。顺道打了LILCTF，做出了一题😋但是其他题没思路了（加上准备科目一🫠，就没往下做，后面再学学再复现😋 考虑到Win逆向还没更完，所以安卓这部分就没有写笔记了，回头再熟悉熟悉再补 week25 (2025.8.18-2025.8.24) moe上强度了，但是第二周的题还没写完 这周摆烂了 week26 (2025.8.25-2025.8.31) 这周主要还是研究moe的题，没有学什么新知识。","link":"/2025/06/02/%E5%91%A8%E8%AE%B0/"},{"title":"week31-week34","text":"2025年10月篇 week31 (2025.9.29-2025.10.5) 这周碰上国庆假期，趁着假期狠狠研究moectf的upx_revenge。花了两天时间琢磨出了.rsrc段应该有问题（之前不知道哪里找的工具给修复到程序能运行但是闪退了，后面拿正常加壳程序对比一下不同的地方在.rsrc段），然后把.rsrc段的ResourceDirectoryTable给修复的差不多了，剩一个Data一直对不上。没招了去找出题人交流，结果发现是upx特征段的问题🫠一个月了终于解出这道题了😭太好了，终于是ak过的人了😭 0xGame2025也是开打了，靠新生赛攒经验这一块( 想着接下来朝逆向开发这一块学学，发现这一类笔记应该归为开发而不是逆向🤔所以又开了一个新分类。 哈基米的，老是感觉自己懂得太少了，但是又不知道从哪里开始学这些知识😭 week32 (2025.10.6-2025.10.12) 这周好像没什么可以写的🫥一半放假一半上课的，有点割裂感 0xGameweek1和Moectf的WriteUP也是放上了。这周主要在做0xGame还有?CTF的题，周末有个羊城杯可以打，但是国庆玩过头了没报上名🫥还有个领航杯来着，这个截止的更早，9.29截止的，没注意看时间也错过了🫠 好想莫名其妙的哈几下气🫥 week33 (2025.10.13-2025.10.19) 这周还是主要做0xGame和?CTF的题。目前两个比赛week1week2的题目是都做出来了，但是借用了不属于自己的力量( 加密算法逆向和脚本这块还是得练啊🫠 周末打了强网杯，拼尽全力无法战胜，只做出了一道Re简单题，脚本还是AI梭的🫠 week34 (2025.10.20-2025.10.26) 这周掉状态了。0xGameweek3上难度了，差点没做完（Calamaity_Fortne因为数据提取错误没及时解出来😭），week4更是有点魔鬼（题目都好抽象 ?CTFweek3开始没打了，人有点乱了，WP没有及时写积了好多（0xGameweek3和?CTFweek1、2），加上赛题难度开始上来了，所以实在忙不过来，更别说还有学业（怎么平衡啊😭 😭😭🫠🫠🫥🫥","link":"/2025/10/05/week31-week34/"},{"title":"记一次blog优化","text":"Hexo+NexT博客的小优化 (注：此篇记录的是笔者原来崩溃的博客的优化，是旧版NexT优化) 这几天突然产生一个想法：博客主页改成分类的样式会不会更好看一点，主页是主题集合，每个主题里面才是相关的文章 心动不如行动，直接开干！ 首页分类卡片实现 这部分其实花了不少时间，因为没有具体学过Hexo+NexT的结构，好在有Deepseek老师的帮助 修改的部分主要在themes/next/layout/index.swig，下面直接贴代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162{% extends '_layout.swig' %}{% import '_macro/sidebar.swig' as sidebar_template with context %}{% block title %}{{ title }}{%- if theme.index_with_subtitle and subtitle %} - {{ subtitle }}{%- endif %}{% endblock %}{% block class %}index categories-page{% endblock %}{% block content %}{# 这部分是实现category卡片，最后面还有没category的文章的处理，因为我严格了每篇文章有category，就没管画面如何了 #}{% if site.categories.length &gt; 0 %} &lt;div class=&quot;category-cards-container&quot;&gt; {% for cat in site.categories.toArray() %} &lt;div class=&quot;category-card&quot;&gt; &lt;div class=&quot;category-header&quot;&gt; &lt;h2 class=&quot;category-name&quot;&gt;{{ cat.name }}&lt;/h2&gt; &lt;span class=&quot;post-count&quot;&gt;{{ cat.posts.length }}篇文章&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; {# 这一部分实现卡片显示包含的文章的标题，数量可以改下面的limit()的数字 #} &lt;div class=&quot;recent-posts-list&quot;&gt; {% for post in cat.posts.sort('date', -1).limit(3).toArray() %} &lt;div class=&quot;recent-post-item&quot;&gt; &lt;a href=&quot;{{ url_for(post.path) }}&quot; class=&quot;post-title&quot; title=&quot;{{ post.title }}&quot;&gt; {{ post.title | truncate(18) }} &lt;/a&gt; &lt;span class=&quot;post-date&quot;&gt; {% if post.updated %} {{ post.updated.format('MM/DD') }} {% else %} {{ post.date.format('MM/DD') }} {% endif %} &lt;/span&gt; &lt;/div&gt; {% endfor %} &lt;div class=&quot;more-posts-wrapper&quot;&gt; &lt;a href=&quot;{{ url_for('/categories/' + cat.name + '/') }}&quot; class=&quot;more-posts-button&quot;&gt; 更多文章 → &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; {% endfor %} &lt;/div&gt;{% else %} &lt;div class=&quot;no-categories-notice&quot;&gt; &lt;p&gt;暂无分类数据，请为文章添加分类&lt;/p&gt; &lt;/div&gt;{% endif %}{% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} 还有source/_data/styles.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/* 分类卡片样式 - 安全追加 */.category-cards-container { margin: 40px auto; max-width: 1200px; padding: 0 20px; .category-card { background: rgba(255,255,255,0.85); /* 半透明白色，与你的opacity 0.85协调 */ border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.1); margin-bottom: 25px; padding: 25px; transition: all 0.3s ease; backdrop-filter: blur(2px); /* 毛玻璃效果增强背景融合 */ border: 1px solid rgba(255,255,255,0.3); /* 柔和边框 */ &amp;:hover { transform: translateY(-5px); box-shadow: 0 5px 25px rgba(0,0,0,0.15); } .category-name { color: #2c3e50; font-size: 1.4em; margin: 0 0 8px 0; font-weight: 600; } .post-count { color: #7f8c8d; font-size: 0.9em; display: block; } }}/* 这部分是我自己用的背景图的设置 */body { background-image: url(/images/background.jpg); background-repeat: no-repeat; background-attachment: fixed; background-size: 100% 100%; opacity: 0.85;}/* ======================== *//* 分类卡片内的文章列表样式 *//* ======================== */.category-card { position: relative; /* 为毛玻璃效果提供定位上下文 */ .category-header { margin-bottom: 15px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.08); } .recent-posts-list { margin-top: 10px; .recent-post-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; transition: all 0.2s ease; &amp;:hover { transform: translateX(3px); } .post-title { color: #34495e; font-size: 0.95em; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; &amp;:hover { color: #3498db; text-decoration: underline; } } .post-date { color: #95a5a6; font-size: 0.8em; font-family: 'Arial', sans-serif; flex-shrink: 0; } } } * { border-bottom: none !important; box-shadow: none !important; } .category-header, .recent-post-item, .recent-posts-list { border: none !important; border-bottom: none !important; }}/* 更多文章按钮样式 */.more-posts-wrapper { text-align: left; margin-top: 12px; padding-top: 10px; .more-posts-button { display: inline-block; color:rgb(72, 168, 241); font-size: 0.9em; padding: 6px 12px; border-radius: 4px; transition: all 0.3s ease; background: rgba(52, 152, 219, 0.1); &amp;:hover { background: rgba(52, 152, 219, 0.2); transform: translateX(3px); } &amp;:hover::after { margin-left: 8px; } }}/* 响应式调整 */@media (max-width: 767px) { .category-card { padding: 18px; .recent-post-item { flex-direction: column; align-items: flex-start; .post-date { margin-top: 3px; align-self: flex-end; } } }} 效果： 点击更多文章后的文章列表实现 这部分主要基于原来的Index.swig，因为我觉得原来的风格就挺简洁好看的 找到themes/next/layout/category.swig，改成： 1234567891011121314151617181920212223242526{% extends '_layout.swig' %}{% import '_macro/sidebar.swig' as sidebar_template with context %}{% block title %} {{ page.category }} | {{ __('title.category') }} | {{ config.title }} {%- if theme.index_with_subtitle and config.subtitle %} - {{ config.subtitle }}{%- endif %}{% endblock %}{% block class %}category posts-expand{% endblock %}{% block content %} &lt;div class=&quot;category-title&quot; style=&quot;text-align: center; margin: 30px 0;&quot;&gt;//这里把分类名称置中了 &lt;h1&gt;{{ page.category }}&lt;/h1&gt; &lt;/div&gt; {%- for post in page.posts.toArray() %} {{ partial('_macro/post.swig', {post: post, is_index: true}) }} {%- endfor %} {% include '_partials/pagination.swig' %}{% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} 效果： 删除文章侧边栏目录难看的下划线 在themes/next/layout/_partials/head.swig最后加上： 1234567891011121314151617181920&lt;!-- 强制移除目录下划线 --&gt;&lt;style&gt; /* 覆盖所有可能的目录容器 */ [class*=&quot;toc&quot;] .nav-item a, [class*=&quot;TOC&quot;] .nav-item a, .active &gt; a, .active-current &gt; a { border-bottom: none !important; text-decoration: none !important; box-shadow: none !important; } /* 覆盖伪元素下划线 */ [class*=&quot;toc&quot;] a::after, [class*=&quot;TOC&quot;] a::after { display: none !important; }&lt;/style&gt; 效果： 删除文末标签文字前的“#” 先说文件：themes/next/layout/_macro/post.swig 这个问题，网上找到的解决方法都是删掉11行的“#” 123456789101112//这是原来的代码，可以ctrl+F搜post-footer&lt;footer class=&quot;post-footer&quot;&gt; {%- if post.tags and post.tags.length %} {%- if theme.tag_icon %} {%- set tag_indicate = '&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;' %} {% else %} {%- set tag_indicate = '#' %} {%- endif %} &lt;div class=&quot;post-tags&quot;&gt; {%- for tag in post.tags.toArray() %} &lt;a href=&quot;{{ url_for(tag.path) }}&quot; rel=&quot;tag&quot;&gt;#&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;{{ tag_indicate }} {{ tag.name }}&lt;/a&gt; {%- endfor %} 但是删除后发现“#”还在。把代码给DS看了下，发现第7行把tag_indicate设成了“#”，删掉这个就可以了 效果： 测试时阅读文章不计数 2025.6.2 注：在NexT8后的版本，valine不被支持了 博客搭起来后一直有个问题，就是自己看自己的博客文章会被计数，最开始是用ublock屏蔽统计网站来实现，但是这两天测试了一下发现这个方法用手机访问也不会计数，这不就意味着统计功能瘫痪了吗😮 所以开始和DS老师探讨新方法。DS老师这人不咋行，好方案藏着掖着，拷问了半天才有了下面的简洁的方法： themes/next/layout/_third-party/comments/valine.swig中，在new Valine({ })的括号里，把visitor设置成 1visitor : (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') ? false : {{ theme.valine.visitor }}, 这样子，在hexo s下访问localhost查看文章不会被计数。DS说这是把hexo s和hexo d两个环境隔离了，所以说如果hexo s下出现文章阅读数为零的情况算正常（我就是这样） 当然了，如果要看阅读数，就要访问hexo d部署后的网站了，记得不要点进文章去看，不然还是会被计数 麻烦是麻烦了点，但功能至少是实现了","link":"/2025/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1blog%E4%BC%98%E5%8C%96/"},{"title":"湾区杯初赛WriteUp&amp;复现","text":"和X2c的nixware、Ky4niT3师傅参加了线上初赛，但是寄了。第一次组队参赛，还是太菜了。Re方向解了一道，然后和师傅们拼凑出了一道。基本就是签到题靠AI，难题没思路，见识还是太少了 WriteUphardtest 附件程序用IDA打开，shift+F12在字符串表通过关键字“flag:”可以找到main函数位置 以下是优化后的main函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112__int64 __fastcall main(int a1, char **a2, char **a3){ unsigned int seed; // eax unsigned __int64 scale1; // rax void *temp1; // rsp unsigned __int64 scale2; // rax void *temp2; // rsp char temp; // al _QWORD buf[2]; // [rsp+8h] [rbp-F0h] BYREF __int64 i_2; // [rsp+18h] [rbp-E0h] __int64 v12; // [rsp+20h] [rbp-D8h] char input; // [rsp+29h] [rbp-CFh] BYREF char judge; // [rsp+2Ah] [rbp-CEh] char randNum; // [rsp+2Bh] [rbp-CDh] int j; // [rsp+2Ch] [rbp-CCh] int i; // [rsp+30h] [rbp-C8h] int length; // [rsp+34h] [rbp-C4h] __int64 v19; // [rsp+38h] [rbp-C0h] __int64 Buf; // [rsp+40h] [rbp-B8h] __int64 v21; // [rsp+48h] [rbp-B0h] _QWORD *Enc; // [rsp+50h] [rbp-A8h] char flag[104]; // [rsp+58h] [rbp-A0h] BYREF unsigned __int64 v24; // [rsp+C0h] [rbp-38h] v24 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); seed = time(0LL); srand(seed); randNum = rand() % 255 + 1; printf(&quot;input your number(1-255): &quot;); if ( __isoc99_scanf(&quot;%d&quot;, &amp;input) == 1 &amp;&amp; randNum == input ) { while ( getchar() != 10 ) ; printf(&quot;flag: &quot;); fgets(flag, 100, stdin); // 获取flag输入 flag[strcspn(flag, &quot;\\n&quot;)] = 0; length = strlen(flag); v19 = length - 1LL; i_2 = length; v12 = 0LL; buf[0] = length; buf[1] = 0LL; scale1 = 16 * ((length + 15LL) / 0x10uLL); // 在动态分配栈上的内存 while ( buf != (buf - (scale1 &amp; 0xFFFFFFFFFFFFF000LL)) ) ; temp1 = alloca(scale1 &amp; 0xFFF); if ( (scale1 &amp; 0xFFF) != 0 ) *(&amp;buf[-1] + (scale1 &amp; 0xFFF)) = *(&amp;buf[-1] + (scale1 &amp; 0xFFF)); Buf = buf; // Buf指向分配的内存 encrypt1(flag, buf); // 对flag进行加密，加密结果实际上由Buf记录，buf是一个通用的缓存空间 v21 = length - 1LL; scale2 = 16 * ((length + 15LL) / 0x10uLL); // 再次动态分配栈上的内存 while ( buf != (buf - (scale2 &amp; 0xFFFFFFFFFFFFF000LL)) ) ; temp2 = alloca(scale2 &amp; 0xFFF); if ( (scale2 &amp; 0xFFF) != 0 ) *(&amp;buf[-1] + (scale2 &amp; 0xFFF)) = *(&amp;buf[-1] + (scale2 &amp; 0xFFF)); Enc = buf; // Enc指向分配的内存 for ( i = 0; i &lt; length; ++i ) { temp = encrypt2(*(Buf + i)); // 对上一轮加密的结果再进行一次加密，加密结果由Enc记录 *(Enc + i) = temp; } judge = 1; for ( j = 0; j &lt; length; ++j ) { if ( *(Enc + j) != byte_2120[j] ) // 判断加密结果是否正确 { judge = 0; break; } } if ( judge ) puts(&quot;right&quot;); return 0LL; } else { puts(&quot;error&quot;); return 1LL; }}__int64 __fastcall encrypt1(const char *flag, __int64 buf){ __int64 count; // rax signed int i; // [rsp+14h] [rbp-1Ch] signed int length; // [rsp+18h] [rbp-18h] length = strlen(flag); for ( i = 0; ; ++i ) { count = i; if ( i &gt;= length ) break; *(i + buf) = rol(flag[i], (i % 7) + 1); // return (flag[i] &lt;&lt; ((i%7)+1)) | (flag[i] &gt;&gt; (8 - ((i%7)+1))) } return count;}__int64 __fastcall encrypt2(char Buf_i){ unsigned __int8 v1; // al unsigned __int8 v3; // [rsp+15h] [rbp-3h] v1 = rol(Buf_i ^ 0x5Au, 3); // return (a1^0x5Au &lt;&lt; 3) | (a1^0x5Au &gt;&gt; (8 - 3)); v3 = sub_1313((16 * ((3 * (v1 &gt;&gt; 4)) &amp; 0xF)) | (5 * (v1 &amp; 0xF)) &amp; 0xFu);// AI说是模幂运算函数，计算a1^(255) mod 257 return byte_2020[ror(v3, 2)]; // return (v3 &gt;&gt; 2) | (v3 &lt;&lt; (8 - 2));此处建立了映射关系} 笔者加解密这一块太菜了，没有数学头脑，只能依靠AI解密了（因为涉及数论，笔者还没学过） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970def rol(b, n): n %= 8 return ((b &lt;&lt; n) | (b &gt;&gt; (8 - n))) &amp; 0xFFdef ror(b, n): n %= 8 return ((b &gt;&gt; n) | (b &lt;&lt; (8 - n))) &amp; 0xFFdef mod_inv(a, mod=257): # 计算a在模257下的逆元，使用费马小定理 return pow(a, 255, mod)byte_2020 = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]# 构建反向映射rev_2020 = {}for idx, val in enumerate(byte_2020): rev_2020[val] = idxenc_data = [ 0x97, 0xD5, 0x60, 0x43, 0xB4, 0x10, 0x43, 0x73, 0x0F, 0xDA, 0x43, 0xCD, 0xD3, 0xE8, 0x73, 0x4A, 0x94, 0xC3, 0xCD, 0x71, 0xBD, 0xDC, 0x97, 0x1A]# 逆向encrypt2enc1_out = []for i, c in enumerate(enc_data): idx = rev_2020[c] # 得到索引（即v3循环右移2位后的值） v3 = rol(idx, 2) # 循环左移2位得到v3（原循环右移2位的逆） # 如果v3为0？但原代码中a1不为0才计算，这里假设v3不为0 if v3 == 0: x = 0 else: x = mod_inv(v3, 257) A = (x &gt;&gt; 4) &amp; 0xF B = x &amp; 0xF high = (11 * A) &amp; 0xF low = (13 * B) &amp; 0xF v1 = (high &lt;&lt; 4) | low tmp = ror(v1, 3) # 循环右移3位（原循环左移3位的逆） enc1_out.append(tmp ^ 0x5A)# 逆向encrypt1flag = []for i, c in enumerate(enc1_out): n = (i % 7) + 1 flag_char = ror(c, n) # 循环右移n位（原循环左移n位的逆） flag.append(flag_char)# 转换为字符串flag_str = ''.join(chr(b) for b in flag)print(flag_str) minigame 微信小程序逆向，第一次遇到这个类型的题 用wedecode解包附件，输出结果在wedecode-main/OUTPUT/default里 没有这方面的经验，让AI分析项目，发现utils/validator.wasm里有检验逻辑。wasm是一种二进制文件，可以转成wat阅读（类似汇编）。使用在线工具wasm2wat demo把wasm转成wat: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(module (type $t0 (func (param i32) (result i32))) (type $t1 (func)) (func $c (export &quot;c&quot;) (type $t0) (param $p0 i32) (result i32) (local $l1 i32) (local $l2 i32) (local $l3 i32) (local $l4 i32) (if $I6 (i32.ne (block $B0 (result i32) (block $B1 (block $B2 (br_if $B2 (i32.eqz (i32.and (local.tee $l3 (local.get $p0)) (i32.const 3)))) (drop (br_if $B0 (i32.const 0) (i32.eqz (i32.load8_u (local.get $p0))))) (loop $L3 (br_if $B2 (i32.eqz (i32.and (local.tee $p0 (i32.add (local.get $p0) (i32.const 1))) (i32.const 3)))) (br_if $L3 (i32.load8_u (local.get $p0)))) (br $B1)) (loop $L4 (local.set $p0 (i32.add (local.tee $l1 (local.get $p0)) (i32.const 4))) (br_if $L4 (i32.eq (i32.and (i32.or (i32.sub (i32.const 16843008) (local.tee $l4 (i32.load (local.get $l1)))) (local.get $l4)) (i32.const -2139062144)) (i32.const -2139062144)))) (loop $L5 (local.set $l1 (i32.add (local.tee $p0 (local.get $l1)) (i32.const 1))) (br_if $L5 (i32.load8_u (local.get $p0))))) (i32.sub (local.get $p0) (local.get $l3))) (i32.const 38)) (then (return (i32.const 0)))) (loop $L7 (block $B8 (local.set $l1 (i32.eq (local.tee $p0 (i32.xor (i32.load8_u offset=1024 (local.get $l2)) (i32.load8_s (i32.add (local.get $l2) (local.get $l3))))) (i32.const 153))) (br_if $B8 (i32.ne (local.get $p0) (i32.const 153))) (br_if $L7 (i32.ne (local.tee $l2 (i32.add (local.get $l2) (i32.const 1))) (i32.const 38))))) (local.get $l1)) (func $b (export &quot;b&quot;) (type $t1)) (memory $a (export &quot;a&quot;) 258 258) (data $d0 (i32.const 1024) &quot;\\ff\\f5\\f8\\fe\\e2\\ff\\f8\\fc\\a9\\fb\\ab\\ae\\fa\\ad\\ac\\a8\\fa\\ae\\ab\\a1\\a1\\af\\ae\\f8\\ac\\af\\ae\\fc\\a1\\fa\\a8\\fb\\fb\\ad\\fc\\ac\\aa\\e4&quot;)) 由AI分析知，逻辑主要是把输入的内容与密文异或，异或的结果要等于153。等价于将输入的内容和153异或要等于密文。解密就是拿153异或密文。exp: 123456789enc = [ 0xff, 0xf5, 0xf8, 0xfe, 0xe2, 0xff, 0xf8, 0xfc, 0xa9, 0xfb, 0xab, 0xae, 0xfa, 0xad, 0xac, 0xa8, 0xfa, 0xae, 0xab, 0xa1, 0xa1, 0xaf, 0xae, 0xf8, 0xac, 0xaf, 0xae, 0xfc, 0xa1, 0xfa, 0xa8, 0xfb, 0xfb, 0xad, 0xfc, 0xac, 0xaa, 0xe4]flag = ''.join([chr(data ^ 153) for data in enc])print(flag) 复现strangapp 待更新…","link":"/2025/10/03/%E6%B9%BE%E5%8C%BA%E6%9D%AF%E5%88%9D%E8%B5%9BWriteUp&%E5%A4%8D%E7%8E%B0/"},{"title":"记一次blog重建","text":"部署Vercel失误后的blog重建（基于hexo+NexT8.23.0，采用utterances评论系统和firestore数据记录） OK，这是笔者在依赖AI盲目把博客部署到Vercel上导致博客崩溃后的博客重建记录 记录的原因首先是更新“记一次blog优化”的内容，还有新版本NexT的一些个人配置（新版本NexT的教程好像不多，评论系统和访客计数系统要自己琢磨好一会儿） 首页分类卡片实现 因为是对“记一次blog优化”的更新，所以这部分直接贴代码了（注：区别更多是在文件名从swig变成了njk） themes/next/layout/index.njk： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263{% extends '_layout.njk' %}{% import '_macro/sidebar.njk' as sidebar_template with context %}{% block title %}{{ title }}{%- if theme.index_with_subtitle and subtitle %} - {{ subtitle }}{%- endif %}{% endblock %}{% block class %}index categories-page{% endblock %}{% block content %}{# 这部分是实现category卡片，最后面还有没category的文章的处理，因为我严格了每篇文章有category，就没管画面如何了 #}{% if site.categories.length &gt; 0 %}&lt;div class=&quot;category-cards-container&quot;&gt; {% for cat in site.categories.toArray() %} &lt;div class=&quot;category-card&quot;&gt; &lt;div class=&quot;category-header&quot;&gt; &lt;h2 class=&quot;category-name&quot;&gt;{{ cat.name }}&lt;/h2&gt; &lt;span class=&quot;post-count&quot;&gt;{{ cat.posts.length }}篇文章&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;{# 这一部分实现卡片显示包含的文章的标题，数量可以改下面的limit()的数字 #} &lt;div class=&quot;recent-posts-list&quot;&gt; {% for post in cat.posts.sort('date', -1).limit(3).toArray() %} &lt;div class=&quot;recent-post-item&quot;&gt; &lt;a href=&quot;{{ url_for(post.path) }}&quot; class=&quot;post-title&quot; title=&quot;{{ post.title }}&quot;&gt; {{ post.title | truncate(18) }} &lt;/a&gt; &lt;span class=&quot;post-date&quot;&gt; {% if post.updated %} {{ post.updated.format('MM/DD') }} {% else %} {{ post.date.format('MM/DD') }} {% endif %} &lt;/span&gt; &lt;/div&gt; {% endfor %} &lt;div class=&quot;more-posts-wrapper&quot;&gt; &lt;a href=&quot;{{ url_for('/categories/' + cat.name + '/') }}&quot; class=&quot;more-posts-button&quot;&gt; 更多文章 → &lt;/a&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;{% endfor %}&lt;/div&gt;{% else %} &lt;div class=&quot;no-categories-notice&quot;&gt; &lt;p&gt;暂无分类数据，请为文章添加分类&lt;/p&gt; &lt;/div&gt; {% endif %}{% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} source/_data/styles.styl： 得先在next/config.yml里打开这个文件的支持（可能是新特性吧，笔者记得之前没改过config设置就有这个文件了，但是现在得打开支持并手动创建_data文件夹和styles.styl等文件），在custom_file_path里删除style的注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* 分类卡片样式 - 安全追加 */.category-cards-container { margin: 40px auto; max-width: 1200px; padding: 0 20px; .category-card { background: rgba(255,255,255,0.85); /* 半透明白色，与你的opacity 0.85协调 */ border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.1); margin-bottom: 25px; padding: 25px; transition: all 0.3s ease; backdrop-filter: blur(2px); /* 毛玻璃效果增强背景融合 */ border: 1px solid rgba(255,255,255,0.3); /* 柔和边框 */ &amp;:hover { transform: translateY(-5px); box-shadow: 0 5px 25px rgba(0,0,0,0.15); } .category-name { color: #2c3e50; font-size: 1.4em; margin: 0 0 8px 0; font-weight: 600; } .post-count { color: #7f8c8d; font-size: 0.9em; display: block; } }}/* 这部分是我自己用的背景图的设置 */body { background-image: url(/images/background.jpg); background-repeat: no-repeat; background-attachment: fixed; background-size: 100% 100%; opacity: 0.85;}/* ======================== *//* 分类卡片内的文章列表样式 *//* ======================== */.category-card { position: relative; /* 为毛玻璃效果提供定位上下文 */ .category-header { margin-bottom: 15px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.08); } .recent-posts-list { margin-top: 10px; .recent-post-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; transition: all 0.2s ease; &amp;:hover { transform: translateX(3px); } .post-title { color: #34495e; font-size: 0.95em; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; &amp;:hover { color: #3498db; text-decoration: underline; } } .post-date { color: #95a5a6; font-size: 0.8em; font-family: 'Arial', sans-serif; flex-shrink: 0; } } } * { border-bottom: none !important; box-shadow: none !important; } .category-header, .recent-post-item, .recent-posts-list { border: none !important; border-bottom: none !important; }}/* 更多文章按钮样式 */.more-posts-wrapper { text-align: left; margin-top: 12px; padding-top: 10px; .more-posts-button { display: inline-block; color:rgb(72, 168, 241); font-size: 0.9em; padding: 6px 12px; border-radius: 4px; transition: all 0.3s ease; background: rgba(52, 152, 219, 0.1); &amp;:hover { background: rgba(52, 152, 219, 0.2); transform: translateX(3px); } &amp;:hover::after { margin-left: 8px; } }}/* 响应式调整 */@media (max-width: 767px) { .category-card { padding: 18px; .recent-post-item { flex-direction: column; align-items: flex-start; .post-date { margin-top: 3px; align-self: flex-end; } } }}.posts-container{ margin: 40px auto; max-width: 1200px; padding: 0 20px;} 效果请见“记一次blog优化” 点击更多文章后的文章列表实现 仍然是基于原来的Index.njk themes/next/layout/category.njk： 123456789101112131415161718192021222324252627282930{% extends '_layout.njk' %}{% import '_macro/sidebar.njk' as sidebar_template with context %}{% block title %} {{ page.category }} | {{ __('title.category') }} | {{ config.title }}{% if theme.index_with_subtitle and subtitle %} - {{ subtitle }}{% endif %}{% endblock %}{% block class %}index posts-expand{% endblock %}{% block content %}&lt;div class=&quot;category-title&quot; style=&quot;text-align: center; margin: 30px 0;&quot;&gt; &lt;h1&gt;{{ page.category }}&lt;/h1&gt; &lt;/div&gt;{# 新增包裹容器并添加间距 class PS:这一部分是个人感觉列表太贴近侧边栏了，所以和首页分类卡片的位置设置保持一致了#} &lt;div class=&quot;posts-container&quot; style=&quot;margin-right: 30px ;&quot;&gt; {%- for post in page.posts.toArray() %} {{ partial('_macro/post.njk', {post: post, is_index: true}) }} {%- endfor %} {%- include '_partials/pagination.njk' -%} {% endblock %}{% block sidebar %} {{ sidebar_template.render(false) }}{% endblock %} 效果仍见上一篇博客 删除侧边栏目录下划线与文末标签的“#” 这两个部分没有变动，除了文件名的后缀改变了，其余都一样。详见上一篇博客。 utterances评论系统 新版本NexT已经不支持valine了，给的选项只有： 所以笔者选了utterances。这个系统好像和github有点关系 在next/config.yml的comments里把active改成utterances 然后需要给github仓库安装utterances，访问https://github.com/apps/utterances ，然后点击Install 在跳转的页面勾选only select repositories，然后选择博客仓库 点击install就可以了 要注意的是，hexo s下是调试不了这个功能的（虽然不知道我为什么要在hexo s下调试这个功能），会报错，但是部署后是可以正常工作的 firestore统计访问人数 NexT8.23.0不支持Valine了，得重新选择数据统计系统。firestore是google的产品，因此需要科学上网。 参考大佬博客：https://weirenxue.github.io/2021/06/11/hexo_next_firestore_visitors/ 步骤很简洁完整了，但是个人实现的时候会有一些问题，接下来详细介绍相关步骤 首先，在next/config.yml里启用firestore： 有两个空需要填写，apikey和projectId。不急，需要先有firestore的项目。接下来访问firebase：https://console.firebase.google.com/ （科学上网） 登录后点击“创建项目” 接下来按照引导走下去，开发者计划、AI辅助、google analytics根据个人需求选择，点击继续并稍等片刻就创建成功了。 点击新项目，在左上角“项目概述”里点“项目设置” 这时候可以看见项目ID等信息了，但是api还没有显示 接下来在左侧边栏“构建”里找到“Authentication”，点击“开始”（哇，这个界面设置我还以为google不让手动设置只能用AI了，瞎按了半天才知道点”开始”） 接下来选择登陆方式登录即可。我选择谷歌，点击右上角启用，项目公开名称默认即可，项目支持邮箱选择个人谷歌邮箱 回到项目设置页面，可以看到api已经出现了 接下来就可以把next/config.yml里的projectId和apiKey填上了 然后打开左侧边栏“构建”里的“Firestore Database”，点击“创建数据库” 接下来的页面，设置位置（数据库ID似乎不能改动），然后下一步 接下来选择测试模式，等待预配Cloud Firestore 加载成功后长这样 接下来重新部署博客后就可以测试计数机制是否正常了。但是笔者在这一步折腾了很久，因为调试的时候发现： 1.数据库的信息在第一次启用计数机制后会自动生成，但是对这些信息进行改动后计数机制就失效了 2.即使在莫名其妙的情况下（可能是关闭firestore配置后再次开启的情况）重新初始化了数据库，计数1次之后再怎么访问（如刷新、关闭页面重新打开）也不会记录第2次 还有一些调试过程发现的问题，但是调试过程太乱了不好描述，所以下面直接指出问题并给出解决方案 首先，firestore的计数机制有点特别，它使用了localStorage来判断是否访问过文章，如果访问过文章，将不会出现第二次计数的情况（永远不会，除非重置localStorage）。这也解释了为什么改动数据信息后计数机制会失效：因为没有第二次计数，所以数据库信息不会再更新。因此需要对计数机制进行一些优化，优化方案来自DeepSeek，需要改动的配置为next/source/js/third-party/statistics/firestore.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* global CONFIG, firebase */firebase.initializeApp({ apiKey : CONFIG.firestore.apiKey, projectId: CONFIG.firestore.projectId});(function() { const getCount = (doc, increaseCount) =&gt; { // IncreaseCount will be false when not in article page return doc.get().then(d =&gt; { // Has no data, initialize count let count = d.exists ? d.data().count : 0; // If first view this article if (increaseCount) { // Increase count count++; doc.set({ count }); } return count; }); }; const db = firebase.firestore(); const articles = db.collection(CONFIG.firestore.collection); document.addEventListener('page:loaded', () =&gt; { if (CONFIG.page.isPost) { // Fix issue #118 // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent const title = document.querySelector('.post-title').textContent.trim(); const doc = articles.doc(title); let increaseCount = CONFIG.hostname === location.hostname; if (sessionStorage.getItem(title)) { increaseCount = false; } else { // Mark as visited in current session sessionStorage.setItem(title, true); } getCount(doc, increaseCount).then(count =&gt; { document.querySelector('.firestore-visitors-count').innerText = count; }).catch(e =&gt; console.error('Error updating count:', e)); } else if (CONFIG.page.isHome) { const promises = [...document.querySelectorAll('.post-title')].map(element =&gt; { const title = element.textContent.trim(); const doc = articles.doc(title); return getCount(doc); }); Promise.all(promises).then(counts =&gt; { const metas = document.querySelectorAll('.firestore-visitors-count'); counts.forEach((val, idx) =&gt; { metas[idx].innerText = val; }); }).catch(e =&gt; console.error('Error fetching counts:', e)); } });})(); 简单解释一下优化的主要思路：使用sessionStorage替换localStorage，计数机制变为会话级，即每次打开文章都会计数，而刷新不会计数 那么接下来就要设置一下数据库的规则了。大佬的安全规则好像有一些漏洞，下面是DeepSeek生成的安全规则： 1234567891011121314151617181920212223rules_version = '2';service cloud.firestore { match /databases/{database}/documents { // 针对文章集合的规则 match /articles/{articleId} { // 允许所有人读取 allow read: if true; // 创建新文档时的规则 allow create: if request.resource.data.keys().hasOnly([&quot;count&quot;]) &amp;&amp; request.resource.data.count == 1; // 更新文档时的规则（确保count只能+1） allow update: if request.resource.data.keys().hasOnly([&quot;count&quot;]) &amp;&amp; request.resource.data.count == resource.data.count + 1; } // 禁止其他所有操作 match /{document=**} { allow read, write: if false; } }} 打开“Firestore Database”的“规则”，把规则粘贴进去，点击发布即可","link":"/2025/06/05/%E8%AE%B0%E4%B8%80%E6%AC%A1blog%E9%87%8D%E5%BB%BA/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"WriteUp","slug":"WriteUp","link":"/tags/WriteUp/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"逆向开发","slug":"逆向开发","link":"/tags/%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/"},{"name":"Windows开发","slug":"Windows开发","link":"/tags/Windows%E5%BC%80%E5%8F%91/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"杂记","slug":"杂记","link":"/tags/%E6%9D%82%E8%AE%B0/"},{"name":"周记","slug":"周记","link":"/tags/%E5%91%A8%E8%AE%B0/"},{"name":"复现","slug":"复现","link":"/tags/%E5%A4%8D%E7%8E%B0/"}],"categories":[{"name":"WriteUp&amp;复现","slug":"WriteUp-复现","link":"/categories/WriteUp-%E5%A4%8D%E7%8E%B0/"},{"name":"Reverse学习笔记","slug":"Reverse学习笔记","link":"/categories/Reverse%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"逆向开发","slug":"逆向开发","link":"/categories/%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"周记","slug":"周记","link":"/categories/%E5%91%A8%E8%AE%B0/"}],"pages":[{"title":"about","text":"关于我 南京邮电大学2024级信息安全本科在读 X2cT34mRe手 学习方向是主要是逆向工程、二进制安全 本站主要是为了记录学习经历，希望可以为像我一样迷茫的人提供一些帮助 分享的文章会尽量保证可读性和可实践性 联系方式 微信：bywnxhx_ QQ：2175241477 博客：https://sydzi.github.io/ 欢迎师傅们提供指导建议","link":"/about/index.html"},{"title":"","text":"/* global IcarusThemeSettings, firebase */ // Firebase Counter - 阅读量统计功能 if (IcarusThemeSettings && IcarusThemeSettings.services && IcarusThemeSettings.services.firebase && IcarusThemeSettings.services.firebase.enable) { // 初始化Firebase try { // 确保firebase对象存在 if (typeof firebase === 'undefined') { console.error('Firebase library not loaded'); // 如果Firebase库未加载，隐藏计数器元素 document.querySelectorAll('.firestore-visitors-count').forEach(el => { el.style.display = 'none'; }); } else { firebase.initializeApp({ apiKey: IcarusThemeSettings.services.firebase.apiKey, projectId: IcarusThemeSettings.services.firebase.projectId }); // 开发环境检测 const isLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname); const isDevelopment = isLocalhost || window.location.hostname.includes('192.168.'); // 移除所有调试日志输出 // 获取数据库引用 const db = firebase.firestore(); const articlesCollection = IcarusThemeSettings.services.firebase.collection || 'articles'; const articles = db.collection(articlesCollection); // 获取阅读次数函数 const getCount = (doc, increaseCount) => { // 获取文档数据 return doc.get().then(d => { // 初始化计数 let count = d.exists ? d.data().count : 0; // 如果需要增加计数（只在文章页面且未在同一会话访问过） if (increaseCount) { // 增加计数 count++; return doc.set({ count }).then(() => { if (isDevelopment) console.log('计数已更新:', count); return count; }).catch(error => { console.error('Error updating count:', error); return count; // 返回增加前的计数 }); } return count; }).catch(error => { console.error('Error getting count:', error); // 出错时返回默认值0 return 0; }); }; // 处理阅读计数的函数 const handleViewCount = () => { // 获取当前URL路径 const currentPath = window.location.pathname; // 增强首页识别：使用多个可能的选择器 const isIndexPage = document.querySelector('.article-list') !== null || document.querySelector('.article-card-list') !== null || document.querySelectorAll('.article-card').length > 0 || // 降低阈值以适应首页 (currentPath === '/' && document.querySelector('article.article') !== null); // 特殊处理：根路径+article.article元素 // 增强文章页面识别：使用更精确的选择器组合 // 重要：首页优先判断，且文章页判断要排除首页的情况，并增加特定的文章页特征 const isArticlePage = !isIndexPage && ( // 传统文章页选择器 (document.querySelector('.article-container') !== null && document.querySelector('.article-content') !== null) || (document.querySelector('article.post') !== null && document.querySelector('.article-content') !== null) || document.querySelector('[id=\"post-content\"]') !== null || // 针对hexo s环境的增强选择器，但需要确保不是首页 (document.querySelector('article.article') !== null && document.querySelector('article.card-content.article') !== null && document.querySelectorAll('.article-card').length === 0 && currentPath !== '/') ); // 页面类型信息 - 仅在开发环境显示 if (isDevelopment) { console.log(`[Firebase] 当前页面类型: ${isArticlePage ? '文章页' : isIndexPage ? '首页' : '其他页面'}`); } if (isArticlePage) { // 文章页面处理 const titleElement = document.querySelector('.title.is-3, .title.is-4-mobile'); const countElement = document.querySelector('.firestore-visitors-count'); if (titleElement && countElement) { const title = titleElement.textContent.trim(); const doc = articles.doc(title); // 确定是否增加计数：不在本地开发环境且同一会话未访问过 let increaseCount = !isDevelopment; if (sessionStorage.getItem(title)) { increaseCount = false; } else { // 标记为在当前会话中已访问 sessionStorage.setItem(title, true); } getCount(doc, increaseCount).then(count => { countElement.innerText = count; }).catch(e => { // 移除错误日志 }); } else { // 静默处理：未找到文章标题或计数元素 } } else if (isIndexPage) { // 首页文章列表处理 // 修改选择器以匹配实际HTML结构 // 首页文章结构: .card > .card-content.article > .title.is-3.is-size-4-mobile const titleElements = document.querySelectorAll( '.card .article .title.is-3, .card .article .title.is-4-mobile, ' + '.card article .title.is-3, .card article .title.is-4-mobile, ' + '.card .article p.title, .card article p.title' ); const countElements = document.querySelectorAll('.card .article .firestore-visitors-count, .card article .firestore-visitors-count'); // 移除首页元素检测日志 if (titleElements.length > 0 && countElements.length > 0) { const promises = [...titleElements].map(element => { const title = element.textContent.trim(); const doc = articles.doc(title); // 首页只获取计数，不增加计数 return getCount(doc, false).then(count => { return count; }); }); Promise.all(promises).then(counts => { counts.forEach((val, idx) => { if (countElements[idx]) { countElements[idx].innerText = val; } }); }).catch(e => { // 错误处理：尝试显示一些默认值或替代文本 countElements.forEach(el => { if (el.innerText === '0') { el.innerText = '加载中...'; } }); }); } else { // 尝试使用更通用的选择器 const fallbackTitleElements = document.querySelectorAll('.article-card a[href^=\"/\"]'); const fallbackCountElements = document.querySelectorAll('.article-card .firestore-visitors-count'); if (fallbackTitleElements.length > 0 && fallbackCountElements.length > 0) { // 这里可以添加备选逻辑 } } } else { // 静默处理：当前页面既不是文章页也不是首页 } }; // 监听传统页面加载完成事件 document.addEventListener('DOMContentLoaded', () => { handleViewCount(); }); // 监听PJAX页面加载完成事件（适配Icarus主题的PJAX机制） document.addEventListener('page:loaded', () => { handleViewCount(); }); } } catch (error) { // 移除初始化失败日志 // 如果初始化失败，尝试隐藏计数器元素以避免显示为0 document.querySelectorAll('.firestore-visitors-count').forEach(el => { el.style.display = 'none'; }); } }","link":"/js/firebase_counter.js"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}